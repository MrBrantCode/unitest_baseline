{
  "task_id": "taco_8235",
  "entry_point": "can_construct_bst",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) / (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) / (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) + (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) + (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) ** (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) ** (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[0] | check2[n - 1])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] | check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [2 << i for i in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [2 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [0 << i for i in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [0 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [0 << i for i in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [0 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [-1 << i for i in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [-1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if gcd(a[i], a[j]) > 1:",
      "mutated_line": "if gcd(a[i], a[j]) >= 1:",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) >= 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if gcd(a[i], a[j]) > 1:",
      "mutated_line": "if gcd(a[i], a[j]) <= 1:",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) <= 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if gcd(a[i], a[j]) > 1:",
      "mutated_line": "if gcd(a[i], a[j]) != 1:",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) != 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "GCD[i] += 1 << j",
      "mutated_line": "GCD[i] -= 1 << j",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] -= 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "GCD[j] += 1 << i",
      "mutated_line": "GCD[j] -= 1 << i",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] -= 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [2 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [2 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [0 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [0 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [0 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [0 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [-1 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [-1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [2 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [2 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [0 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [0 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [0 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [0 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [-1 << j for j in range(n + 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [-1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[1] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[1] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[-1] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[-1] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[1] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[1] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, n - i):",
      "mutated_line": "for j in range(2, n - i):",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(2, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, n - i):",
      "mutated_line": "for j in range(0, n - i):",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(0, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, n - i):",
      "mutated_line": "for j in range(0, n - i):",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(0, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for j in range(1, n - i):",
      "mutated_line": "for j in range(-1, n - i):",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(-1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(1, n - i):",
      "mutated_line": "for j in range(1, n + i):",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n + i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for j in range(1, n - i):",
      "mutated_line": "for j in range(1, n * i):",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n * i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) / (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) / (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) + (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) + (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) ** (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) ** (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) / (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) / (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) + (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) + (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) ** (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) ** (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [1 << i for i in range(n - 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n - 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [1 << i for i in range(n * 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n * 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if gcd(a[i], a[j]) > 1:",
      "mutated_line": "if gcd(a[i], a[j]) > 2:",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 2:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if gcd(a[i], a[j]) > 1:",
      "mutated_line": "if gcd(a[i], a[j]) > 0:",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 0:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if gcd(a[i], a[j]) > 1:",
      "mutated_line": "if gcd(a[i], a[j]) > 0:",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 0:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if gcd(a[i], a[j]) > 1:",
      "mutated_line": "if gcd(a[i], a[j]) > -1:",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > -1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [1 << j for j in range(n - 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n - 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [1 << j for j in range(n * 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n * 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [1 << j for j in range(n - 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n - 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [1 << j for j in range(n * 1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n * 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (2 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (2 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (0 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (0 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (0 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (0 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (-1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (-1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i - 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i * 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i * 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j - i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j - i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j * i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j * i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[1] & check2[n - 1])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[1] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[-1] & check2[n - 1])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[-1] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[1] & check2[n - 1])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[1] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[0] & check2[n + 1])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n + 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[0] & check2[n * 1])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n * 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [1 << i for i in range(n + 2)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 2)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [1 << i for i in range(n + 0)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 0)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [1 << i for i in range(n + 0)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 0)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "GCD = [1 << i for i in range(n + 1)]",
      "mutated_line": "GCD = [1 << i for i in range(n + -1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + -1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "GCD[i] += 1 << j",
      "mutated_line": "GCD[i] += 2 << j",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 2 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "GCD[i] += 1 << j",
      "mutated_line": "GCD[i] += 0 << j",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 0 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "GCD[i] += 1 << j",
      "mutated_line": "GCD[i] += 0 << j",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 0 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "GCD[i] += 1 << j",
      "mutated_line": "GCD[i] += -1 << j",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += -1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "GCD[j] += 1 << i",
      "mutated_line": "GCD[j] += 2 << i",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 2 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "GCD[j] += 1 << i",
      "mutated_line": "GCD[j] += 0 << i",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 0 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "GCD[j] += 1 << i",
      "mutated_line": "GCD[j] += 0 << i",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 0 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "GCD[j] += 1 << i",
      "mutated_line": "GCD[j] += -1 << i",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += -1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [1 << j for j in range(n + 2)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 2)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [1 << j for j in range(n + 0)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 0)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [1 << j for j in range(n + 0)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 0)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "check1 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check1 = [1 << j for j in range(n + -1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + -1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [1 << j for j in range(n + 2)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 2)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [1 << j for j in range(n + 0)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 0)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [1 << j for j in range(n + 0)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 0)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "check2 = [1 << j for j in range(n + 1)]",
      "mutated_line": "check2 = [1 << j for j in range(n + -1)]",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + -1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] | GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] | GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 2)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 2)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 0)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 0)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 0)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 0)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + -1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + -1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (2 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (2 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (0 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (0 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (0 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (0 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (-1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (-1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j - 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << (i + j) * 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << (i + j) * 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (2 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (2 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (0 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (0 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (0 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (0 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (-1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (-1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j + 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j * 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j * 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[0] & check2[n - 2])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 2])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[0] & check2[n - 0])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[0] & check2[n - 0])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = bool(check1[0] & check2[n - 1])",
      "mutated_line": "ans = bool(check1[0] & check2[n - -1])",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - -1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool((check1[0] | check2[i]) & GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool((check1[0] | check2[i]) & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] | GCD[j + i + 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] | GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i - j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i - j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i * j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i * j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 2)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 2)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 0)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 0)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 0)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 0)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + -1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + -1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] | GCD[j - 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] | GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 2)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 2)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 0)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 0)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 0)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 0)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - -1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - -1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i - 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i - 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i * 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i * 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool((check1[j] | check2[i + j]) & GCD[j + i + 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool((check1[j] | check2[i + j]) & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool((check1[j] | check2[i + j]) & GCD[j - 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool((check1[j] | check2[i + j]) & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[1] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[1] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[-1] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[-1] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[1] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[1] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 2])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 2])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 0])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 0])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 0])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 0])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)",
      "mutated_line": "check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + -1])) * (1 << i + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + -1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i - 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i - 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[(j + i) * 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[(j + i) * 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j + 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j + 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j * 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j * 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i - j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i - j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i * j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i * j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j - i + 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j - i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j * i + 1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j * i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 2])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 2])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 0])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 0])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 0])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 0])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)",
      "mutated_line": "check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + -1])) * (1 << i + j + 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + -1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i - j] & GCD[j - 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i - j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i * j] & GCD[j - 1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i * j] & GCD[j - 1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 2])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 2])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 0])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 0])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 0])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 0])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - 1])) * (1 << j - 1)",
      "mutated_line": "check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - -1])) * (1 << j - 1)",
      "code": "from math import gcd\n\ndef can_construct_bst(n: int, a: list) -> bool:\n    \"\"\"\n    Determines if it is possible to construct a binary search tree from the given vertices\n    such that the greatest common divisor of any two vertices connected by an edge is greater than 1.\n\n    Parameters:\n    n (int): The number of vertices.\n    a (list): A list of distinct integers representing the values of the vertices in ascending order.\n\n    Returns:\n    bool: True if it is possible to construct the binary search tree, False otherwise.\n    \"\"\"\n    GCD = [1 << i for i in range(n + 1)]\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) > 1:\n                GCD[i] += 1 << j\n                GCD[j] += 1 << i\n    check1 = [1 << j for j in range(n + 1)]\n    check2 = [1 << j for j in range(n + 1)]\n    for i in range(n):\n        check1[0] |= int(bool(check1[0] & check2[i] & GCD[i + 1])) * (1 << i + 1)\n        for j in range(1, n - i):\n            check1[j] |= int(bool(check1[j] & check2[i + j] & GCD[j + i + 1])) * (1 << i + j + 1)\n            check2[j + i] |= int(bool(check1[j] & check2[i + j] & GCD[j - -1])) * (1 << j - 1)\n    ans = bool(check1[0] & check2[n - 1])\n    return ans"
    }
  ]
}