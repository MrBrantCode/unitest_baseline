{
  "task_id": "taco_19004",
  "entry_point": "can_robot_reach_lab",
  "mutant_count": 123,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [+1, 0, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [+1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 1, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 1, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, -1, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, -1, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 1, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 1, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 0, 2, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 2, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 0, 0, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 0, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 0, 0, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 0, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 0, -1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, -1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 0, 1, 1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 1]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 0, 1, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, -1]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-1, 0, 1, 1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 1]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [1, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [-1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [-1, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [1, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 2, 0, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 2, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 0, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 0, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, -1, 0, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, -1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 1, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, -1, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, -1, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 1, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, 0, +1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, +1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 1\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = -1\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 1\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 1 and count == 0:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 and count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-2, 0, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-2, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-0, 0, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-0, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [-0, 0, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-0, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "d4i = [-1, 0, 1, 0]",
      "mutated_line": "d4i = [--1, 0, 1, 0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [--1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, 0, -2]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -2]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -0]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -0]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "d4j = [0, 1, 0, -1]",
      "mutated_line": "d4j = [0, 1, 0, --1]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, --1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if grid[i][j] == 'L':",
      "mutated_line": "if grid[i][j] != 'L':",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(5):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(5):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(3):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(3):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(0):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(0):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(1):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(1):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for i in range(4):",
      "mutated_line": "for i in range(-4):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(-4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ni = x + d4i[i]",
      "mutated_line": "ni = x - d4i[i]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x - d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ni = x + d4i[i]",
      "mutated_line": "ni = x * d4i[i]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x * d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "nj = y + d4j[i]",
      "mutated_line": "nj = y - d4j[i]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y - d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "nj = y + d4j[i]",
      "mutated_line": "nj = y * d4j[i]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y * d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n or 0 <= nj < m or grid[ni][nj] == '.':",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n or 0 <= nj < m or grid[ni][nj] == '.':\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count -= 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count != 1 or count == 0:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count != 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 1 or count != 0:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count != 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "grid[x][y] = '+'",
      "mutated_line": "grid[x][y] = ''",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = ''\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if grid[i][j] == 'L':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 < ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 < ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 > ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 > ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 == ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 == ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 < nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 < nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 > nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 > nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 == nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 == nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] != '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] != '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 2\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 0\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 0\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += -1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 2 or count == 0:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 2 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 0 or count == 0:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 0 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 0 or count == 0:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 0 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == -1 or count == 0:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == -1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 1 or count == 1:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 1:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 1 or count == -1:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == -1:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if count == 1 or count == 0:",
      "mutated_line": "if count == 1 or count == 1:",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 1:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(5):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(5):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(3):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(3):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(0):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(0):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(1):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(1):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(-4):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(-4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ni = x + d4i[q]",
      "mutated_line": "ni = x - d4i[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x - d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ni = x + d4i[q]",
      "mutated_line": "ni = x * d4i[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x * d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nj = y + d4j[q]",
      "mutated_line": "nj = y - d4j[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y - d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "nj = y + d4j[q]",
      "mutated_line": "nj = y * d4j[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y * d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n or 0 <= nj < m or grid[ni][nj] == '.':",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n or 0 <= nj < m or grid[ni][nj] == '.':\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(5):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(5):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(3):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(3):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(0):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(0):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(1):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(1):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for q in range(4):",
      "mutated_line": "for q in range(-4):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(-4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ni = i + d4i[q]",
      "mutated_line": "ni = i - d4i[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i - d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ni = i + d4i[q]",
      "mutated_line": "ni = i * d4i[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i * d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nj = j + d4j[q]",
      "mutated_line": "nj = j - d4j[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j - d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nj = j + d4j[q]",
      "mutated_line": "nj = j * d4j[q]",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j * d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n or 0 <= nj < m or grid[ni][nj] == '.':",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n or 0 <= nj < m or grid[ni][nj] == '.':\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if -1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if -1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and -1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and -1 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == ''):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == ''):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 < ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 < ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 > ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 > ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 == ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 == ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 < nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 < nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 > nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 > nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 == nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 == nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] != '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] != '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 < ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 < ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 > ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 > ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 == ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 == ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 < nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 < nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 > nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 > nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 == nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 == nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] != '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] != '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if -1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if -1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and -1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and -1 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == ''):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == ''):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if -1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if -1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 1 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and -1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and -1 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 1 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == '.':",
      "mutated_line": "if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == ''):",
      "code": "from collections import deque\n\ndef can_robot_reach_lab(grid, n, m):\n\n    def bfs(grid, n, m, que):\n        while que:\n            (x, y) = que.popleft()\n            count = 0\n            for i in range(4):\n                ni = x + d4i[i]\n                nj = y + d4j[i]\n                if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                    count += 1\n            if count == 1 or count == 0:\n                grid[x][y] = '+'\n                for q in range(4):\n                    ni = x + d4i[q]\n                    nj = y + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == '.'):\n                        que.append((ni, nj))\n    d4i = [-1, 0, 1, 0]\n    d4j = [0, 1, 0, -1]\n    que = deque()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'L':\n                for q in range(4):\n                    ni = i + d4i[q]\n                    nj = j + d4j[q]\n                    if 0 <= ni < n and 0 <= nj < m and (grid[ni][nj] == ''):\n                        que.append((ni, nj))\n                bfs(grid, n, m, que)\n                break\n    return grid"
    }
  ]
}