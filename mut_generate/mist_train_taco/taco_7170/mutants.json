{
  "task_id": "taco_7170",
  "entry_point": "calculate_maximum_spanning_tree_weights",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) / (2 * n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) / (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) * (2 * n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) * (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dd = (s - sum(relwt)) // n",
      "mutated_line": "dd = (s - sum(relwt)) / n",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) / n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dd = (s - sum(relwt)) // n",
      "mutated_line": "dd = (s - sum(relwt)) * n",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) * n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) - w[-1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) - w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) * (w[-1] * (n - 1))",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) * (w[-1] * (n - 1))\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // (2 / n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 / n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // (2 + n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 + n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // 2 ** n",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // 2 ** n\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "relwt = [(a - mn) // n for a in ab]",
      "mutated_line": "relwt = [(a - mn) / n for a in ab]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) / n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "relwt = [(a - mn) // n for a in ab]",
      "mutated_line": "relwt = [(a - mn) * n for a in ab]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) * n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dd = (s - sum(relwt)) // n",
      "mutated_line": "dd = (s + sum(relwt)) // n",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s + sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dd = (s - sum(relwt)) // n",
      "mutated_line": "dd = s * sum(relwt) // n",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = s * sum(relwt) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ret = [x + dd for x in relwt]",
      "mutated_line": "ret = [x - dd for x in relwt]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x - dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ret = [x + dd for x in relwt]",
      "mutated_line": "ret = [x * dd for x in relwt]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x * dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] / (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] / (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + (w[-1] + (n - 1))",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + (w[-1] + (n - 1))\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] ** (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] ** (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "c = [x + y for (x, y) in zip(Go, Tr)]",
      "mutated_line": "c = [x - y for (x, y) in zip(Go, Tr)]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x - y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "c = [x + y for (x, y) in zip(Go, Tr)]",
      "mutated_line": "c = [x * y for (x, y) in zip(Go, Tr)]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x * y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // (3 * n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (3 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // (1 * n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (1 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // (0 * n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (0 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // (1 * n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (1 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s = sum(ab) // (2 * n)",
      "mutated_line": "s = sum(ab) // (-2 * n)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (-2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "relwt = [(a - mn) // n for a in ab]",
      "mutated_line": "relwt = [(a + mn) // n for a in ab]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a + mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "relwt = [(a - mn) // n for a in ab]",
      "mutated_line": "relwt = [a * mn // n for a in ab]",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [a * mn // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] * (n + 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n + 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] * (n * 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n * 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[+1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[+1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] * (n - 2)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 2)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] * (n - 0)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 0)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] * (n - 0)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - 0)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-1] * (n - -1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-1] * (n - -1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:+1]) + w[-1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:+1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-2] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-2] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-0] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-0] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[-0] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[-0] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-1]) + w[--1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-1]) + w[--1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-2]) + w[-1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-2]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-0]) + w[-1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-0]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:-0]) + w[-1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:-0]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return sum(w[:-1]) + w[-1] * (n - 1)",
      "mutated_line": "return sum(w[:--1]) + w[-1] * (n - 1)",
      "code": "def calculate_maximum_spanning_tree_weights(T, test_cases):\n\n    def getWts(ab):\n        n = len(ab)\n        s = sum(ab) // (2 * n)\n        mn = min(ab)\n        relwt = [(a - mn) // n for a in ab]\n        dd = (s - sum(relwt)) // n\n        ret = [x + dd for x in relwt]\n        return ret\n\n    def sol(ab):\n        n = len(ab)\n        w = sorted(getWts(ab))\n        return sum(w[:--1]) + w[-1] * (n - 1)\n    results = []\n    for i in range(T):\n        (N, Go, Tr) = test_cases[i]\n        c = [x + y for (x, y) in zip(Go, Tr)]\n        results.append(sol(c))\n    return results"
    }
  ]
}