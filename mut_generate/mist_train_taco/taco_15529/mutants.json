{
  "task_id": "taco_15529",
  "entry_point": "shortest_path_from_src",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "ind[v] += 1",
      "mutated_line": "ind[v] -= 1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] -= 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = [math.inf] * n",
      "mutated_line": "dist = [math.inf] / n",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] / n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = [math.inf] * n",
      "mutated_line": "dist = [math.inf] + n",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] + n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dist = [math.inf] * n",
      "mutated_line": "dist = [math.inf] ** n",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] ** n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 1\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = -1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = -1\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[0] = 1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 1\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind = {i: 0 for i in range(n)}",
      "mutated_line": "ind = {i: 1 for i in range(n)}",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 1 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind = {i: 0 for i in range(n)}",
      "mutated_line": "ind = {i: -1 for i in range(n)}",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: -1 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ind = {i: 0 for i in range(n)}",
      "mutated_line": "ind = {i: 1 for i in range(n)}",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 1 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ind[v] += 1",
      "mutated_line": "ind[v] += 2",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 2\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ind[v] += 1",
      "mutated_line": "ind[v] += 0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 0\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ind[v] += 1",
      "mutated_line": "ind[v] += 0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 0\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ind[v] += 1",
      "mutated_line": "ind[v] += -1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += -1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "ind[nbr] -= 1",
      "mutated_line": "ind[nbr] += 1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] += 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[1] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[-1] = 0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[-1] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[0] = 0",
      "mutated_line": "dist[1] = 0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[1] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if dist[i] == math.inf:",
      "mutated_line": "if dist[i] != math.inf:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] != math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ind[nbr] -= 1",
      "mutated_line": "ind[nbr] -= 2",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 2\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ind[nbr] -= 1",
      "mutated_line": "ind[nbr] -= 0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 0\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ind[nbr] -= 1",
      "mutated_line": "ind[nbr] -= 0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 0\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ind[nbr] -= 1",
      "mutated_line": "ind[nbr] -= -1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= -1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if ind[nbr] == 0:",
      "mutated_line": "if ind[nbr] != 0:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] != 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dist[node] + weight < dist[nbr]:",
      "mutated_line": "if dist[node] + weight <= dist[nbr]:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight <= dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dist[node] + weight < dist[nbr]:",
      "mutated_line": "if dist[node] + weight >= dist[nbr]:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight >= dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dist[node] + weight < dist[nbr]:",
      "mutated_line": "if dist[node] + weight != dist[nbr]:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight != dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "dist[i] = -1",
      "mutated_line": "dist[i] = +1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = +1\n    return dist"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "q = deque([i for i in ind if ind[i] == 0])",
      "mutated_line": "q = deque([i for i in ind if ind[i] != 0])",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] != 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if ind[nbr] == 0:",
      "mutated_line": "if ind[nbr] == 1:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 1:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if ind[nbr] == 0:",
      "mutated_line": "if ind[nbr] == -1:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == -1:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if ind[nbr] == 0:",
      "mutated_line": "if ind[nbr] == 1:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 1:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if dist[node] + weight < dist[nbr]:",
      "mutated_line": "if dist[node] - weight < dist[nbr]:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] - weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if dist[node] + weight < dist[nbr]:",
      "mutated_line": "if dist[node] * weight < dist[nbr]:",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] * weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[nbr] = dist[node] + weight",
      "mutated_line": "dist[nbr] = dist[node] - weight",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] - weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[nbr] = dist[node] + weight",
      "mutated_line": "dist[nbr] = dist[node] * weight",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] * weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[i] = -1",
      "mutated_line": "dist[i] = -2",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -2\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[i] = -1",
      "mutated_line": "dist[i] = -0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -0\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[i] = -1",
      "mutated_line": "dist[i] = -0",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -0\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[i] = -1",
      "mutated_line": "dist[i] = --1",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 0])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = --1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([i for i in ind if ind[i] == 0])",
      "mutated_line": "q = deque([i for i in ind if ind[i] == 1])",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 1])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([i for i in ind if ind[i] == 0])",
      "mutated_line": "q = deque([i for i in ind if ind[i] == -1])",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == -1])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = deque([i for i in ind if ind[i] == 0])",
      "mutated_line": "q = deque([i for i in ind if ind[i] == 1])",
      "code": "from typing import List\nimport math\nfrom collections import deque\n\ndef shortest_path_from_src(n: int, m: int, edges: List[List[int]]) -> List[int]:\n    ind = {i: 0 for i in range(n)}\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((v, w))\n        ind[v] += 1\n    q = deque([i for i in ind if ind[i] == 1])\n    ans = deque()\n    while q:\n        node = q.popleft()\n        ans.append(node)\n        for (nbr, _) in adj[node]:\n            ind[nbr] -= 1\n            if ind[nbr] == 0:\n                q.append(nbr)\n    dist = [math.inf] * n\n    dist[0] = 0\n    while ans:\n        node = ans.popleft()\n        for (nbr, weight) in adj[node]:\n            if dist[node] + weight < dist[nbr]:\n                dist[nbr] = dist[node] + weight\n    for i in range(n):\n        if dist[i] == math.inf:\n            dist[i] = -1\n    return dist"
    }
  ]
}