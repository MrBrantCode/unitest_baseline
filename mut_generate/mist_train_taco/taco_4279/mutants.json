{
  "task_id": "taco_4279",
  "entry_point": "count_distinct_covered_points",
  "mutant_count": 316,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 1\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = -1\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 1\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans -= gcd(abs(a - A), abs(b - B)) + 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans -= gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "sum_intersections = 0",
      "mutated_line": "sum_intersections = 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 1\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "sum_intersections = 0",
      "mutated_line": "sum_intersections = -1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = -1\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "sum_intersections = 0",
      "mutated_line": "sum_intersections = 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 1\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ASR",
      "lineno": 45,
      "original_line": "sum_intersections += len(intersections) - 1",
      "mutated_line": "sum_intersections -= len(intersections) - 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections -= len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return ans - sum_intersections",
      "mutated_line": "return ans + sum_intersections",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans + sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return ans - sum_intersections",
      "mutated_line": "return ans * sum_intersections",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans * sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b - B)) - 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) - 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b - B)) * 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) * 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "sum_intersections += len(intersections) - 1",
      "mutated_line": "sum_intersections += len(intersections) + 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) + 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "sum_intersections += len(intersections) - 1",
      "mutated_line": "sum_intersections += len(intersections) * 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) * 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b - B)) + 2",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 2\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b - B)) + 0",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 0\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b - B)) + 0",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 0\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b - B)) + -1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + -1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i - 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i * 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) + a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) + a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = ((b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1)) * (a2 * (A2 - A1) * (b2 - b1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = ((b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1)) * (a2 * (A2 - A1) * (b2 - b1))\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) + (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) + (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) * ((b2 - b1) * (A2 - A1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) * ((b2 - b1) * (A2 - A1))\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 0 or num1 % den1 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 or num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "sum_intersections += len(intersections) - 1",
      "mutated_line": "sum_intersections += len(intersections) - 2",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 2\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "sum_intersections += len(intersections) - 1",
      "mutated_line": "sum_intersections += len(intersections) - 0",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 0\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "sum_intersections += len(intersections) - 1",
      "mutated_line": "sum_intersections += len(intersections) - 0",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 0\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "sum_intersections += len(intersections) - 1",
      "mutated_line": "sum_intersections += len(intersections) - -1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - -1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 2, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 0, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 0, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + -1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) - A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) - A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) * (A2 * (a2 - a1) * (B2 - B1)) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) * (A2 * (a2 - a1) * (B2 - B1)) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) / (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) / (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - (a2 * (A2 - A1) + (b2 - b1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - (a2 * (A2 - A1) + (b2 - b1))\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - (a2 * (A2 - A1)) ** (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - (a2 * (A2 - A1)) ** (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) / (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) / (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = B2 - B1 + (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = B2 - B1 + (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) ** (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) ** (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) / (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) / (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1 + (A2 - A1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1 + (A2 - A1))\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) ** (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) ** (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 == 0 and num1 % den1 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 == 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 0 and num1 % den1 != 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 != 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if a1 == a2:",
      "mutated_line": "if a1 != a2:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 != a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a + A), abs(b - B)) + 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a + A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a * A), abs(b - B)) + 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a * A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b + B)) + 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b + B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ans += gcd(abs(a - A), abs(b - B)) + 1",
      "mutated_line": "ans += gcd(abs(a - A), abs(b * B)) + 1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b * B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) / (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) / (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) + (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) + (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = ((b2 - B2) * (A2 - A1)) ** (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = ((b2 - B2) * (A2 - A1)) ** (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) / (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) / (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + (A2 * (a2 - a1) + (B2 - B1)) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + (A2 * (a2 - a1) + (B2 - B1)) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + (A2 * (a2 - a1)) ** (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + (A2 * (a2 - a1)) ** (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 / (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 / (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - (a2 + (A2 - A1)) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - (a2 + (A2 - A1)) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 ** (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 ** (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 + b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 + b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 * b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 * b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 + B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 + B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = B2 * B1 * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = B2 * B1 * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 + a1) - (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 + a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 * a1) - (b2 - b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 * a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 + b1) * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 + b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) - b2 * b1 * (A2 - A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - b2 * b1 * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 + A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 + A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)",
      "mutated_line": "den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 * A1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 * A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 1 and num1 % den1 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 1 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != -1 and num1 % den1 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != -1 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 1 and num1 % den1 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 1 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 0 and num1 * den1 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 * den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 0 and num1 + den1 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 + den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 0 and num1 % den1 == 1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 1:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 0 and num1 % den1 == -1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == -1:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if den1 != 0 and num1 % den1 == 0:",
      "mutated_line": "if den1 != 0 and num1 % den1 == 1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 1:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) - (num1 // den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) - (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) * ((num1 // den1 - A2) * (B2 - B1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) * ((num1 // den1 - A2) * (B2 - B1))\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "den2 = A2 - A1",
      "mutated_line": "den2 = A2 + A1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 + A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "den2 = A2 - A1",
      "mutated_line": "den2 = A2 * A1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 * A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 != 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 != 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) - (num1 // den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) - (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) * ((num1 // den1 - a2) * (b2 - b1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) * ((num1 // den1 - a2) * (b2 - b1))\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "den2 = a2 - a1",
      "mutated_line": "den2 = a2 + a1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 + a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "den2 = a2 - a1",
      "mutated_line": "den2 = a2 * a1",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 * a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 != 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 != 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) / (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) / (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2 + (A2 - A1)) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2 + (A2 - A1)) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) ** (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) ** (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 + a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 + a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 * a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 * a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 / (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 / (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + (A2 + (a2 - a1)) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + (A2 + (a2 - a1)) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 ** (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 ** (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 + B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 + B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 * B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 * B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 + A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 + A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 * A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 * A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 / (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 / (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 + (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 + (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 ** (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 ** (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) / (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) / (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2 + (B2 - B1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2 + (B2 - B1))\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) ** (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) ** (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 * den2 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 * den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 + den2 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 + den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 == 1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 1:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 == -1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == -1:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 == 1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 1:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 or (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 or (num1 // den1 - a2) * (num1 // den1 - a1) <= 0 or ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 or (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 or (num1 // den1 - a2) * (num1 // den1 - a1) <= 0 or ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 / (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 / (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 + (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 + (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 ** (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 ** (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) / (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) / (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2 + (b2 - b1))",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2 + (b2 - b1))\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) ** (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) ** (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 * den2 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 * den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 + den2 == 0:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 + den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 == 1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 1:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 == -1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == -1:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if num2 % den2 == 0:",
      "mutated_line": "if num2 % den2 == 1:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 1:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 or (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 or (num1 // den1 - a2) * (num1 // den1 - a1) <= 0 or ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 or (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 or (num1 // den1 - a2) * (num1 // den1 - a1) <= 0 or ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 + B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 + B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = b2 * B2 * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = b2 * B2 * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 + A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 + A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 * A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 * A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 + a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 + a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "mutated_line": "num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 * a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 * a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 + A1) + (num1 // den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 + A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 * A1) + (num1 // den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 * A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 // den1 + A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 + A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + num1 // den1 * A2 * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + num1 // den1 * A2 * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 + B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 + B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 * B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 * B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) < 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) < 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) > 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) > 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) == 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) == 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) < 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) < 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) > 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) > 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) == 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) == 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) < 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) < 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) > 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) > 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) == 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) == 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) < 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) < 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) > 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) > 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) == 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) == 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 // den1, num2 // den2) in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 + a1) + (num1 // den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 + a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 * a1) + (num1 // den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 * a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 // den1 + a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 + a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + num1 // den1 * a2 * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + num1 // den1 * a2 * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 + b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 + b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 * b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 * b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) < 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) < 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) > 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) > 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) == 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) == 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) < 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) < 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) > 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) > 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) == 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) == 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) < 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) < 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) > 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) > 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) == 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) == 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) < 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) < 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) > 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) > 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) == 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) == 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 // den1, num2 // den2) in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 / den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 / den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)",
      "mutated_line": "num2 = B2 * (A2 - A1) + (num1 * den1 - A2) * (B2 - B1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 * den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) / (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) / (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if num1 // den1 - A2 + (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if num1 // den1 - A2 + (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) ** (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) ** (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= -1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= -1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) / (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) / (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 - B2 + (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 - B2 + (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) ** (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) ** (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= -1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= -1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) / (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) / (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 - a2 + (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 - a2 + (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) ** (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) ** (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= -1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= -1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) / (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) / (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 - b2 + (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 - b2 + (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) ** (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) ** (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= -1):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= -1):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 / den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 / den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)",
      "mutated_line": "num2 = b2 * (a2 - a1) + (num1 * den1 - a2) * (b2 - b1)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 * den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) / (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) / (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if num1 // den1 - A2 + (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if num1 // den1 - A2 + (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) ** (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) ** (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= -1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= -1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 1 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) / (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) / (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 - B2 + (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 - B2 + (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) ** (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) ** (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= -1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= -1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 1 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) / (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) / (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 - a2 + (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 - a2 + (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) ** (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) ** (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= -1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= -1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 1) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) / (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) / (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 - b2 + (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 - b2 + (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) ** (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) ** (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= -1):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= -1):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 1):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 + A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 + A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if num1 // den1 * A2 * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if num1 // den1 * A2 * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 + A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 + A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 * A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 * A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 + B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 + B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 * B2 * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 * B2 * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 + B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 + B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 * B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 * B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 + a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 + a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 * a2 * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 * a2 * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 + a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 + a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 * a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 * a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 + b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 + b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 * b2 * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 * b2 * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 + b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 + b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 * b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 * b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 / den1, num2 // den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 / den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 * den1, num2 // den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 * den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 // den1, num2 / den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 / den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 // den1, num2 * den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 * den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 + A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 + A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if num1 // den1 * A2 * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if num1 // den1 * A2 * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 + A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 + A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 * A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 * A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 + B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 + B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 * B2 * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and num2 // den2 * B2 * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 + B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 + B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 * B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 * B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 + a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 + a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 * a2 * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and (num1 // den1 * a2 * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 + a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 + a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 * a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 * a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 + b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 + b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 * b2 * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and (num2 // den2 * b2 * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 + b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 + b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 * b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 * b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 / den1, num2 // den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 / den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 * den1, num2 // den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 * den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 // den1, num2 / den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 / den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if (num1 // den1, num2 // den2) not in m:",
      "mutated_line": "if (num1 // den1, num2 * den2) not in m:",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 * den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 / den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 / den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 * den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 * den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 / den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 / den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 * den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 * den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 / den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 / den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 * den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 * den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 / den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 / den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 * den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 * den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 / den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 / den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 * den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 * den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 / den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 / den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 * den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 * den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 / den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 / den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 * den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 * den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 / den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 / den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 * den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 * den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 / den1, num2 // den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 / den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 * den1, num2 // den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 * den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 // den1, num2 / den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 / den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 // den1, num2 * den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 * den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 / den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 / den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 * den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 * den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 / den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 / den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 * den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 * den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 / den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 / den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 * den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 * den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 / den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 / den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 * den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 * den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 / den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 / den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 * den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 * den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 / den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 / den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 * den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 * den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 / den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 / den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 * den2 - b2) * (num2 // den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 * den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 / den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 / den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):",
      "mutated_line": "if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 * den2 - b1) <= 0):",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 * den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 / den1, num2 // den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 / den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 * den1, num2 // den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 * den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 // den1, num2 / den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 / den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "m[num1 // den1, num2 // den2] = set()",
      "mutated_line": "m[num1 // den1, num2 * den2] = set()",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 * den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 / den1, num2 // den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 / den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 * den1, num2 // den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 * den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 // den1, num2 / den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 / den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 // den1, num2 * den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 * den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 / den1, num2 // den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 / den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 * den1, num2 // den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 * den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 // den1, num2 / den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 / den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 // den1, num2 * den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 * den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 / den1, num2 // den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 / den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 * den1, num2 // den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 * den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 // den1, num2 / den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 / den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m[num1 // den1, num2 // den2].add(i)",
      "mutated_line": "m[num1 // den1, num2 * den2].add(i)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 * den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 / den1, num2 // den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 / den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 * den1, num2 // den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 * den1, num2 // den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 // den1, num2 / den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 / den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "m[num1 // den1, num2 // den2].add(j)",
      "mutated_line": "m[num1 // den1, num2 * den2].add(j)",
      "code": "from math import gcd\n\ndef count_distinct_covered_points(segments):\n    n = len(segments)\n    pts = []\n    ans = 0\n    for i in range(n):\n        (a, b, A, B) = segments[i]\n        pts.append((a, b, A, B))\n        ans += gcd(abs(a - A), abs(b - B)) + 1\n    m = dict()\n    for i in range(n):\n        for j in range(i + 1, n):\n            (a1, b1, a2, b2) = pts[i]\n            (A1, B1, A2, B2) = pts[j]\n            num1 = (b2 - B2) * (A2 - A1) * (a2 - a1) + A2 * (a2 - a1) * (B2 - B1) - a2 * (A2 - A1) * (b2 - b1)\n            den1 = (B2 - B1) * (a2 - a1) - (b2 - b1) * (A2 - A1)\n            if den1 != 0 and num1 % den1 == 0:\n                if a1 == a2:\n                    num2 = B2 * (A2 - A1) + (num1 // den1 - A2) * (B2 - B1)\n                    den2 = A2 - A1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 // den2].add(j)\n                else:\n                    num2 = b2 * (a2 - a1) + (num1 // den1 - a2) * (b2 - b1)\n                    den2 = a2 - a1\n                    if num2 % den2 == 0:\n                        if (num1 // den1 - A2) * (num1 // den1 - A1) <= 0 and (num2 // den2 - B2) * (num2 // den2 - B1) <= 0 and ((num1 // den1 - a2) * (num1 // den1 - a1) <= 0) and ((num2 // den2 - b2) * (num2 // den2 - b1) <= 0):\n                            if (num1 // den1, num2 // den2) not in m:\n                                m[num1 // den1, num2 // den2] = set()\n                            m[num1 // den1, num2 // den2].add(i)\n                            m[num1 // den1, num2 * den2].add(j)\n    sum_intersections = 0\n    for intersections in m.values():\n        sum_intersections += len(intersections) - 1\n    return ans - sum_intersections"
    }
  ]
}