{
  "task_id": "taco_3224",
  "entry_point": "calculate_minimum_failures",
  "mutant_count": 29,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if current_sum <= M:",
      "mutated_line": "if current_sum < M:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum < M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if current_sum <= M:",
      "mutated_line": "if current_sum > M:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum > M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if current_sum <= M:",
      "mutated_line": "if current_sum == M:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum == M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "excess_time = current_sum - M",
      "mutated_line": "excess_time = current_sum + M",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum + M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "excess_time = current_sum - M",
      "mutated_line": "excess_time = current_sum * M",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum * M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 1\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = -1\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 1\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "excess_time -= time",
      "mutated_line": "excess_time += time",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time += time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count -= 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "result.append(0)",
      "mutated_line": "result.append(1)",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(1)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "result.append(0)",
      "mutated_line": "result.append(-1)",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(-1)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "result.append(0)",
      "mutated_line": "result.append(1)",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(1)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 2\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 0\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 0\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += -1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if excess_time <= 0:",
      "mutated_line": "if excess_time < 0:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time < 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if excess_time <= 0:",
      "mutated_line": "if excess_time > 0:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time > 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if excess_time <= 0:",
      "mutated_line": "if excess_time == 0:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time == 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "current_sum = sum(t[:i+1])",
      "mutated_line": "current_sum = sum(t[:i - 1])",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i - 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "current_sum = sum(t[:i+1])",
      "mutated_line": "current_sum = sum(t[:i * 1])",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i * 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if excess_time <= 0:",
      "mutated_line": "if excess_time <= 1:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 1:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if excess_time <= 0:",
      "mutated_line": "if excess_time <= -1:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= -1:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if excess_time <= 0:",
      "mutated_line": "if excess_time <= 1:",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 1:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "current_sum = sum(t[:i+1])",
      "mutated_line": "current_sum = sum(t[:i + 2])",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 2])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "current_sum = sum(t[:i+1])",
      "mutated_line": "current_sum = sum(t[:i + 0])",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 0])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "current_sum = sum(t[:i+1])",
      "mutated_line": "current_sum = sum(t[:i + 0])",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + 0])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "current_sum = sum(t[:i+1])",
      "mutated_line": "current_sum = sum(t[:i + -1])",
      "code": "def calculate_minimum_failures(n, M, t):\n    result = []\n    for i in range(n):\n        current_sum = sum(t[:i + -1])\n        if current_sum <= M:\n            result.append(0)\n        else:\n            sorted_times = sorted(t[:i])\n            excess_time = current_sum - M\n            count = 0\n            for time in reversed(sorted_times):\n                excess_time -= time\n                count += 1\n                if excess_time <= 0:\n                    result.append(count)\n                    break\n    return result"
    }
  ]
}