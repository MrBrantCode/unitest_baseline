{
  "task_id": "taco_14780",
  "entry_point": "is_valid_sudoku",
  "mutant_count": 32,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if rootN * rootN != n:",
      "mutated_line": "if rootN * rootN == n:",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN == n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))",
      "mutated_line": "return all(map(isOneToN, board)) or all(map(isOneToN, transpose)) or all(map(isOneToN, squares))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) or all(map(isOneToN, transpose)) or all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return True\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if rootN * rootN != n:",
      "mutated_line": "if rootN / rootN != n:",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN / rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if rootN * rootN != n:",
      "mutated_line": "if rootN + rootN != n:",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN + rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if rootN * rootN != n:",
      "mutated_line": "if rootN ** rootN != n:",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN ** rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return True\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])",
      "mutated_line": "isValidRow = lambda r: isinstance(r, list) or len(r) == n or all([type(x) == int for x in r])",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) or len(r) == n or all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return True\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "isOneToN = lambda l: set(l) == oneToN",
      "mutated_line": "isOneToN = lambda l: set(l) != oneToN",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) != oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])",
      "mutated_line": "isValidRow = lambda r: isinstance(r, list) and len(r) != n and all([type(x) == int for x in r])",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) != n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(2, n + 1))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(2, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(0, n + 1))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(0, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(0, n + 1))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(0, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(-1, n + 1))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(-1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(1, n - 1))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n - 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(1, n * 1))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n * 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(1, n + 2))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 2))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(1, n + 0))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 0))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(1, n + 0))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 0))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "oneToN = set(range(1, n + 1))",
      "mutated_line": "oneToN = set(range(1, n + -1))",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + -1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q - y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q - y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q * y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q * y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(1, n, rootN) for q in range(0, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(1, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(-1, n, rootN) for q in range(0, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(-1, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(1, n, rootN) for q in range(0, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(1, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(1, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(1, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(-1, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(-1, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(1, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(1, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])",
      "mutated_line": "isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) != int for x in r])",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) != int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p - x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p - x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "squares = [[board[p + x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "mutated_line": "squares = [[board[p * x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]",
      "code": "import math\n\ndef is_valid_sudoku(board):\n    if not isinstance(board, list):\n        return False\n    n = len(board)\n    rootN = int(round(math.sqrt(n)))\n    if rootN * rootN != n:\n        return False\n    isValidRow = lambda r: isinstance(r, list) and len(r) == n and all([type(x) == int for x in r])\n    if not all(map(isValidRow, board)):\n        return False\n    oneToN = set(range(1, n + 1))\n    isOneToN = lambda l: set(l) == oneToN\n    transpose = [[board[j][i] for i in range(n)] for j in range(n)]\n    squares = [[board[p * x][q + y] for x in range(rootN) for y in range(rootN)] for p in range(0, n, rootN) for q in range(0, n, rootN)]\n    return all(map(isOneToN, board)) and all(map(isOneToN, transpose)) and all(map(isOneToN, squares))"
    }
  ]
}