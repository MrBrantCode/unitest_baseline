{
  "task_id": "taco_1378",
  "entry_point": "update_state",
  "mutant_count": 231,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 * 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 + 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(1000000)",
      "mutated_line": "sys.setrecursionlimit(1000001)",
      "code": "import sys\nsys.setrecursionlimit(1000001)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(1000000)",
      "mutated_line": "sys.setrecursionlimit(999999)",
      "code": "import sys\nsys.setrecursionlimit(999999)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(1000000)",
      "mutated_line": "sys.setrecursionlimit(0)",
      "code": "import sys\nsys.setrecursionlimit(0)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(1000000)",
      "mutated_line": "sys.setrecursionlimit(1)",
      "code": "import sys\nsys.setrecursionlimit(1)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(1000000)",
      "mutated_line": "sys.setrecursionlimit(-1000000)",
      "code": "import sys\nsys.setrecursionlimit(-1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 11 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 9 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 0 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 1 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = -10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 21\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 19\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 0\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 1\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** -20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tmp[newx] = 1",
      "mutated_line": "tmp[newx] = 2",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 2\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tmp[newx] = 1",
      "mutated_line": "tmp[newx] = 0",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 0\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tmp[newx] = 1",
      "mutated_line": "tmp[newx] = 0",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 0\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tmp[newx] = 1",
      "mutated_line": "tmp[newx] = -1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = -1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dc = do = 0",
      "mutated_line": "dc = do = 1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 1\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dc = do = 0",
      "mutated_line": "dc = do = -1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = -1\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dc = do = 0",
      "mutated_line": "dc = do = 1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 1\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if score < 0:",
      "mutated_line": "if score <= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score <= 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if score < 0:",
      "mutated_line": "if score >= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score >= 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if score < 0:",
      "mutated_line": "if score != 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score != 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if (x, y, state, ox) in dic:",
      "mutated_line": "if (x, y, state, ox) not in dic:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) not in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if y == goal:",
      "mutated_line": "if y != goal:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y != goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if ox <= 1:",
      "mutated_line": "if ox < 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox < 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if ox <= 1:",
      "mutated_line": "if ox > 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox > 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if ox <= 1:",
      "mutated_line": "if ox == 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox == 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x >= 1:",
      "mutated_line": "if x > 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x > 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x >= 1:",
      "mutated_line": "if x < 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x < 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if x >= 1:",
      "mutated_line": "if x == 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x == 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x <= w - 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x <= w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x >= w - 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x >= w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x != w - 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x != w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if o <= 1:",
      "mutated_line": "if o < 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o < 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if o <= 1:",
      "mutated_line": "if o > 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o > 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if o <= 1:",
      "mutated_line": "if o == 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o == 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if ans > f:",
      "mutated_line": "if ans >= f:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans >= f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if ans > f:",
      "mutated_line": "if ans <= f:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans <= f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if ans > f:",
      "mutated_line": "if ans != f:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans != f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if score < 0:",
      "mutated_line": "if score < 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 1:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if score < 0:",
      "mutated_line": "if score < -1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < -1:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if score < 0:",
      "mutated_line": "if score < 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 1:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "dc = -score",
      "mutated_line": "dc = +score",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = +score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 1\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return -1\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 1\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if ox <= 1:",
      "mutated_line": "if ox <= 2:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 2:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if ox <= 1:",
      "mutated_line": "if ox <= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 0:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if ox <= 1:",
      "mutated_line": "if ox <= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 0:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if ox <= 1:",
      "mutated_line": "if ox <= -1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= -1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= 2:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 2:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 0:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 0:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if x >= 1:",
      "mutated_line": "if x >= -1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= -1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - 1] != 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] != 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x < w + 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w + 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x < w * 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w * 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + 1] != 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] != 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(dc, do) = get_co(x, y + 1, formation)",
      "mutated_line": "(dc, do) = get_co(x, y - 1, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y - 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(dc, do) = get_co(x, y + 1, formation)",
      "mutated_line": "(dc, do) = get_co(x, y * 1, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y * 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) - dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) - dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) * dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) * dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if o <= 1:",
      "mutated_line": "if o <= 2:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 2:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if o <= 1:",
      "mutated_line": "if o <= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 0:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if o <= 1:",
      "mutated_line": "if o <= 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 0:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if o <= 1:",
      "mutated_line": "if o <= -1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= -1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 'NA'",
      "mutated_line": "return ''",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return ''\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return 'NA'",
      "mutated_line": "return ''",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return ''\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - 1] == 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 1:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - 1] == -1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == -1:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - 1] == 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 1:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x < w - 2:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 2:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x < w - 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 0:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x < w - 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 0:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x < w - 1:",
      "mutated_line": "if x < w - -1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - -1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + 1] == 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 1:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + 1] == -1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == -1:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + 1] == 1:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 1:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(dc, do) = get_co(x, y + 1, formation)",
      "mutated_line": "(dc, do) = get_co(x, y + 2, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 2, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(dc, do) = get_co(x, y + 1, formation)",
      "mutated_line": "(dc, do) = get_co(x, y + 0, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 0, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(dc, do) = get_co(x, y + 1, formation)",
      "mutated_line": "(dc, do) = get_co(x, y + 0, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 0, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(dc, do) = get_co(x, y + 1, formation)",
      "mutated_line": "(dc, do) = get_co(x, y + -1, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + -1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "(dc, do) = get_co(i, 0, formation)",
      "mutated_line": "(dc, do) = get_co(i, 1, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 1, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "(dc, do) = get_co(i, 0, formation)",
      "mutated_line": "(dc, do) = get_co(i, -1, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, -1, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "(dc, do) = get_co(i, 0, formation)",
      "mutated_line": "(dc, do) = get_co(i, 1, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 1, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) - dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) - dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) * dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) * dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x + 1] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x * 1] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x * 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(dc, do) = get_co(x - 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x + 1, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "(dc, do) = get_co(x - 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x * 1, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x * 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) - dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) - dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) * dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) * dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x - 1] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x * 1] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x * 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(dc, do) = get_co(x + 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x - 1, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "(dc, do) = get_co(x + 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x * 1, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x * 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) - dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) - dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) * dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) * dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y - 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y - 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y * 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y * 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - 2] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 2] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - 0] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 0] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - 0] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 0] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if state[x - 1] == 0:",
      "mutated_line": "if state[x - -1] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - -1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(dc, do) = get_co(x - 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x - 2, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 2, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(dc, do) = get_co(x - 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x - 0, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 0, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(dc, do) = get_co(x - 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x - 0, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 0, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "(dc, do) = get_co(x - 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x - -1, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - -1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x * 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x * 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox + 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox + 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox * 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox * 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + 2] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 2] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + 0] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 0] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + 0] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 0] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if state[x + 1] == 0:",
      "mutated_line": "if state[x + -1] == 0:",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + -1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(dc, do) = get_co(x + 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x + 2, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 2, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(dc, do) = get_co(x + 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x + 0, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 0, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(dc, do) = get_co(x + 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x + 0, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 0, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "(dc, do) = get_co(x + 1, y, formation)",
      "mutated_line": "(dc, do) = get_co(x + -1, y, formation)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + -1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x * 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x * 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox + 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox + 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox * 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox * 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 2, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 2, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 0, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 0, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 0, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 0, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + -1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + -1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do + 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do + 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min((ox + do) * 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min((ox + do) * 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((1 if i != j else 0 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i != j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((2 if i == j else 0 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((2 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((0 if i == j else 0 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((0 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((0 if i == j else 0 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((0 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((-1 if i == j else 0 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((-1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((1 if i == j else 1 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 1 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((1 if i == j else -1 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else -1 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "state = tuple((1 if i == j else 0 for j in range(W)))",
      "mutated_line": "state = tuple((1 if i == j else 1 for j in range(W)))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 1 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 1, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 1, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, -1, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, -1, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 1, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 1, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H + 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H + 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H * 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H * 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x * 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x * 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 2, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 2, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 0, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 0, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 0, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 0, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - -1, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - -1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 2, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 2, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 0, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 0, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 0, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 0, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, state, ox - -1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - -1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x * 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x * 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 2, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 2, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 0, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 0, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 0, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 0, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + -1, y, state, ox - 1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + -1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 2, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 2, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 0, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 0, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 0, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 0, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, state, ox - -1, goal, dic, w, m, formation))",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - -1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox - do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox - do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox * do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox * do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 2, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 2, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - -1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - -1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do + 1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do + 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min((o + do) * 1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min((o + do) * 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 2, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 2, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 0, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 0, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 0, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 0, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - -1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - -1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 2, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 2, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 0, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 0, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 0, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 0, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - -1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - -1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x * 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x * 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do + 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do + 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min((ox + do) * 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min((ox + do) * 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 2, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 2, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 0, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 0, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 0, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 0, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + -1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + -1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x * 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x * 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do + 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do + 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min((ox + do) * 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min((ox + do) * 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i != x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i != x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((2 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((2 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((0 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((0 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((0 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((0 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((-1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((-1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 1 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 1 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else -1 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else -1 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 1 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 1 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o - do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o - do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o * do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o * do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 2, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 2, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 0, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 0, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 0, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 0, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)",
      "mutated_line": "ans = min(ans, minimum_cost(i, 0, state, min(o + do - -1, m), H - 1, dic, W, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - -1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 2), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 2), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - -1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - -1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox - do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox - do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox * do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox * do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 2, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 2, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - -1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - -1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 2), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 2), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 0), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + -1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + -1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox - do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox - do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox * do - 1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox * do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 2, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 2, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 0, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)",
      "mutated_line": "ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - -1, m), goal, dic, w, m, formation) + dc)",
      "code": "import sys\nsys.setrecursionlimit(1000000)\nINF = 10 ** 20\n\ndef update_state(state, newx):\n    tmp = list(state)\n    tmp[newx] = 1\n    return tuple(tmp)\n\ndef get_co(x, y, formation):\n    dc = do = 0\n    score = formation[y][x]\n    if score < 0:\n        dc = -score\n    else:\n        do = score\n    return (dc, do)\n\ndef minimum_cost(x, y, state, ox, goal, dic, w, m, formation):\n    if (x, y, state, ox) in dic:\n        return dic[x, y, state, ox]\n    if y == goal:\n        return 0\n    if ox <= 1:\n        return INF\n    ret = INF\n    if x >= 1:\n        if state[x - 1] == 0:\n            (dc, do) = get_co(x - 1, y, formation)\n            ret = min(ret, minimum_cost(x - 1, y, update_state(state, x - 1), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x - 1, y, state, ox - 1, goal, dic, w, m, formation))\n    if x < w - 1:\n        if state[x + 1] == 0:\n            (dc, do) = get_co(x + 1, y, formation)\n            ret = min(ret, minimum_cost(x + 1, y, update_state(state, x + 1), min(ox + do - -1, m), goal, dic, w, m, formation) + dc)\n        else:\n            ret = min(ret, minimum_cost(x + 1, y, state, ox - 1, goal, dic, w, m, formation))\n    (dc, do) = get_co(x, y + 1, formation)\n    ret = min(ret, minimum_cost(x, y + 1, tuple((1 if i == x else 0 for i in range(w))), min(ox + do - 1, m), goal, dic, w, m, formation) + dc)\n    dic[x, y, state, ox] = ret\n    return ret\n\ndef calculate_minimum_cost(W, H, f, m, o, formation):\n    if o <= 1:\n        return 'NA'\n    dic = {}\n    ans = INF\n    for i in range(W):\n        (dc, do) = get_co(i, 0, formation)\n        state = tuple((1 if i == j else 0 for j in range(W)))\n        ans = min(ans, minimum_cost(i, 0, state, min(o + do - 1, m), H - 1, dic, W, m, formation) + dc)\n    if ans > f:\n        return 'NA'\n    else:\n        return str(ans)"
    }
  ]
}