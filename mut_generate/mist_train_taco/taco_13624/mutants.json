{
  "task_id": "taco_13624",
  "entry_point": "restore_original_string",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "repeated = len(s) != len(set(s))",
      "mutated_line": "repeated = len(s) == len(set(s))",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) == len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) >= 4:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) >= 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) <= 4:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) <= 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) != 4:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) != 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(kk) == 2:",
      "mutated_line": "if len(kk) != 2:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) != 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 0 and diff_count == 2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 and diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = strings[0]",
      "mutated_line": "s = strings[1]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[1]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = strings[0]",
      "mutated_line": "s = strings[-1]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[-1]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = strings[0]",
      "mutated_line": "s = strings[1]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[1]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if Counter(string) != etalon:",
      "mutated_line": "if Counter(string) == etalon:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) == etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(2, k):",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(2, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(0, k):",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(0, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(0, k):",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(0, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(1, k):",
      "mutated_line": "for i in range(-1, k):",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(-1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if strings[i] != s:",
      "mutated_line": "if strings[i] == s:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] == s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) > 5:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 5:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) > 3:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 3:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) > 0:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 0:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) > 1:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 1:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(kk) > 4:",
      "mutated_line": "if len(kk) > -4:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > -4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return +1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(kk) == 2:",
      "mutated_line": "if len(kk) == 3:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 3:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(kk) == 2:",
      "mutated_line": "if len(kk) == 1:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 1:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(kk) == 2:",
      "mutated_line": "if len(kk) == 0:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 0:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(kk) == 2:",
      "mutated_line": "if len(kk) == 1:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 1:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(kk) == 2:",
      "mutated_line": "if len(kk) == -2:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == -2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n >= 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n >= 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n <= 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n <= 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n != 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n != 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] - s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] - s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return (s[1] + s[0]) * s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return (s[1] + s[0]) * s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] - s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] - s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] * s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] * s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count != 0 or diff_count == 2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count != 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 0 or diff_count != 2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count != 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for string in strings[1:]:",
      "mutated_line": "for string in strings[2:]:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[2:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for string in strings[1:]:",
      "mutated_line": "for string in strings[0:]:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[0:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for string in strings[1:]:",
      "mutated_line": "for string in strings[0:]:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[0:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for string in strings[1:]:",
      "mutated_line": "for string in strings[-1:]:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[-1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return +1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -2\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -0\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -0\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return --1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 3 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 3 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 1 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 1 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 0 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 0 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 1 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 1 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > -2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > -2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] - s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] - s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] * s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] * s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "diff_count = sum(1 for a, b in zip(original, target) if a != b)",
      "mutated_line": "diff_count = sum((2 for (a, b) in zip(original, target) if a != b))",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((2 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "diff_count = sum(1 for a, b in zip(original, target) if a != b)",
      "mutated_line": "diff_count = sum((0 for (a, b) in zip(original, target) if a != b))",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((0 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "diff_count = sum(1 for a, b in zip(original, target) if a != b)",
      "mutated_line": "diff_count = sum((0 for (a, b) in zip(original, target) if a != b))",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((0 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "diff_count = sum(1 for a, b in zip(original, target) if a != b)",
      "mutated_line": "diff_count = sum((-1 for (a, b) in zip(original, target) if a != b))",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((-1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 1 or diff_count == 2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 1 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == -1 or diff_count == 2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == -1 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 1 or diff_count == 2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 1 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 0 or diff_count == 3",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 3\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 0 or diff_count == 1",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 1\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 0 or diff_count == 0",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 0\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 0 or diff_count == 1",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 1\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return diff_count == 0 or diff_count == 2",
      "mutated_line": "return diff_count == 0 or diff_count == -2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == -2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -2\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -0\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -0\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return --1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if s[j] != strings[i][j]:",
      "mutated_line": "if s[j] == strings[i][j]:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] == strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if change == i:",
      "mutated_line": "if change != i:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change != i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if i > change:",
      "mutated_line": "if i >= change:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i >= change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if i > change:",
      "mutated_line": "if i <= change:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i <= change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if i > change:",
      "mutated_line": "if i != change:",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i != change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[2] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[2] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[0] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[0] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[0] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[0] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[-1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[-1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[1]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[1]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[-1]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[1]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[1]"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "diff_count = sum(1 for a, b in zip(original, target) if a != b)",
      "mutated_line": "diff_count = sum((1 for (a, b) in zip(original, target) if a == b))",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a == b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] - s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] - s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = (s[:change] + s[i] + s[change + 1:i] + s[change]) * s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = (s[:change] + s[i] + s[change + 1:i] + s[change]) * s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] - s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] - s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = (s[:i] + s[change] + s[i + 1:change] + s[i]) * s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = (s[:i] + s[change] + s[i + 1:change] + s[i]) * s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[2] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[2] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[0] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[0] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[0] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[0] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[-1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[-1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[1] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[1] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[-1] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[-1] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[1] + s[2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[1] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[3:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[3:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[1:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[1:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[0:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[0:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[1:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[1:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]",
      "mutated_line": "return s[1] + s[0] + s[-2:] if n > 2 else s[1] + s[0]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[-2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] - s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] - s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = (s[:change] + s[i] + s[change + 1:i]) * s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = (s[:change] + s[i] + s[change + 1:i]) * s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] - s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] - s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = (s[:i] + s[change] + s[i + 1:change]) * s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = (s[:i] + s[change] + s[i + 1:change]) * s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] - s[change + 1:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] - s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = (s[:change] + s[i]) * s[change + 1:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = (s[:change] + s[i]) * s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] - s[i + 1:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] - s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = (s[:i] + s[change]) * s[i + 1:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = (s[:i] + s[change]) * s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] - s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] - s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] * s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] * s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i - 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i - 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i * 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i * 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] - s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] - s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] * s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] * s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change - 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change - 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change * 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change * 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 2:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 2:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 0:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 0:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 0:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 0:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + -1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + -1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 2:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 2:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 0:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 0:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 0:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 0:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + -1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + -1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change - 1:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change - 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change * 1:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change * 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i - 1:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i - 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i * 1:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i * 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 2:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 2:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 0:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 0:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + 0:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 0:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]",
      "mutated_line": "stry = s[:change] + s[i] + s[change + -1:i] + s[change] + s[i + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + -1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 2:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 2:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 0:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 0:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + 0:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + 0:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "stry = s[:i] + s[change] + s[i + 1:change] + s[i] + s[change + 1:]",
      "mutated_line": "stry = s[:i] + s[change] + s[i + -1:change] + s[i] + s[change + 1:]",
      "code": "from collections import Counter\n\ndef restore_original_string(k, n, strings):\n\n    def is_valid_swap(original, target):\n        diff_count = sum((1 for (a, b) in zip(original, target) if a != b))\n        return diff_count == 0 or diff_count == 2\n    s = strings[0]\n    repeated = len(s) != len(set(s))\n    etalon = Counter(s)\n    for string in strings[1:]:\n        if Counter(string) != etalon:\n            return -1\n    kk = []\n    for i in range(1, k):\n        if strings[i] != s:\n            for j in range(n):\n                if s[j] != strings[i][j]:\n                    kk.append(j)\n            break\n    if len(kk) > 4:\n        return -1\n    if repeated:\n        for string in strings:\n            if not is_valid_swap(s, string):\n                break\n        else:\n            return s\n    if len(kk) == 2:\n        for change in kk:\n            for i in range(n):\n                if change == i:\n                    continue\n                if i > change:\n                    stry = s[:change] + s[i] + s[change + 1:i] + s[change] + s[i + 1:]\n                else:\n                    stry = s[:i] + s[change] + s[i + -1:change] + s[i] + s[change + 1:]\n                for string in strings:\n                    if not is_valid_swap(stry, string):\n                        break\n                else:\n                    return stry\n    if repeated:\n        return s\n    return s[1] + s[0] + s[2:] if n > 2 else s[1] + s[0]"
    }
  ]
}