{
  "task_id": "taco_17607",
  "entry_point": "minimize_travel_time",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if position >= len(a):",
      "mutated_line": "if position > len(a):",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position > len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if position >= len(a):",
      "mutated_line": "if position < len(a):",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position < len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if position >= len(a):",
      "mutated_line": "if position == len(a):",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position == len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops > 0 or a[position] > speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 or a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return solve_rec(0, k, a[0])",
      "mutated_line": "return solve_rec(1, k, a[0])",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(1, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return solve_rec(0, k, a[0])",
      "mutated_line": "return solve_rec(-1, k, a[0])",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(-1, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return solve_rec(0, k, a[0])",
      "mutated_line": "return solve_rec(1, k, a[0])",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(1, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 1\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return -1\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 1\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "res = float('inf')",
      "mutated_line": "res = float('')",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops >= 0 and a[position] > speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops >= 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops <= 0 and a[position] > speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops <= 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops != 0 and a[position] > speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops != 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops > 0 and a[position] >= speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] >= speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops > 0 and a[position] <= speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] <= speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops > 0 and a[position] != speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] != speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) - solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) - solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) * solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) * solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return solve_rec(0, k, a[0])",
      "mutated_line": "return solve_rec(0, k, a[1])",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return solve_rec(0, k, a[0])",
      "mutated_line": "return solve_rec(0, k, a[-1])",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return solve_rec(0, k, a[0])",
      "mutated_line": "return solve_rec(0, k, a[1])",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops > 1 and a[position] > speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 1 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops > -1 and a[position] > speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > -1 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if drops > 0 and a[position] > speed:",
      "mutated_line": "if drops > 1 and a[position] > speed:",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 1 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) - solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) - solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) * solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) * solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] / (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] / (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] + (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] + (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] ** (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] ** (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed / (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed / (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed + (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed + (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed ** (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed ** (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] + d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] + d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] * d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] * d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position - 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position - 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position * 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position * 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] + d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] + d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] * d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] * d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position - 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position - 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position * 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position * 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops + 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops + 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops * 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops * 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 2, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 2, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 0, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 0, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 0, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 0, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + -1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + -1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 2, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 2, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 0, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 0, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 0, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 0, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + -1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + -1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 2, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 2, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 0, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 0, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 0, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 0, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - -1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - -1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position - 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position - 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position * 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position * 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position - 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position - 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position * 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position * 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 2] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 2] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 0] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 0] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + 0] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 0] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "mutated_line": "res = min(res, a[position] * (d[position + -1] - d[position]) + solve_rec(position + 1, drops, a[position]))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + -1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 2] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 2] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 0] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 0] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + 0] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + 0] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "res = min(res, speed * (d[position + 1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "mutated_line": "res = min(res, speed * (d[position + -1] - d[position]) + solve_rec(position + 1, drops - 1, speed))",
      "code": "import functools\n\ndef minimize_travel_time(n, l, k, d, a):\n    d.append(l)\n\n    @functools.lru_cache(maxsize=None)\n    def solve_rec(position, drops, speed):\n        if position >= len(a):\n            return 0\n        res = float('inf')\n        if drops > 0 and a[position] > speed:\n            res = min(res, speed * (d[position + -1] - d[position]) + solve_rec(position + 1, drops - 1, speed))\n        res = min(res, a[position] * (d[position + 1] - d[position]) + solve_rec(position + 1, drops, a[position]))\n        return res\n    return solve_rec(0, k, a[0])"
    }
  ]
}