{
  "task_id": "taco_10547",
  "entry_point": "calculate_minimum_cost",
  "mutant_count": 83,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t = [0] * n",
      "mutated_line": "t = [0] / n",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] / n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t = [0] * n",
      "mutated_line": "t = [0] + n",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] + n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "t = [0] * n",
      "mutated_line": "t = [0] ** n",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] ** n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return heights[i] * costs[j] + t[j]",
      "mutated_line": "return heights[i] * costs[j] - t[j]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] - t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return heights[i] * costs[j] + t[j]",
      "mutated_line": "return heights[i] * costs[j] * t[j]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] * t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) <= (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) <= (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) >= (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) >= (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) != (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) != (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p = [0]",
      "mutated_line": "p = [1]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [1]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p = [0]",
      "mutated_line": "p = [-1]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [-1]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "p = [0]",
      "mutated_line": "p = [1]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [1]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(2, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(0, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(0, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(-1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 or g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 or g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 or h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 or h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "return t[-1]",
      "mutated_line": "return t[+1]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[+1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return heights[i] * costs[j] + t[j]",
      "mutated_line": "return heights[i] / costs[j] + t[j]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] / costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return heights[i] * costs[j] + t[j]",
      "mutated_line": "return heights[i] + costs[j] + t[j]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] + costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return heights[i] * costs[j] + t[j]",
      "mutated_line": "return heights[i] ** costs[j] + t[j]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] ** costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) / (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) / (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return t[i] - t[j] + (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return t[i] - t[j] + (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) ** (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) ** (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) / (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) / (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < t[j] - t[k] + (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < t[j] - t[k] + (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) ** (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) ** (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t = [0] * n",
      "mutated_line": "t = [1] * n",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [1] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t = [0] * n",
      "mutated_line": "t = [-1] * n",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [-1] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "t = [0] * n",
      "mutated_line": "t = [1] * n",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [1] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) >= 1 and g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) >= 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) <= 1 and g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) <= 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) != 1 and g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) != 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[1]) <= g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) <= g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[1]) >= g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) >= g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[1]) != g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) != g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) >= 1 and h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) >= 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) <= 1 and h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) <= 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) != 1 and h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) != 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return t[-1]",
      "mutated_line": "return t[-2]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-2]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return t[-1]",
      "mutated_line": "return t[-0]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return t[-1]",
      "mutated_line": "return t[-0]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return t[-1]",
      "mutated_line": "return t[--1]",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[--1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] + t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] + t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return t[i] * t[j] * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return t[i] * t[j] * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] + costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] + costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] * costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] * costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] + t[k]) * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] + t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < t[j] * t[k] * (costs[i] - costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < t[j] * t[k] * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] + costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] + costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])",
      "mutated_line": "return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] * costs[j])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] * costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 2 and g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 2 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 0 and g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 0 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 0 and g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 0 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > -1 and g(p[1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > -1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p.pop(0)",
      "mutated_line": "p.pop(1)",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(1)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p.pop(0)",
      "mutated_line": "p.pop(-1)",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(-1)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p.pop(0)",
      "mutated_line": "p.pop(1)",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(1)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "t[i] = g(p[0])",
      "mutated_line": "t[i] = g(p[1])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[1])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "t[i] = g(p[0])",
      "mutated_line": "t[i] = g(p[-1])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[-1])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "t[i] = g(p[0])",
      "mutated_line": "t[i] = g(p[1])",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[1])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 2 and h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 2 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 0 and h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 0 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 0 and h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 0 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > -1 and h(p[-2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > -1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[+2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[+2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-2], p[+1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[+1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[2]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[2]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[0]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[0]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[0]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[0]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[-1]) < g(p[0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[-1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[1]) < g(p[1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[1]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[1]) < g(p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[-1]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "while len(p) > 1 and g(p[1]) < g(p[0]):",
      "mutated_line": "while len(p) > 1 and g(p[1]) < g(p[1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[1]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-3], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-3], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-1], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-1], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-0], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-0], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-1], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-1], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[--2], p[-1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[--2], p[-1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-2], p[-2]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-2]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-2], p[-0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-0]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-2], p[-0]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[-0]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while len(p) > 1 and h(p[-2], p[-1]):",
      "mutated_line": "while len(p) > 1 and h(p[-2], p[--1]):",
      "code": "def calculate_minimum_cost(n, heights, costs):\n\n    def g(j):\n        return heights[i] * costs[j] + t[j]\n\n    def h(j, k):\n        return (t[i] - t[j]) * (costs[j] - costs[k]) < (t[j] - t[k]) * (costs[i] - costs[j])\n    t = [0] * n\n    p = [0]\n    for i in range(1, n):\n        while len(p) > 1 and g(p[1]) < g(p[0]):\n            p.pop(0)\n        t[i] = g(p[0])\n        while len(p) > 1 and h(p[-2], p[--1]):\n            p.pop()\n        p.append(i)\n    return t[-1]"
    }
  ]
}