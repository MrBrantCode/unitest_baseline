{
  "task_id": "taco_11287",
  "entry_point": "construct_tree",
  "mutant_count": 127,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 and (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 and (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d2 = d / 2",
      "mutated_line": "d2 = d * 2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d * 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d2 = d / 2",
      "mutated_line": "d2 = d // 2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d // 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d21 = d2 + 1",
      "mutated_line": "d21 = d2 - 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 - 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "d21 = d2 + 1",
      "mutated_line": "d21 = d2 * 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 * 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_i = d + 2",
      "mutated_line": "next_i = d - 2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d - 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "next_i = d + 2",
      "mutated_line": "next_i = d * 2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d * 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while next_i <= n:",
      "mutated_line": "while next_i < n:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i < n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while next_i <= n:",
      "mutated_line": "while next_i > n:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i > n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while next_i <= n:",
      "mutated_line": "while next_i == n:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i == n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[2] += 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] += 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "next_i += 1",
      "mutated_line": "next_i -= 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i -= 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n <= d + 1 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n <= d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n >= d + 1 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n >= d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n != d + 1 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n != d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 1 or k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 or k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = d / 2",
      "mutated_line": "d2 = d / 3",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 3\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = d / 2",
      "mutated_line": "d2 = d / 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 1\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = d / 2",
      "mutated_line": "d2 = d / 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 0\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = d / 2",
      "mutated_line": "d2 = d / 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 1\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d2 = d / 2",
      "mutated_line": "d2 = d / -2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / -2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d21 = d2 + 1",
      "mutated_line": "d21 = d2 + 2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 2\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d21 = d2 + 1",
      "mutated_line": "d21 = d2 + 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 0\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d21 = d2 + 1",
      "mutated_line": "d21 = d2 + 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 0\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "d21 = d2 + 1",
      "mutated_line": "d21 = d2 + -1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + -1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(3, d + 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(3, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(1, d + 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(1, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(0, d + 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(0, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(1, d + 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(1, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(-2, d + 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(-2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(2, d - 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d - 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(2, d * 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d * 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_i = d + 2",
      "mutated_line": "next_i = d + 3",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 3\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_i = d + 2",
      "mutated_line": "next_i = d + 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 1\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_i = d + 2",
      "mutated_line": "next_i = d + 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 0\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_i = d + 2",
      "mutated_line": "next_i = d + 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 1\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "next_i = d + 2",
      "mutated_line": "next_i = d + -2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + -2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == 0 and remaining_degree == 0:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 and remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[2] -= 2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 2\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[2] -= 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 0\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[2] -= 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 0\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[2] -= -1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= -1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_i += 1",
      "mutated_line": "next_i += 2",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 2\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_i += 1",
      "mutated_line": "next_i += 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 0\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_i += 1",
      "mutated_line": "next_i += 0",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 0\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "next_i += 1",
      "mutated_line": "next_i += -1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += -1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 'YES', edges",
      "mutated_line": "return ('', edges)",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d - 1 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d - 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d * 1 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d * 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d >= 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d >= 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d <= 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d <= 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d != 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d != 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 1 and k != 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k != 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 'NO', []",
      "mutated_line": "return ('', [])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(2, 2)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(2, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(0, 2)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(0, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(0, 2)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(0, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(-1, 2)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(-1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(1, 3)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 3)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(1, 1)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 1)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(1, 0)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 0)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(1, 1)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 1)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [(1, 2)]",
      "mutated_line": "edges = [(1, -2)]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, -2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(2, d + 2):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 2):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(2, d + 0):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 0):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(2, d + 0):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 0):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for node in range(2, d + 1):",
      "mutated_line": "for node in range(2, d + -1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + -1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[+1]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[+1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth != 0 or remaining_degree == 0:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth != 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == 0 or remaining_degree != 0:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree != 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[3] -= 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[3] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[1] -= 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[1] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[0] -= 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[0] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[1] -= 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[1] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "node[2] -= 1",
      "mutated_line": "node[-2] -= 1",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[-2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 2 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 2 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 0 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 0 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 0 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 0 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + -1 or (d > 1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + -1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 2 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 2 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 0 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 0 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 0 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 0 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > -1 and k == 1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > -1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 1 and k == 2):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 2):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 1 and k == 0):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 0):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 1 and k == 0):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 0):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < d + 1 or (d > 1 and k == 1):",
      "mutated_line": "if n < d + 1 or (d > 1 and k == -1):",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == -1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges.append((node, node + 1))",
      "mutated_line": "edges.append((node, node - 1))",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node - 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges.append((node, node + 1))",
      "mutated_line": "edges.append((node, node * 1))",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node * 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 + abs(d21 - node), k - 2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 + abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 * abs(d21 - node), k - 2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 * abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 - node), k + 2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k + 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 - node), k * 2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k * 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 'NO', []",
      "mutated_line": "return ('', [])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[-2]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-2]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[-0]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-0]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[-0]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-0]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "node = stack[-1]",
      "mutated_line": "node = stack[--1]",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[--1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == 1 or remaining_degree == 0:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 1 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == -1 or remaining_degree == 0:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == -1 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == 1 or remaining_degree == 0:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 1 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == 0 or remaining_degree == 1:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 1:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == 0 or remaining_degree == -1:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == -1:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if remaining_depth == 0 or remaining_degree == 0:",
      "mutated_line": "if remaining_depth == 0 or remaining_degree == 1:",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 1:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth + 1, k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth + 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth * 1, k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth * 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 1, k + 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k + 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 1, k * 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k * 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "edges.append((node, node + 1))",
      "mutated_line": "edges.append((node, node + 2))",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 2))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "edges.append((node, node + 1))",
      "mutated_line": "edges.append((node, node + 0))",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 0))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "edges.append((node, node + 1))",
      "mutated_line": "edges.append((node, node + 0))",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 0))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "edges.append((node, node + 1))",
      "mutated_line": "edges.append((node, node + -1))",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + -1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 - node), k - 3])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 3])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 - node), k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 1])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 - node), k - 0])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 0])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 - node), k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 1])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 - node), k - -2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - -2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 2, k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 2, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 0, k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 0, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 0, k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 0, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - -1, k - 1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - -1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 1, k - 2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 2])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 1, k - 0])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 0])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 1, k - 0])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 0])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "stack.append([next_i, remaining_depth - 1, k - 1])",
      "mutated_line": "stack.append([next_i, remaining_depth - 1, k - -1])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 - node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - -1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 + node), k - 2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 + node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "stack.append([node, d2 - abs(d21 - node), k - 2])",
      "mutated_line": "stack.append([node, d2 - abs(d21 * node), k - 2])",
      "code": "def construct_tree(n, d, k):\n    if n < d + 1 or (d > 1 and k == 1):\n        return ('NO', [])\n    edges = [(1, 2)]\n    stack = []\n    d2 = d / 2\n    d21 = d2 + 1\n    for node in range(2, d + 1):\n        edges.append((node, node + 1))\n        stack.append([node, d2 - abs(d21 * node), k - 2])\n    next_i = d + 2\n    while next_i <= n:\n        if not stack:\n            return ('NO', [])\n        node = stack[-1]\n        (i, remaining_depth, remaining_degree) = node\n        if remaining_depth == 0 or remaining_degree == 0:\n            stack.pop()\n            continue\n        node[2] -= 1\n        edges.append((i, next_i))\n        stack.append([next_i, remaining_depth - 1, k - 1])\n        next_i += 1\n    return ('YES', edges)"
    }
  ]
}