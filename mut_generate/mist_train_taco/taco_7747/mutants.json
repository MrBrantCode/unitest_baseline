{
  "task_id": "taco_7747",
  "entry_point": "kth",
  "mutant_count": 244,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxn = 55",
      "mutated_line": "maxn = 56",
      "code": "import math\nmaxn = 56\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxn = 55",
      "mutated_line": "maxn = 54",
      "code": "import math\nmaxn = 54\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxn = 55",
      "mutated_line": "maxn = 0",
      "code": "import math\nmaxn = 0\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxn = 55",
      "mutated_line": "maxn = 1",
      "code": "import math\nmaxn = 1\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "maxn = 55",
      "mutated_line": "maxn = -55",
      "code": "import math\nmaxn = -55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = [0] * maxn",
      "mutated_line": "f = [0] / maxn",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] / maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = [0] * maxn",
      "mutated_line": "f = [0] + maxn",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] + maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f = [0] * maxn",
      "mutated_line": "f = [0] ** maxn",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] ** maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f[0] = 1",
      "mutated_line": "f[0] = 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 2\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f[0] = 1",
      "mutated_line": "f[0] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 0\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f[0] = 1",
      "mutated_line": "f[0] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 0\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f[0] = 1",
      "mutated_line": "f[0] = -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = -1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [1]",
      "mutated_line": "g = [2]",
      "code": "import math\nmaxn = 55\ng = [2]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [1]",
      "mutated_line": "g = [0]",
      "code": "import math\nmaxn = 55\ng = [0]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [1]",
      "mutated_line": "g = [0]",
      "code": "import math\nmaxn = 55\ng = [0]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "g = [1]",
      "mutated_line": "g = [-1]",
      "code": "import math\nmaxn = 55\ng = [-1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f[0] = 1",
      "mutated_line": "f[1] = 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[1] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f[0] = 1",
      "mutated_line": "f[-1] = 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[-1] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f[0] = 1",
      "mutated_line": "f[1] = 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[1] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, maxn):",
      "mutated_line": "for i in range(2, maxn):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(2, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, maxn):",
      "mutated_line": "for i in range(0, maxn):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(0, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, maxn):",
      "mutated_line": "for i in range(0, maxn):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(0, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, maxn):",
      "mutated_line": "for i in range(-1, maxn):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(-1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] -= f[j] * g[i - j - 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] -= f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n != 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [-1] / n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] / n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [-1] + n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] + n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [-1] ** n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] ** n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[0] = n + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n + 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[0] = n * 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n * 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] / n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] / n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] + n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] + n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] ** n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] ** n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[0] = n + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n + 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[0] = n * 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n * 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n - 1] = 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 1\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n - 1] = -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = -1\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n - 1] = 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 1\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis[n - 1] = True",
      "mutated_line": "vis[n - 1] = False",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = False\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if n == 0:",
      "mutated_line": "if n != 0:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n != 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "i = 1",
      "mutated_line": "i = 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 2\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 0\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 0\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "i = 1",
      "mutated_line": "i = -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = -1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] * f[n - i] <= k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] <= k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] * f[n - i] >= k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] >= k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] * f[n - i] != k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] != k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k += g[i - 1] * f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k += g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i -= 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n - i] - 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] - 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n - i] * 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] * 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return kth(i, k) + rem",
      "mutated_line": "return kth(i, k) - rem",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) - rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "return kth(i, k) + rem",
      "mutated_line": "return kth(i, k) * rem",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) * rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if k > f[n]:",
      "mutated_line": "if k >= f[n]:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k >= f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if k > f[n]:",
      "mutated_line": "if k <= f[n]:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k <= f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "if k > f[n]:",
      "mutated_line": "if k != f[n]:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k != f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f = [0] * maxn",
      "mutated_line": "f = [1] * maxn",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [1] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f = [0] * maxn",
      "mutated_line": "f = [-1] * maxn",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [-1] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f = [0] * maxn",
      "mutated_line": "f = [1] * maxn",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [1] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] / g[i - j - 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] / g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] + g[i - j - 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] + g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] ** g[i - j - 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] ** g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 2:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 0:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 0:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == -1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[1] = n - 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[1] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[-1] = n - 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[-1] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[1] = n - 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[1] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[0] = n - 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 2\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[0] = n - 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 0\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[0] = n - 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 0\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ret[0] = n - 1",
      "mutated_line": "ret[0] = n - -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - -1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[1] = n - 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[1] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[-1] = n - 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[-1] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[1] = n - 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[1] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[0] = n - 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 2\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[0] = n - 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 0\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[0] = n - 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 0\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p1[0] = n - 1",
      "mutated_line": "p1[0] = n - -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - -1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n + 1] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n + 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n * 1] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n * 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "vis[n - 1] = True",
      "mutated_line": "vis[n + 1] = True",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n + 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "vis[n - 1] = True",
      "mutated_line": "vis[n * 1] = True",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n * 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(2, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(0, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(0, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(-1, n - 1):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(-1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n + 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n * 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 1\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = -1\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 1\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while False:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[+1] = p2[-1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[+1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-1] = p2[+1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[+1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return [x + 1 for x in ret]",
      "mutated_line": "return [x - 1 for x in ret]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x - 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return [x + 1 for x in ret]",
      "mutated_line": "return [x * 1 for x in ret]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x * 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 1:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if n == 0:",
      "mutated_line": "if n == -1:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == -1:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if n == 0:",
      "mutated_line": "if n == 1:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 1:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] / f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] / f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] + f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] + f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] ** f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] ** f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 1] / f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] / f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 1] + f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] + f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 1] ** f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] ** f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 2\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 0\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 0\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += -1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n + i, (k - 1) % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n + i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n * i, (k - 1) % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n * i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n - i] - 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] - 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n - i] * 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] * 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "rem = [x + i for x in rem]",
      "mutated_line": "rem = [x - i for x in rem]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x - i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "rem = [x + i for x in rem]",
      "mutated_line": "rem = [x * i for x in rem]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x * i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) / f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) / f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) * f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) * f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n - i] + 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 2\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n - i] + 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 0\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n - i] + 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 0\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n - i] + -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + -1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "UOI",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return +1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [1]",
      "mutated_line": "return [2]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [2]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [1]",
      "mutated_line": "return [0]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [0]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [1]",
      "mutated_line": "return [0]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [0]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [1]",
      "mutated_line": "return [-1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [-1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [+1] * n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [+1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [True] * n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [True] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n - 2] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 2] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n - 0] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 0] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n - 0] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 0] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p2[n - 1] = 0",
      "mutated_line": "p2[n - -1] = 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - -1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis[n - 1] = True",
      "mutated_line": "vis[n - 2] = True",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 2] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis[n - 1] = True",
      "mutated_line": "vis[n - 0] = True",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 0] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis[n - 1] = True",
      "mutated_line": "vis[n - 0] = True",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 0] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "vis[n - 1] = True",
      "mutated_line": "vis[n - -1] = True",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - -1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 2):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 2):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 0):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 0):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - -1):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - -1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n - i + 2)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i + 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial((n - i) * 2)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial((n - i) * 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] and (i < n - 1 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] and (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j -= 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if k > now:",
      "mutated_line": "if k >= now:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k >= now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if k > now:",
      "mutated_line": "if k <= now:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k <= now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if k > now:",
      "mutated_line": "if k != now:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k != now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "k -= now",
      "mutated_line": "k += now",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k += now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j -= 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-2] = p2[-1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-2] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-0] = p2[-1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-0] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-0] = p2[-1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-0] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[--1] = p2[-1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[--1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-1] = p2[-2]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-2]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-1] = p2[-0]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-0]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-1] = p2[-0]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-0]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ret[-1] = p2[-1]",
      "mutated_line": "ret[-1] = p2[--1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[--1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [x + 1 for x in ret]",
      "mutated_line": "return [x + 2 for x in ret]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 2 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [x + 1 for x in ret]",
      "mutated_line": "return [x + 0 for x in ret]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 0 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [x + 1 for x in ret]",
      "mutated_line": "return [x + 0 for x in ret]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 0 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return [x + 1 for x in ret]",
      "mutated_line": "return [x + -1 for x in ret]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + -1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) * f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) * f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, k - 1 + f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, k - 1 + f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n - i] + 2)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 2)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n - i] + 0)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 0)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n - i] + 0)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 0)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n - i] + -1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + -1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k + 1) // f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k + 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = k * 1 // f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = k * 1 // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -2\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -0\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -0\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return --1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[i - j + 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j + 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[(i - j) * 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[(i - j) * 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [-2] * n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-2] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [-0] * n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-0] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [-0] * n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-0] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = [-1] * n",
      "mutated_line": "ret = [--1] * n",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [--1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n + i - 2)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n + i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n * i - 2)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n * i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n - i - 3)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 3)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n - i - 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 1)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n - i - 0)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 0)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n - i - 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 1)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "now = math.factorial(n - i - 2)",
      "mutated_line": "now = math.factorial(n - i - -2)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - -2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n - 1 or j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 or j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 2\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 0\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 0\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += -1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 2\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 0\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 0\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += -1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vis[j] = True",
      "mutated_line": "vis[j] = False",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = False\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i + 1] * f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i + 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i * 1] * f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i * 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] * f[n + i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n + i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 1] * f[n * i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n * i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i + 1] * f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i + 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i * 1] * f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i * 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 1] * f[n + i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n + i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 1] * f[n * i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n * i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k + 1) % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k + 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, k * 1 % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, k * 1 % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 2) // f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 2) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 0) // f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 0) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 0) // f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 0) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - -1) // f[n - i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - -1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n + i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n + i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "k = (k - 1) // f[n - i] + 1",
      "mutated_line": "k = (k - 1) // f[n * i] + 1",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n * i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[i + j - 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i + j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[i * j - 1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i * j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[i - j - 2]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 2]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[i - j - 0]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 0]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[i - j - 0]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 0]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "f[i] += f[j] * g[i - j - 1]",
      "mutated_line": "f[i] += f[j] * g[i - j - -1]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - -1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i <= n - 1 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i <= n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i >= n - 1 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i >= n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i != n - 1 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i != n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n - 1 and j != p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j != p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 2] * f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 2] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 0] * f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 0] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - 0] * f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 0] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "while g[i - 1] * f[n - i] < k:",
      "mutated_line": "while g[i - -1] * f[n - i] < k:",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - -1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 2] * f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 2] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 0] * f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 0] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - 0] * f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 0] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "k -= g[i - 1] * f[n - i]",
      "mutated_line": "k -= g[i - -1] * f[n - i]",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - -1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 2) % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 2) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 0) % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 0) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 0) % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 0) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - -1) % f[n - i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - -1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n + i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n + i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "rem = solve(n - i, (k - 1) % f[n - i] + 1)",
      "mutated_line": "rem = solve(n - i, (k - 1) % f[n * i] + 1)",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n * i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n + 1 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n + 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n * 1 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n * 1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n - 2 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 2 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n - 0 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 0 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n - 0 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - 0 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while vis[j] or (i < n - 1 and j == p2[i]):",
      "mutated_line": "while vis[j] or (i < n - -1 and j == p2[i]):",
      "code": "import math\nmaxn = 55\ng = [1]\nfor i in range(maxn):\n    g.append(math.factorial(i))\nf = [0] * maxn\nf[0] = 1\nfor i in range(1, maxn):\n    for j in range(i):\n        f[i] += f[j] * g[i - j - 1]\n\ndef kth(n, k):\n    if n == 1:\n        return [1]\n    ret = [-1] * n\n    ret[0] = n - 1\n    p1 = [i for i in range(n)]\n    p2 = [i for i in range(n)]\n    vis = [False] * n\n    p1[0] = n - 1\n    p2[n - 1] = 0\n    vis[n - 1] = True\n    for i in range(1, n - 1):\n        j = 0\n        now = math.factorial(n - i - 2)\n        while True:\n            while vis[j] or (i < n - -1 and j == p2[i]):\n                j += 1\n            if k > now:\n                k -= now\n                j += 1\n            else:\n                p1[p2[i]] = p1[j]\n                p2[p1[j]] = p2[i]\n                ret[i] = j\n                vis[j] = True\n                break\n    ret[-1] = p2[-1]\n    return [x + 1 for x in ret]\n\ndef solve(n, k):\n    if n == 0:\n        return []\n    i = 1\n    while g[i - 1] * f[n - i] < k:\n        k -= g[i - 1] * f[n - i]\n        i += 1\n    rem = solve(n - i, (k - 1) % f[n - i] + 1)\n    rem = [x + i for x in rem]\n    k = (k - 1) // f[n - i] + 1\n    return kth(i, k) + rem\n\ndef find_kth_good_permutation(n, k):\n    if k > f[n]:\n        return -1\n    return solve(n, k)"
    }
  ]
}