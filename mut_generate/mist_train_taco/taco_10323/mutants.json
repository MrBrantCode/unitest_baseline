{
  "task_id": "taco_10323",
  "entry_point": "minimum_cost_to_determine_cards",
  "mutant_count": 42,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "self.parents[x] += self.parents[y]",
      "mutated_line": "self.parents[x] -= self.parents[y]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] -= self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [-1] / n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] / n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [-1] + n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] + n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [-1] ** n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] ** n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] <= 0:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] <= 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] >= 0:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] >= 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] != 0:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] != 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if x == y:",
      "mutated_line": "if x != y:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if self.parents[x] > self.parents[y]:",
      "mutated_line": "if self.parents[x] >= self.parents[y]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] >= self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if self.parents[x] > self.parents[y]:",
      "mutated_line": "if self.parents[x] <= self.parents[y]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] <= self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if self.parents[x] > self.parents[y]:",
      "mutated_line": "if self.parents[x] != self.parents[y]:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] != self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "return -self.parents[self.find(x)]",
      "mutated_line": "return +self.parents[self.find(x)]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return +self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "return self.find(x) == self.find(y)",
      "mutated_line": "return self.find(x) != self.find(y)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) != self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] < 1:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 1:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] < -1:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < -1:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if self.parents[x] < 0:",
      "mutated_line": "if self.parents[x] < 1:",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 1:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X + 1, Y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X + 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X * 1, Y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X * 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 1, Y + 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y + 1)\n    return len(uf.roots())"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 1, Y * 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y * 1)\n    return len(uf.roots())"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [+1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [+1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "return [i for i in range(self.n) if self.find(i) == root]",
      "mutated_line": "return [i for i in range(self.n) if self.find(i) != root]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) != root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x <= 0]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x <= 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x >= 0]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x >= 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x != 0]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x != 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))",
      "mutated_line": "return ''.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return ''.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 2, Y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 2, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 0, Y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 0, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 0, Y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 0, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - -1, Y - 1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - -1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 1, Y - 2)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 2)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 1, Y - 0)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 0)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 1, Y - 0)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 0)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "uf.union(X - 1, Y - 1)",
      "mutated_line": "uf.union(X - 1, Y - -1)",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - -1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [-2] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-2] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [-0] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [-0] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-0] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.parents = [-1] * n",
      "mutated_line": "self.parents = [--1] * n",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [--1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x < 1]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 1]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x < -1]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < -1]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return [i for (i, x) in enumerate(self.parents) if x < 0]",
      "mutated_line": "return [i for (i, x) in enumerate(self.parents) if x < 1]",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 1]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return '\\n'.join(('{}: {}'.format(r, self.members(r)) for r in self.roots()))",
      "mutated_line": "return '\\n'.join((''.format(r, self.members(r)) for r in self.roots()))",
      "code": "class UnionFind:\n\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.parents[x] > self.parents[y]:\n            (x, y) = (y, x)\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for (i, x) in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n    def __str__(self):\n        return '\\n'.join((''.format(r, self.members(r)) for r in self.roots()))\n\ndef minimum_cost_to_determine_cards(N, M, conditions):\n    uf = UnionFind(N)\n    for (X, Y, Z) in conditions:\n        uf.union(X - 1, Y - 1)\n    return len(uf.roots())"
    }
  ]
}