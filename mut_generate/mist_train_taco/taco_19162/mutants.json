{
  "task_id": "taco_19162",
  "entry_point": "count_valid_splits",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "MOD = 1000000008\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "MOD = 1000000006\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "MOD = -1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(2, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(0, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(0, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(-1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prod = 1",
      "mutated_line": "prod = 2",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 2\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prod = 1",
      "mutated_line": "prod = 0",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 0\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prod = 1",
      "mutated_line": "prod = 0",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 0\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "prod = 1",
      "mutated_line": "prod = -1",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = -1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod /= count[ch][0] + count[ch][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod /= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return count[0][1]",
      "mutated_line": "return count[0][2]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][2]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return count[0][1]",
      "mutated_line": "return count[0][0]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return count[0][1]",
      "mutated_line": "return count[0][0]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return count[0][1]",
      "mutated_line": "return count[0][-1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = [(0, 0) for _ in range(n)]",
      "mutated_line": "count = [(1, 0) for _ in range(n)]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(1, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = [(0, 0) for _ in range(n)]",
      "mutated_line": "count = [(-1, 0) for _ in range(n)]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(-1, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = [(0, 0) for _ in range(n)]",
      "mutated_line": "count = [(1, 0) for _ in range(n)]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(1, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = [(0, 0) for _ in range(n)]",
      "mutated_line": "count = [(0, 1) for _ in range(n)]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 1) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = [(0, 0) for _ in range(n)]",
      "mutated_line": "count = [(0, -1) for _ in range(n)]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, -1) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "count = [(0, 0) for _ in range(n)]",
      "mutated_line": "count = [(0, 1) for _ in range(n)]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 1) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][0] - count[ch][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] - count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][0] * count[ch][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] * count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tot = 0",
      "mutated_line": "tot = 1",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 1\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tot = 0",
      "mutated_line": "tot = -1",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = -1\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tot = 0",
      "mutated_line": "tot = 1",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 1\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "tot += cur",
      "mutated_line": "tot -= cur",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot -= cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return count[0][1]",
      "mutated_line": "return count[1][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return count[0][1]",
      "mutated_line": "return count[-1][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[-1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return count[0][1]",
      "mutated_line": "return count[1][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[1][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count[i] = (0, prod % MOD)",
      "mutated_line": "count[i] = (1, prod % MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (1, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count[i] = (0, prod % MOD)",
      "mutated_line": "count[i] = (-1, prod % MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (-1, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "count[i] = (0, prod % MOD)",
      "mutated_line": "count[i] = (1, prod % MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (1, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "count[i] = (0, prod % MOD)",
      "mutated_line": "count[i] = (0, prod * MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod * MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "count[i] = (0, prod % MOD)",
      "mutated_line": "count[i] = (0, prod + MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod + MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod / (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod / (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod * (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod * (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "count[i] = (prod % MOD, tot % MOD)",
      "mutated_line": "count[i] = (prod * MOD, tot % MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod * MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "count[i] = (prod % MOD, tot % MOD)",
      "mutated_line": "count[i] = (prod + MOD, tot % MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod + MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "count[i] = (prod % MOD, tot % MOD)",
      "mutated_line": "count[i] = (prod % MOD, tot * MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot * MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "count[i] = (prod % MOD, tot % MOD)",
      "mutated_line": "count[i] = (prod % MOD, tot + MOD)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot + MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][1] + count[ch][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][1] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][-1] + count[ch][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][-1] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][1] + count[ch][1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][1] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][0] + count[ch][2]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][2]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][0] + count[ch][0]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][0]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][0] + count[ch][0]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][0]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prod *= count[ch][0] + count[ch][1]",
      "mutated_line": "prod *= count[ch][0] + count[ch][-1]",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][-1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] / prod // (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] / prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = (count[ch][1] + prod) // (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = (count[ch][1] + prod) // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] ** prod // (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] ** prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][0] - count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] - count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][0] * count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] * count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "children[p[i - 1]].append(i)",
      "mutated_line": "children[p[i + 1]].append(i)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i + 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "children[p[i - 1]].append(i)",
      "mutated_line": "children[p[i * 1]].append(i)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i * 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "children[p[i - 1]].append(i)",
      "mutated_line": "children[p[i - 2]].append(i)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 2]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "children[p[i - 1]].append(i)",
      "mutated_line": "children[p[i - 0]].append(i)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 0]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "children[p[i - 1]].append(i)",
      "mutated_line": "children[p[i - 0]].append(i)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 0]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "children[p[i - 1]].append(i)",
      "mutated_line": "children[p[i - -1]].append(i)",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - -1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][2] * prod // (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][2] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][0] * prod // (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][0] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][0] * prod // (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][0] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][-1] * prod // (count[ch][0] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][-1] * prod // (count[ch][0] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][1] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][1] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][-1] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][-1] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][1] + count[ch][1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][1] + count[ch][1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][2])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][2])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][0])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][0])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][0])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][0])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][1])",
      "mutated_line": "cur = count[ch][1] * prod // (count[ch][0] + count[ch][-1])",
      "code": "MOD = 1000000007\n\ndef count_valid_splits(n, p, x):\n    children = [[] for _ in range(n)]\n    for i in range(1, n):\n        children[p[i - 1]].append(i)\n    count = [(0, 0) for _ in range(n)]\n    for i in reversed(range(n)):\n        prod = 1\n        for ch in children[i]:\n            prod *= count[ch][0] + count[ch][1]\n        if x[i]:\n            count[i] = (0, prod % MOD)\n        else:\n            tot = 0\n            for ch in children[i]:\n                cur = count[ch][1] * prod // (count[ch][0] + count[ch][-1])\n                tot += cur\n            count[i] = (prod % MOD, tot % MOD)\n    return count[0][1]"
    }
  ]
}