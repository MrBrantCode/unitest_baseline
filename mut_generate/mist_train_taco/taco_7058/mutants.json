{
  "task_id": "taco_7058",
  "entry_point": "is_puzzle_solvable",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) != 0",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) != 0"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 0 and x == R and (y == 0) and (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 and x == R and (y == 0) and (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if y == 0:",
      "mutated_line": "if y != 0:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y != 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if edge(x1, y1) and edge(x2, y2):",
      "mutated_line": "if edge(x1, y1) or edge(x2, y2):",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) or edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 0 or stack[-1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 or stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) == 1",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) == -1",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return len(stack) == 0",
      "mutated_line": "return len(stack) == 1",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x != 0 or x == R or y == 0 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x != 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 0 or x != R or y == 0 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x != R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 0 or x == R or y != 0 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y != 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 0 or x == R or y == 0 or (y != C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y != C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y == 0:",
      "mutated_line": "if y == 1:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 1:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y == 0:",
      "mutated_line": "if y == -1:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == -1:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if y == 0:",
      "mutated_line": "if y == 1:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 1:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "elif x == R:",
      "mutated_line": "elif x != R:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x != R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) >= 0 and stack[-1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) >= 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) <= 0 and stack[-1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) <= 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) != 0 and stack[-1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) != 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 0 and stack[-1] != i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] != i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 1 or x == R or y == 0 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 1 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == -1 or x == R or y == 0 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == -1 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 1 or x == R or y == 0 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 1 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 0 or x == R or y == 1 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 1 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 0 or x == R or y == -1 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == -1 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return x == 0 or x == R or y == 0 or (y == C)",
      "mutated_line": "return x == 0 or x == R or y == 1 or (y == C)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 1 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return R + y",
      "mutated_line": "return R - y",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R - y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return R + y",
      "mutated_line": "return R * y",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R * y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif y == C:",
      "mutated_line": "elif y != C:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y != C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 1 and stack[-1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 1 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > -1 and stack[-1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > -1 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 1 and stack[-1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 1 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return R + C + (R - x)",
      "mutated_line": "return R + C - (R - x)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C - (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return R + C + (R - x)",
      "mutated_line": "return (R + C) * (R - x)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return (R + C) * (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "assert x == 0",
      "mutated_line": "assert x != 0",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x != 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 * R + C - (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C - (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return (2 * R + C) * (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return (2 * R + C) * (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 0 and stack[+1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[+1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return R + C + (R - x)",
      "mutated_line": "return R - C + (R - x)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R - C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return R + C + (R - x)",
      "mutated_line": "return R * C + (R - x)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R * C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return R + C + (R - x)",
      "mutated_line": "return R + C + (R + x)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R + x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return R + C + (R - x)",
      "mutated_line": "return R + C + R * x",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + R * x\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "assert x == 0",
      "mutated_line": "assert x == 1",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 1\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "assert x == 0",
      "mutated_line": "assert x == -1",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == -1\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "assert x == 0",
      "mutated_line": "assert x == 1",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 1\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 * R - C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R - C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 * R * C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R * C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 * R + C + (C + y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C + y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 * R + C + C * y",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + C * y\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 0 and stack[-2] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-2] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 0 and stack[-0] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-0] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 0 and stack[-0] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-0] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(stack) > 0 and stack[-1] == i:",
      "mutated_line": "if len(stack) > 0 and stack[--1] == i:",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[--1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 / R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 / R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 + R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 + R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 2 ** R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 2 ** R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 3 * R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 3 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 1 * R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 1 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 0 * R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 0 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return 1 * R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return 1 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 2 * R + C + (C - y)",
      "mutated_line": "return -2 * R + C + (C - y)",
      "code": "def is_puzzle_solvable(R, C, N, points):\n\n    def edge(x, y):\n        return x == 0 or x == R or y == 0 or (y == C)\n\n    def flat(x, y):\n        assert edge(x, y)\n        if y == 0:\n            return x\n        elif x == R:\n            return R + y\n        elif y == C:\n            return R + C + (R - x)\n        else:\n            assert x == 0\n            return -2 * R + C + (C - y)\n    ps = []\n    for i in range(N):\n        (x1, y1, x2, y2) = points[i]\n        if edge(x1, y1) and edge(x2, y2):\n            ps.append((flat(x1, y1), i))\n            ps.append((flat(x2, y2), i))\n    ps.sort()\n    stack = []\n    for (_, i) in ps:\n        if len(stack) > 0 and stack[-1] == i:\n            stack.pop()\n        else:\n            stack.append(i)\n    return len(stack) == 0"
    }
  ]
}