{
  "task_id": "taco_7419",
  "entry_point": "is_allocation_possible",
  "mutant_count": 188,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist = [0] * n",
      "mutated_line": "dist = [0] / n",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] / n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist = [0] * n",
      "mutated_line": "dist = [0] + n",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] + n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dist = [0] * n",
      "mutated_line": "dist = [0] ** n",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] ** n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 'POSSIBLE'",
      "mutated_line": "return ''",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = [0]",
      "mutated_line": "q = [1]",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [1]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = [0]",
      "mutated_line": "q = [-1]",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [-1]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = [0]",
      "mutated_line": "q = [1]",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [1]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if len(g[i]) == 0:",
      "mutated_line": "if len(g[i]) != 0:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) != 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] / (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] / (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] + (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] + (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] ** (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] ** (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 1\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = -1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = -1\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[0] = 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 1\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][1] != 10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] != 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 1].append(i - 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i - 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 1].append(i * 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i * 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist = [0] * n",
      "mutated_line": "dist = [1] * n",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [1] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist = [0] * n",
      "mutated_line": "dist = [-1] * n",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [-1] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "dist = [0] * n",
      "mutated_line": "dist = [1] * n",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [1] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if i != 0:",
      "mutated_line": "if i == 0:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i == 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "memo = [[i, 0] for i in x]",
      "mutated_line": "memo = [[i, 1] for i in x]",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 1] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "memo = [[i, 0] for i in x]",
      "mutated_line": "memo = [[i, -1] for i in x]",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, -1] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "memo = [[i, 0] for i in x]",
      "mutated_line": "memo = [[i, 1] for i in x]",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 1] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(g[i]) == 0:",
      "mutated_line": "if len(g[i]) == 1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 1:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(g[i]) == 0:",
      "mutated_line": "if len(g[i]) == -1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == -1:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if len(g[i]) == 0:",
      "mutated_line": "if len(g[i]) == 1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 1:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] * (x[i] - 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] - 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] * (x[i] * 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] * 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[1] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[-1] = 0",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[-1] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[0] = 0",
      "mutated_line": "dp[1] = 0",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[1] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] / (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] / (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] + (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] + (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] ** (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] ** (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "memo[i][1] = min(dp)",
      "mutated_line": "memo[i][2] = min(dp)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][2] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "memo[i][1] = min(dp)",
      "mutated_line": "memo[i][0] = min(dp)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][0] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "memo[i][1] = min(dp)",
      "mutated_line": "memo[i][0] = min(dp)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][0] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "memo[i][1] = min(dp)",
      "mutated_line": "memo[i][-1] = min(dp)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][-1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][1] == 10004:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10004:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][1] == 10002:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10002:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][1] == 0:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 0:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][1] == 1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 1:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][1] == -10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == -10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 'IMPOSSIBLE'",
      "mutated_line": "return ''",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return ''\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 1].append(i + 2)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 2)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 1].append(i + 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 0)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 1].append(i + 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 0)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 1].append(i + -1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + -1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i != 0:",
      "mutated_line": "if i != 1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 1:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i != 0:",
      "mutated_line": "if i != -1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != -1:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if i != 0:",
      "mutated_line": "if i != 1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 1:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 1] - 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] - 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 1] * 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] * 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "dist = sorted([[-j, i] for i, j in enumerate(dist)])",
      "mutated_line": "dist = [j for (_, j) in dist]",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[+j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10004] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10004] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10002] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10002] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [0] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [0] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [1] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [1] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [-10003] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [-10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] * (x[i] + 2)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 2)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] * (x[i] + 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 0)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] * (x[i] + 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 0)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "dp = [10003] * (x[i] + 1)",
      "mutated_line": "dp = [10003] * (x[i] + -1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + -1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] * (x[i] - 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] - 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] * (x[i] * 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] * 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] + memo[j][0], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] + memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] * memo[j][0], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] * memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], +1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], +1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -1, +1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, +1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] == 10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] == 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] + memo[j][1], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] + memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] * memo[j][1], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] * memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], +1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], +1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -1, +1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, +1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] == 10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] == 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][2] == 10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][2] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][0] == 10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][0] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][0] == 10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][0] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if memo[i][1] == 10003:",
      "mutated_line": "if memo[i][-1] == 10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][-1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j + 1].append(i + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j + 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j * 1].append(i + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j * 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 1] + 2",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 2\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 1] + 0",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 0\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 1] + 0",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 0\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 1] + -1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + -1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10004] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10004] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10002] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10002] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [0] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [0] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [1] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [1] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [-10003] * (x[i] + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [-10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] * (x[i] + 2)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 2)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] * (x[i] + 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 0)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] * (x[i] + 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 0)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp2 = [10003] * (x[i] + 1)",
      "mutated_line": "dp2 = [10003] * (x[i] + -1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + -1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -2, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -2, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -0, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -0, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -0, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -0, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], --1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], --1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -1, -2):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -2):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -1, -0):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -0):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -1, -0):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -0):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -1, --1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, --1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 10004:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10004:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 10002:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10002:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 0:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 0:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 1:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != -10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != -10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -2, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -2, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -0, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -0, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -0, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -0, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], --1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], --1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -1, -2):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -2):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -1, -0):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -0):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -1, -0):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -0):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -1, --1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, --1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 10004:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10004:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 10002:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10002:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 0:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 0:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != 1:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 1:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if dp[k] != 10003:",
      "mutated_line": "if dp[k] != -10003:",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != -10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 2].append(i + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 2].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 0].append(i + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 0].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - 0].append(i + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 0].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "g[j - 1].append(i + 1)",
      "mutated_line": "g[j - -1].append(i + 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - -1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] + 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] + 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] * 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] * 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][-1], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][-1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k - memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k - memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k * memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k * memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] - memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] - memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] * memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] * memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5002)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5002)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5000)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5000)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 0)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 1)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], -5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], -5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][2], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][2], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][0], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for k in range(x[i] - memo[j][1], -1, -1):",
      "mutated_line": "for k in range(x[i] - memo[j][-1], -1, -1):",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][-1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k - memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k - memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k * memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k * memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] - memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] - memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] * memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] * memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5002)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5002)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5000)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5000)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 0)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 0)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 1)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 1)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], -5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], -5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 2] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 2] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 0] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 0] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - 0] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 0] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 1] - -1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - -1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k - memo[j][0]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k - memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k * memo[j][0]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k * memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k - memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k - memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k * memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k * memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i + 1] - 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i + 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i * 1] - 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i * 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][-1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][-1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][2], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][2], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][-1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][-1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][2]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][2]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][-1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][-1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][-1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][-1], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 2] - 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 2] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 0] - 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 0] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - 0] - 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 0] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist[i] = dist[p[i - 1] - 1] + 1",
      "mutated_line": "dist[i] = dist[p[i - -1] - 1] + 1",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - -1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][-1]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][-1]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)",
      "mutated_line": "dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][2]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][2]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][1]], dp[k] + memo[j][0], 5001)",
      "mutated_line": "dp2[k + memo[j][1]] = min(dp2[k + memo[j][-1]], dp[k] + memo[j][0], 5001)",
      "code": "def is_allocation_possible(n, p, x):\n    \"\"\"\n    Determines whether it is possible to allocate colors and weights to the vertices of a tree\n    such that the total weight of the vertices with the same color as any vertex v, among the\n    vertices contained in the subtree whose root is v, is equal to X_v.\n\n    Parameters:\n    - n (int): The number of vertices in the tree.\n    - p (list of int): A list where p[i-2] (for 2 <= i <= n) gives the parent of vertex i.\n    - x (list of int): A list where x[i-1] (for 1 <= i <= n) gives the favorite integer for vertex i.\n\n    Returns:\n    - str: \"POSSIBLE\" if the allocation is possible, otherwise \"IMPOSSIBLE\".\n    \"\"\"\n    g = [[] for _ in range(n)]\n    for (i, j) in enumerate(p):\n        g[j - 1].append(i + 1)\n    dist = [0] * n\n    q = [0]\n    while q:\n        qq = q.pop()\n        for i in g[qq]:\n            if i != 0:\n                dist[i] = dist[p[i - 1] - 1] + 1\n                q.append(i)\n    dist = sorted([[-j, i] for (i, j) in enumerate(dist)])\n    dist = [j for (_, j) in dist]\n    memo = [[i, 0] for i in x]\n    for i in dist:\n        if len(g[i]) == 0:\n            continue\n        dp = [10003] * (x[i] + 1)\n        dp[0] = 0\n        for j in g[i]:\n            dp2 = [10003] * (x[i] + 1)\n            for k in range(x[i] - memo[j][0], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][0]] = min(dp2[k + memo[j][0]], dp[k] + memo[j][1], 5001)\n            for k in range(x[i] - memo[j][1], -1, -1):\n                if dp[k] != 10003:\n                    dp2[k + memo[j][1]] = min(dp2[k + memo[j][-1]], dp[k] + memo[j][0], 5001)\n            dp = dp2\n        memo[i][1] = min(dp)\n        if memo[i][1] == 10003:\n            return 'IMPOSSIBLE'\n    return 'POSSIBLE'"
    }
  ]
}