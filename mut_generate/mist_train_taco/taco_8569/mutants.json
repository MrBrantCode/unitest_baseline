{
  "task_id": "taco_8569",
  "entry_point": "rearrange_markers",
  "mutant_count": 92,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = True\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] != queue[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] != queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [-1] / N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] / N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [-1] + N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] + N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [-1] ** N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] ** N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if a[i] not in dic:",
      "mutated_line": "if a[i] in dic:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 1\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = -1\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 1\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 and queue[0][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 and queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c -= 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) >= N // 2:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) >= N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) <= N // 2:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) <= N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) != N // 2:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) != N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][1] == queue[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][1] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][-1] == queue[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][-1] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][1] == queue[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][1] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] == queue[0][2]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][2]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] == queue[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][0]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] == queue[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][0]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] == queue[0][-1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][-1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c != 0 or queue[0][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c != 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][0] != l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] != l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 2\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 0\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 0\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += -1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if l[i][0] == m[i][0]:",
      "mutated_line": "if l[i][0] != m[i][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] != m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [+1] * N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [+1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[2]] = item[1]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[1]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[2]] = item[-1]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[-1]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[2]] = item[1]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[1]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "results.append((\"Yes\", ans))",
      "mutated_line": "results.append(('', ans))",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('', ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) > N / 2:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N / 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) > N * 2:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N * 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = False\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "results.append((\"No\", []))",
      "mutated_line": "results.append(('', []))",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[1][0] == queue[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[1][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[-1][0] == queue[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[-1][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[1][0] == queue[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[1][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] == queue[1][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[1][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] == queue[-1][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[-1][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "while queue[0][0] == queue[0][1]:",
      "mutated_line": "while queue[0][0] == queue[1][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[1][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 1 or queue[0][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 1 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == -1 or queue[0][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == -1 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 1 or queue[0][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 1 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = False\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "results.append((\"No\", []))",
      "mutated_line": "results.append(('', []))",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [-2] * N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-2] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [-0] * N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-0] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [-0] * N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-0] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "ans = [-1] * N",
      "mutated_line": "ans = [--1] * N",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [--1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[3]] = item[0]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[3]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[1]] = item[0]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[1]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[0]] = item[0]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[0]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[1]] = item[0]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[1]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "ans[item[2]] = item[0]",
      "mutated_line": "ans[item[-2]] = item[0]",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[-2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) > N // 3:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 3:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) > N // 1:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 1:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) > N // 0:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 0:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) > N // 1:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 1:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if len(dic[a[i]]) > N // 2:",
      "mutated_line": "if len(dic[a[i]]) > N // -2:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // -2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][1] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][1] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][-1] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][-1] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][1] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][1] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][0] == l[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][1]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][0] == l[0][-1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][-1]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][0] == l[0][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][1]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if l[i][0] == m[i][0]:",
      "mutated_line": "if l[i][1] == m[i][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][1] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if l[i][0] == m[i][0]:",
      "mutated_line": "if l[i][-1] == m[i][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][-1] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if l[i][0] == m[i][0]:",
      "mutated_line": "if l[i][1] == m[i][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][1] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if l[i][0] == m[i][0]:",
      "mutated_line": "if l[i][0] == m[i][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][1]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if l[i][0] == m[i][0]:",
      "mutated_line": "if l[i][0] == m[i][-1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][-1]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if l[i][0] == m[i][0]:",
      "mutated_line": "if l[i][0] == m[i][1]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][1]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][1], l[i][0]) = (l[i][0], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][1], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][-1], l[i][0]) = (l[i][0], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][-1], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][1], l[i][0]) = (l[i][0], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][1], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][1]) = (l[i][0], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][1]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][-1]) = (l[i][0], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][-1]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][1]) = (l[i][0], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][1]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][0]) = (l[i][1], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][1], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][0]) = (l[i][-1], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][-1], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][0]) = (l[i][1], m[i][0])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][1], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][1])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][1])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][-1])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][-1])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][0])",
      "mutated_line": "(m[i][0], l[i][0]) = (l[i][0], m[i][1])",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][1])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[1][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[1][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[-1][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[-1][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[1][0] == l[0][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[1][0] == l[0][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][0] == l[1][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[1][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][0] == l[-1][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[-1][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while c == 0 or queue[0][0] == l[0][0]:",
      "mutated_line": "while c == 0 or queue[0][0] == l[1][0]:",
      "code": "import collections\n\ndef rearrange_markers(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, a) = case\n        dic = {}\n        flag = False\n        for i in range(N):\n            if a[i] not in dic:\n                dic[a[i]] = [i]\n            else:\n                dic[a[i]].append(i)\n                if len(dic[a[i]]) > N // 2:\n                    flag = True\n                    break\n        if flag:\n            results.append(('No', []))\n            continue\n        queue = []\n        for key in dic.keys():\n            for index in dic[key]:\n                queue.append([key, key, index])\n        queue = collections.deque(queue)\n        while queue[0][0] == queue[0][1]:\n            l = []\n            m = []\n            c = 0\n            while c == 0 or queue[0][0] == l[1][0]:\n                c += 1\n                l.append(queue.popleft())\n            for i in range(c):\n                m.append(queue.popleft())\n                if l[i][0] == m[i][0]:\n                    flag = True\n                    break\n                (m[i][0], l[i][0]) = (l[i][0], m[i][0])\n            if flag:\n                break\n            for i in range(c):\n                queue.append(l[i])\n            for i in range(len(m)):\n                queue.append(m[i])\n        if flag:\n            results.append(('No', []))\n            continue\n        ans = [-1] * N\n        for item in queue:\n            ans[item[2]] = item[0]\n        results.append(('Yes', ans))\n    return results"
    }
  ]
}