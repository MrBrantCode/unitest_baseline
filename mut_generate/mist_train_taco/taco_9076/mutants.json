{
  "task_id": "taco_9076",
  "entry_point": "dijkstra",
  "mutant_count": 65,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2147483647",
      "mutated_line": "INF = 2147483648",
      "code": "import heapq\nINF = 2147483648\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2147483647",
      "mutated_line": "INF = 2147483646",
      "code": "import heapq\nINF = 2147483646\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2147483647",
      "mutated_line": "INF = 0",
      "code": "import heapq\nINF = 0\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2147483647",
      "mutated_line": "INF = 1",
      "code": "import heapq\nINF = 1\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INF = 2147483647",
      "mutated_line": "INF = -2147483647",
      "code": "import heapq\nINF = -2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [INF] * V",
      "mutated_line": "dist = [INF] / V",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] / V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [INF] * V",
      "mutated_line": "dist = [INF] + V",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] + V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [INF] * V",
      "mutated_line": "dist = [INF] ** V",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] ** V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 1\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = -1\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 1\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "n1 = N - 1",
      "mutated_line": "n1 = N + 1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N + 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "n1 = N - 1",
      "mutated_line": "n1 = N * 1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N * 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a += 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b += 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dist[n1] >= INF:",
      "mutated_line": "if dist[n1] > INF:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] > INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dist[n1] >= INF:",
      "mutated_line": "if dist[n1] < INF:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] < INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if dist[n1] >= INF:",
      "mutated_line": "if dist[n1] == INF:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] == INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if dist[s] < t:",
      "mutated_line": "if dist[s] <= t:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] <= t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if dist[s] < t:",
      "mutated_line": "if dist[s] >= t:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] >= t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if dist[s] < t:",
      "mutated_line": "if dist[s] != t:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] != t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n1 = N - 1",
      "mutated_line": "n1 = N - 2",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 2\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n1 = N - 1",
      "mutated_line": "n1 = N - 0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 0\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n1 = N - 1",
      "mutated_line": "n1 = N - 0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 0\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "n1 = N - 1",
      "mutated_line": "n1 = N - -1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - -1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 2\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 0\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 0\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= -1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 2\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 0\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 0\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= -1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if b == n1:",
      "mutated_line": "if b != n1:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b != n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist = dijkstra(N, to, 0)",
      "mutated_line": "dist = dijkstra(N, to, 1)",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 1)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist = dijkstra(N, to, 0)",
      "mutated_line": "dist = dijkstra(N, to, -1)",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, -1)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dist = dijkstra(N, to, 0)",
      "mutated_line": "dist = dijkstra(N, to, 1)",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 1)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return +1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if dist[a] <= c:",
      "mutated_line": "if dist[a] < c:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] < c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if dist[a] <= c:",
      "mutated_line": "if dist[a] > c:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] > c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if dist[a] <= c:",
      "mutated_line": "if dist[a] == c:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] == c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "heapq.heappush(Q, (0, start))",
      "mutated_line": "heapq.heappush(Q, (1, start))",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (1, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "heapq.heappush(Q, (0, start))",
      "mutated_line": "heapq.heappush(Q, (-1, start))",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (-1, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "heapq.heappush(Q, (0, start))",
      "mutated_line": "heapq.heappush(Q, (1, start))",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (1, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if t <= cost and cost < dist[e]:",
      "mutated_line": "if t <= cost or cost < dist[e]:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost or cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -2\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -0\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -0\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return --1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t <= cost and cost < dist[e]:",
      "mutated_line": "if t < cost and cost < dist[e]:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t < cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t <= cost and cost < dist[e]:",
      "mutated_line": "if t > cost and cost < dist[e]:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t > cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t <= cost and cost < dist[e]:",
      "mutated_line": "if t == cost and cost < dist[e]:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t == cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t <= cost and cost < dist[e]:",
      "mutated_line": "if t <= cost and cost <= dist[e]:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost <= dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t <= cost and cost < dist[e]:",
      "mutated_line": "if t <= cost and cost >= dist[e]:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost >= dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t <= cost and cost < dist[e]:",
      "mutated_line": "if t <= cost and cost != dist[e]:",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost != dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "last.sort(key=lambda x: -x[1])",
      "mutated_line": "last.sort(key=lambda x: +x[1])",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: +x[1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "last.sort(key=lambda x: -x[1])",
      "mutated_line": "last.sort(key=lambda x: -x[2])",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[2])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "last.sort(key=lambda x: -x[1])",
      "mutated_line": "last.sort(key=lambda x: -x[0])",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[0])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "last.sort(key=lambda x: -x[1])",
      "mutated_line": "last.sort(key=lambda x: -x[0])",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[0])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "last.sort(key=lambda x: -x[1])",
      "mutated_line": "last.sort(key=lambda x: -x[-1])",
      "code": "import heapq\nINF = 2147483647\n\ndef dijkstra(V, to, start):\n    dist = [INF] * V\n    Q = []\n    dist[start] = 0\n    heapq.heappush(Q, (0, start))\n    while Q:\n        (t, s) = heapq.heappop(Q)\n        if dist[s] < t:\n            continue\n        for (e, cost) in to[s]:\n            if t <= cost and cost < dist[e]:\n                dist[e] = cost\n                heapq.heappush(Q, (cost, e))\n    return dist\n\ndef find_max_stay_time(N, M, bridges):\n    n1 = N - 1\n    last = []\n    to = [[] for _ in range(N)]\n    for (a, b, c) in bridges:\n        a -= 1\n        b -= 1\n        to[a].append((b, c))\n        if b == n1:\n            last.append((a, c))\n    dist = dijkstra(N, to, 0)\n    if dist[n1] >= INF:\n        return -1\n    last.sort(key=lambda x: -x[-1])\n    for (a, c) in last:\n        if dist[a] <= c:\n            return c\n    return -1"
    }
  ]
}