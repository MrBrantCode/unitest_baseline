{
  "task_id": "taco_5531",
  "entry_point": "find_min_moves_for_permutations",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] / (n + 1)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] / (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] + (n + 1)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] + (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] ** (n + 1)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] ** (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 and len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 and len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n - 1)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n - 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n * 1)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n * 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(2, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(0, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(0, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(-1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n - 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n * 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) >= 4 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) >= 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) <= 4 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) <= 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) != 4 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) != 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) >= 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) >= 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) <= 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) <= 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) != 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) != 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [True] * (n + 1)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [True] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + 2)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 2)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + 0)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 0)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + 0)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 0)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + -1)",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + -1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 2):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 0):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 0):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + -1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][1] != 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] != 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while False:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(one) > len(two):",
      "mutated_line": "if len(one) >= len(two):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) >= len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(one) > len(two):",
      "mutated_line": "if len(one) <= len(two):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) <= len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if len(one) > len(two):",
      "mutated_line": "if len(one) != len(two):",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) != len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return len(res), [i + 1 for i in res]",
      "mutated_line": "return (len(res), [i - 1 for i in res])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i - 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "return len(res), [i + 1 for i in res]",
      "mutated_line": "return (len(res), [i * 1 for i in res])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i * 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "pos = [[] for _ in range(n + 1)]",
      "mutated_line": "pos = [[] for _ in range(n - 1)]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n - 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "pos = [[] for _ in range(n + 1)]",
      "mutated_line": "pos = [[] for _ in range(n * 1)]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n * 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pos[row1[i]].extend((i, 0))",
      "mutated_line": "pos[row1[i]].extend((i, 1))",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 1))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pos[row1[i]].extend((i, 0))",
      "mutated_line": "pos[row1[i]].extend((i, -1))",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, -1))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pos[row1[i]].extend((i, 0))",
      "mutated_line": "pos[row1[i]].extend((i, 1))",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 1))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pos[row2[i]].extend((i, 1))",
      "mutated_line": "pos[row2[i]].extend((i, 2))",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 2))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pos[row2[i]].extend((i, 1))",
      "mutated_line": "pos[row2[i]].extend((i, 0))",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 0))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pos[row2[i]].extend((i, 1))",
      "mutated_line": "pos[row2[i]].extend((i, 0))",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 0))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "pos[row2[i]].extend((i, 1))",
      "mutated_line": "pos[row2[i]].extend((i, -1))",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, -1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 5 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 5 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 3 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 3 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 0 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 0 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 1 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 1 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > -4 or len(pos[row2[i]]) > 4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > -4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 5:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 5:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 3:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 3:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 0:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 0:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 1:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:",
      "mutated_line": "if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > -4:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > -4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return -1, []",
      "mutated_line": "return (+1, [])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (+1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = pos[i][0]",
      "mutated_line": "p = pos[i][1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][1]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = pos[i][0]",
      "mutated_line": "p = pos[i][-1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][-1]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p = pos[i][0]",
      "mutated_line": "p = pos[i][1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][1]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][1] == 2:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 2:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][1] == 0:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 0:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][1] == 0:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 0:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][1] == -1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == -1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "was[x] = True",
      "mutated_line": "was[x] = False",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = False\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if pos[x][0] == p:",
      "mutated_line": "if pos[x][0] != p:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] != p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if r == 0:",
      "mutated_line": "if r != 0:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r != 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return len(res), [i + 1 for i in res]",
      "mutated_line": "return (len(res), [i + 2 for i in res])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 2 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return len(res), [i + 1 for i in res]",
      "mutated_line": "return (len(res), [i + 0 for i in res])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 0 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return len(res), [i + 1 for i in res]",
      "mutated_line": "return (len(res), [i + 0 for i in res])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 0 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "return len(res), [i + 1 for i in res]",
      "mutated_line": "return (len(res), [i + -1 for i in res])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + -1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "pos = [[] for _ in range(n + 1)]",
      "mutated_line": "pos = [[] for _ in range(n + 2)]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 2)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "pos = [[] for _ in range(n + 1)]",
      "mutated_line": "pos = [[] for _ in range(n + 0)]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 0)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "pos = [[] for _ in range(n + 1)]",
      "mutated_line": "pos = [[] for _ in range(n + 0)]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 0)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "pos = [[] for _ in range(n + 1)]",
      "mutated_line": "pos = [[] for _ in range(n + -1)]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + -1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, []",
      "mutated_line": "return (-2, [])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-2, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, []",
      "mutated_line": "return (-0, [])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-0, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, []",
      "mutated_line": "return (-0, [])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-0, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return -1, []",
      "mutated_line": "return (--1, [])",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (--1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][2] == 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][2] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][0] == 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][0] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][0] == 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][0] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pos[i][1] == 1:",
      "mutated_line": "if pos[i][-1] == 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][-1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if p == first:",
      "mutated_line": "if p != first:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p != first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if p == first:",
      "mutated_line": "if p != first:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p != first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if r == 0:",
      "mutated_line": "if r == 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 1:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if r == 0:",
      "mutated_line": "if r == -1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == -1:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if r == 0:",
      "mutated_line": "if r == 1:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 1:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if pos[x][0] == p:",
      "mutated_line": "if pos[x][1] == p:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][1] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if pos[x][0] == p:",
      "mutated_line": "if pos[x][-1] == p:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][-1] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if pos[x][0] == p:",
      "mutated_line": "if pos[x][1] == p:",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][1] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p = pos[x][2]",
      "mutated_line": "p = pos[x][3]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][3]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p = pos[x][2]",
      "mutated_line": "p = pos[x][1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][1]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p = pos[x][2]",
      "mutated_line": "p = pos[x][0]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p = pos[x][2]",
      "mutated_line": "p = pos[x][1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][1]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p = pos[x][2]",
      "mutated_line": "p = pos[x][-2]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][-2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = pos[x][3]",
      "mutated_line": "r = pos[x][4]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][4]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = pos[x][3]",
      "mutated_line": "r = pos[x][2]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][2]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = pos[x][3]",
      "mutated_line": "r = pos[x][0]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][0]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = pos[x][3]",
      "mutated_line": "r = pos[x][1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = pos[x][3]",
      "mutated_line": "r = pos[x][-3]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][-3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = pos[x][0]",
      "mutated_line": "p = pos[x][1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][1]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = pos[x][0]",
      "mutated_line": "p = pos[x][-1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][-1]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "p = pos[x][0]",
      "mutated_line": "p = pos[x][1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][1]\n                    if p == first:\n                        break\n                    r = pos[x][1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = pos[x][1]",
      "mutated_line": "r = pos[x][2]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][2]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = pos[x][1]",
      "mutated_line": "r = pos[x][0]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][0]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = pos[x][1]",
      "mutated_line": "r = pos[x][0]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][0]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r = pos[x][1]",
      "mutated_line": "r = pos[x][-1]",
      "code": "def find_min_moves_for_permutations(n, row1, row2):\n    pos = [[] for _ in range(n + 1)]\n    for i in range(n):\n        pos[row1[i]].extend((i, 0))\n        pos[row2[i]].extend((i, 1))\n        if len(pos[row1[i]]) > 4 or len(pos[row2[i]]) > 4:\n            return (-1, [])\n    was = [False] * (n + 1)\n    res = []\n    for i in range(1, n + 1):\n        if not was[i]:\n            x = i\n            p = pos[i][0]\n            if pos[i][1] == 1:\n                (one, two) = ([p], [])\n            else:\n                (one, two) = ([], [p])\n            first = p\n            while True:\n                was[x] = True\n                if pos[x][0] == p:\n                    p = pos[x][2]\n                    if p == first:\n                        break\n                    r = pos[x][3]\n                else:\n                    p = pos[x][0]\n                    if p == first:\n                        break\n                    r = pos[x][-1]\n                if r == 0:\n                    one.append(p)\n                    x = row2[p]\n                else:\n                    two.append(p)\n                    x = row1[p]\n            if len(one) > len(two):\n                one = two\n            res.extend(one)\n    return (len(res), [i + 1 for i in res])"
    }
  ]
}