{
  "task_id": "taco_14194",
  "entry_point": "calculate_ball_positions_after_time",
  "mutant_count": 91,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while False:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "maxTime -= time",
      "mutated_line": "maxTime += time",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime += time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "self.x += self.v * time",
      "mutated_line": "self.x -= self.v * time",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x -= self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) * (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) * (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) // (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) // (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) * (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) * (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) // (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) // (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if time > maxTime:",
      "mutated_line": "if time >= maxTime:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time >= maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if time > maxTime:",
      "mutated_line": "if time <= maxTime:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time <= maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if time > maxTime:",
      "mutated_line": "if time != maxTime:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time != maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "self.x += self.v * time",
      "mutated_line": "self.x += self.v / time",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v / time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "self.x += self.v * time",
      "mutated_line": "self.x += self.v + time",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v + time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "self.x += self.v * time",
      "mutated_line": "self.x += self.v ** time",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v ** time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if self.v == other.v:",
      "mutated_line": "if self.v != other.v:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v != other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t = -(self.x - other.x) / (self.v - other.v)",
      "mutated_line": "t = -(self.x - other.x) * (self.v - other.v)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) * (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t = -(self.x - other.x) / (self.v - other.v)",
      "mutated_line": "t = -(self.x - other.x) // (self.v - other.v)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) // (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t <= 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t <= 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t >= 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t >= 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t != 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t != 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "minTime = float('inf')",
      "mutated_line": "minTime = float('')",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 - 2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 - 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = (m1 - m2) * v1 * (2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = (m1 - m2) * v1 * (2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 - m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 - m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 * m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 * m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 - 2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 - 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = (m2 - m1) * v2 * (2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = (m2 - m1) * v2 * (2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 - m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 - m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 * m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 * m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "t = -(self.x - other.x) / (self.v - other.v)",
      "mutated_line": "t = +(self.x - other.x) / (self.v - other.v)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = +(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t = -(self.x - other.x) / (self.v - other.v)",
      "mutated_line": "t = -(self.x - other.x) / (self.v + other.v)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v + other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t = -(self.x - other.x) / (self.v - other.v)",
      "mutated_line": "t = -(self.x - other.x) / (self.v * other.v)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v * other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t < 1.000000001:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1.000000001:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t < -0.999999999:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < -0.999999999:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t < 0:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 0:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t < 1:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if t < 1e-09:",
      "mutated_line": "if t < -1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < -1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i - 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i * 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if time < minTime:",
      "mutated_line": "if time <= minTime:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time <= minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if time < minTime:",
      "mutated_line": "if time >= minTime:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time >= minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if time < minTime:",
      "mutated_line": "if time != minTime:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time != minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) / v1 + 2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) / v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = (m1 - m2 + v1 + 2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = (m1 - m2 + v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) ** v1 + 2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) ** v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 / v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 / v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + (2 * m2 + v2)) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + (2 * m2 + v2)) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + (2 * m2) ** v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + (2 * m2) ** v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) / v2 + 2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) / v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = (m2 - m1 + v2 + 2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = (m2 - m1 + v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) ** v2 + 2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) ** v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 / v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 / v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + (2 * m1 + v1)) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + (2 * m1 + v1)) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + (2 * m1) ** v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + (2 * m1) ** v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return float('inf')",
      "mutated_line": "return float('')",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t = -(self.x - other.x) / (self.v - other.v)",
      "mutated_line": "t = -(self.x + other.x) / (self.v - other.v)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x + other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "t = -(self.x - other.x) / (self.v - other.v)",
      "mutated_line": "t = -(self.x * other.x) / (self.v - other.v)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x * other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return float('inf')",
      "mutated_line": "return float('')",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 2, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 0, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 0, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + -1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) <= 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) <= 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) >= 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) >= 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) != 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) != 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 + m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 + m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = (m1 * m2 * v1 + 2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = (m1 * m2 * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 2 / m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 / m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + (2 + m2) * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + (2 + m2) * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 2 ** m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 ** m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 + m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 + m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = (m2 * m1 * v2 + 2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = (m2 * m1 * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 2 / m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 / m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + (2 + m1) * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + (2 + m1) * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 2 ** m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 ** m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) < 1.000000001:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1.000000001:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) < -0.999999999:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < -0.999999999:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) < 0:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 0:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) < 1:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time - minTime) < -1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < -1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 3 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 3 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 1 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 1 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 0 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 0 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + 1 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 1 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)",
      "mutated_line": "balls[i].v = ((m1 - m2) * v1 + -2 * m2 * v2) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + -2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 3 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 3 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 1 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 1 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 0 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 0 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + 1 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 1 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)",
      "mutated_line": "balls[j].v = ((m2 - m1) * v2 + -2 * m1 * v1) / (m1 + m2)",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time - minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + -2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time + minTime) < 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time + minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif abs(time - minTime) < 1e-09:",
      "mutated_line": "elif abs(time * minTime) < 1e-09:",
      "code": "def calculate_ball_positions_after_time(n, t, ball_data):\n\n    class Ball:\n\n        def __init__(self, x, v, m):\n            self.v = v\n            self.x = x\n            self.m = m\n\n        def move(self, time):\n            self.x += self.v * time\n\n        def collisionTime(self, other):\n            if self.v == other.v:\n                return float('inf')\n            t = -(self.x - other.x) / (self.v - other.v)\n            if t < 1e-09:\n                return float('inf')\n            return t\n\n    def findFirst(balls):\n        minTime = float('inf')\n        minPairs = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                time = balls[i].collisionTime(balls[j])\n                if time < minTime:\n                    minTime = time\n                    minPairs = [(i, j)]\n                elif abs(time * minTime) < 1e-09:\n                    minPairs.append((i, j))\n        return (minTime, minPairs)\n\n    def collidePair(balls, i, j):\n        v1 = balls[i].v\n        v2 = balls[j].v\n        m1 = balls[i].m\n        m2 = balls[j].m\n        balls[i].v = ((m1 - m2) * v1 + 2 * m2 * v2) / (m1 + m2)\n        balls[j].v = ((m2 - m1) * v2 + 2 * m1 * v1) / (m1 + m2)\n    balls = [Ball(x, v, m) for (x, v, m) in ball_data]\n    maxTime = t\n    while True:\n        (time, pairs) = findFirst(balls)\n        if time > maxTime:\n            break\n        for i in range(n):\n            balls[i].move(time)\n        for (i, j) in pairs:\n            collidePair(balls, i, j)\n        maxTime -= time\n    for ball in balls:\n        ball.move(maxTime)\n    positions = [ball.x for ball in balls]\n    return positions"
    }
  ]
}