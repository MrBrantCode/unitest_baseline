{
  "task_id": "taco_8838",
  "entry_point": "calculate_max_convenience",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "self.par[rx] += self.par[ry]",
      "mutated_line": "self.par[rx] -= self.par[ry]",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] -= self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) != 1:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) != 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[1]) * 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) * 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = l[0] + l[1] + 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = l[0] + l[1] + 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ASR",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience -= l[i] ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience -= l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [-1] / n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] / n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [-1] + n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] + n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [-1] ** n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] ** n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [1] * n",
      "mutated_line": "self.rank = [1] / n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] / n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [1] * n",
      "mutated_line": "self.rank = [1] + n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] + n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.rank = [1] * n",
      "mutated_line": "self.rank = [1] ** n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] ** n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while x != p:",
      "mutated_line": "while x == p:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x == p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if rx == ry:",
      "mutated_line": "if rx != ry:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx != ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if self.rank[rx] < self.rank[ry]:",
      "mutated_line": "if self.rank[rx] <= self.rank[ry]:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] <= self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if self.rank[rx] < self.rank[ry]:",
      "mutated_line": "if self.rank[rx] >= self.rank[ry]:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] >= self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if self.rank[rx] < self.rank[ry]:",
      "mutated_line": "if self.rank[rx] != self.rank[ry]:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] != self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if self.rank[rx] == self.rank[ry]:",
      "mutated_line": "if self.rank[rx] != self.rank[ry]:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] != self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "self.rank[rx] += 1",
      "mutated_line": "self.rank[rx] -= 1",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] -= 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return self.root(x) == self.root(y)",
      "mutated_line": "return self.root(x) != self.root(y)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) != self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -self.par[self.root(x)]",
      "mutated_line": "return +self.par[self.root(x)]",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return +self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == 2:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 2:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == 0:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 0:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == 0:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 0:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if len(l) == 1:",
      "mutated_line": "if len(l) == -1:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == -1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return n * n",
      "mutated_line": "return n / n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n / n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return n * n",
      "mutated_line": "return n + n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n + n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return n * n",
      "mutated_line": "return n ** n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n ** n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] - l[1]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] - l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] * l[1]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] * l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[1]) ** 3",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 3\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[1]) ** 1",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 1\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[1]) ** 0",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 0\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[1]) ** 1",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 1\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[1]) ** -2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** -2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(2, len(l)):",
      "mutated_line": "for i in range(3, len(l)):",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(3, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(2, len(l)):",
      "mutated_line": "for i in range(1, len(l)):",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(1, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(2, len(l)):",
      "mutated_line": "for i in range(0, len(l)):",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(0, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(2, len(l)):",
      "mutated_line": "for i in range(1, len(l)):",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(1, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "for i in range(2, len(l)):",
      "mutated_line": "for i in range(-2, len(l)):",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(-2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience += l[i] * 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] * 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience += l[i] + 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] + 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while not self.par[p] < 0:",
      "mutated_line": "while not self.par[p] <= 0:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] <= 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while not self.par[p] < 0:",
      "mutated_line": "while not self.par[p] >= 0:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] >= 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while not self.par[p] < 0:",
      "mutated_line": "while not self.par[p] != 0:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] != 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return True\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.rank[rx] += 1",
      "mutated_line": "self.rank[rx] += 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 2\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.rank[rx] += 1",
      "mutated_line": "self.rank[rx] += 0",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 0\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.rank[rx] += 1",
      "mutated_line": "self.rank[rx] += 0",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 0\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.rank[rx] += 1",
      "mutated_line": "self.rank[rx] += -1",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += -1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "uf.unite(i, p[i] - 1)",
      "mutated_line": "uf.unite(i, p[i] + 1)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] + 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "uf.unite(i, p[i] - 1)",
      "mutated_line": "uf.unite(i, p[i] * 1)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] * 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "l.sort(reverse=True)",
      "mutated_line": "l.sort(reverse=False)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=False)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience += l[i] ** 3",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 3\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience += l[i] ** 1",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 1\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience += l[i] ** 0",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 0\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience += l[i] ** 1",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 1\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "max_convenience += l[i] ** 2",
      "mutated_line": "max_convenience += l[i] ** -2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** -2\n    return max_convenience"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [+1] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [+1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [1] * n",
      "mutated_line": "self.rank = [2] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [2] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [1] * n",
      "mutated_line": "self.rank = [0] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [0] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [1] * n",
      "mutated_line": "self.rank = [0] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [0] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.rank = [1] * n",
      "mutated_line": "self.rank = [-1] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [-1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while not self.par[p] < 0:",
      "mutated_line": "while not self.par[p] < 1:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 1:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while not self.par[p] < 0:",
      "mutated_line": "while not self.par[p] < -1:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < -1:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while not self.par[p] < 0:",
      "mutated_line": "while not self.par[p] < 1:",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 1:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "uf.unite(i, p[i] - 1)",
      "mutated_line": "uf.unite(i, p[i] - 2)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 2)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "uf.unite(i, p[i] - 1)",
      "mutated_line": "uf.unite(i, p[i] - 0)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 0)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "uf.unite(i, p[i] - 1)",
      "mutated_line": "uf.unite(i, p[i] - 0)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 0)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "uf.unite(i, p[i] - 1)",
      "mutated_line": "uf.unite(i, p[i] - -1)",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - -1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[1] + l[1]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[1] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[-1] + l[1]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[-1] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[1] + l[1]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[1] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[2]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[2]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[0]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[0]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[0]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[0]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "max_convenience = (l[0] + l[1]) ** 2",
      "mutated_line": "max_convenience = (l[0] + l[-1]) ** 2",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[-1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [-2] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-2] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [-0] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-0] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [-0] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [-0] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "self.par = [-1] * n",
      "mutated_line": "self.par = [--1] * n",
      "code": "class Unionfind:\n\n    def __init__(self, n):\n        self.par = [--1] * n\n        self.rank = [1] * n\n\n    def root(self, x):\n        p = x\n        while not self.par[p] < 0:\n            p = self.par[p]\n        while x != p:\n            tmp = x\n            x = self.par[x]\n            self.par[tmp] = p\n        return p\n\n    def unite(self, x, y):\n        (rx, ry) = (self.root(x), self.root(y))\n        if rx == ry:\n            return False\n        if self.rank[rx] < self.rank[ry]:\n            (rx, ry) = (ry, rx)\n        self.par[rx] += self.par[ry]\n        self.par[ry] = rx\n        if self.rank[rx] == self.rank[ry]:\n            self.rank[rx] += 1\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def count(self, x):\n        return -self.par[self.root(x)]\n\ndef calculate_max_convenience(n, p):\n    uf = Unionfind(n)\n    for i in range(n):\n        uf.unite(i, p[i] - 1)\n    rs = set((uf.root(i) for i in range(n)))\n    l = []\n    for r in rs:\n        l.append(uf.count(r))\n    l.sort(reverse=True)\n    if len(l) == 1:\n        return n * n\n    max_convenience = (l[0] + l[1]) ** 2\n    for i in range(2, len(l)):\n        max_convenience += l[i] ** 2\n    return max_convenience"
    }
  ]
}