{
  "task_id": "taco_2652",
  "entry_point": "assign_prime_tree_weights",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if start is None:",
      "mutated_line": "if start is not None:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is not None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] / (n - 1)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] / (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] + (n - 1)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] + (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] ** (n - 1)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] ** (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 2",
      "mutated_line": "val = 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 3\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 2",
      "mutated_line": "val = 1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 1\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 2",
      "mutated_line": "val = 0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 0\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 2",
      "mutated_line": "val = 1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 1\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "val = 2",
      "mutated_line": "val = -2",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = -2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "parent = -1",
      "mutated_line": "parent = +1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = +1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while False:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) >= 2:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) >= 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) <= 2:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) <= 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) != 2:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) != 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if len(edges) == 1:",
      "mutated_line": "if len(edges) != 1:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) != 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return +1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] * (n + 1)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n + 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] * (n * 1)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n * 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = -1",
      "mutated_line": "parent = -2",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -2\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = -1",
      "mutated_line": "parent = -0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -0\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = -1",
      "mutated_line": "parent = -0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -0\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = -1",
      "mutated_line": "parent = --1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = --1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = True\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) > 3:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 3:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) > 1:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 1:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) > 0:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 0:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) > 1:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 1:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(edges) > 2:",
      "mutated_line": "if len(edges) > -2:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > -2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return +1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(edges) == 1:",
      "mutated_line": "if len(edges) == 2:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 2:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(edges) == 1:",
      "mutated_line": "if len(edges) == 0:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 0:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(edges) == 1:",
      "mutated_line": "if len(edges) == 0:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 0:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if len(edges) == 1:",
      "mutated_line": "if len(edges) == -1:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == -1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -2\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -0\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -0\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return --1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] * (n - 2)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 2)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] * (n - 0)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 0)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] * (n - 0)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 0)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ret = [None] * (n - 1)",
      "mutated_line": "ret = [None] * (n - -1)",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - -1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if q != parent:",
      "mutated_line": "if q == parent:",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q == parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val != 3 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val != 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 3 if val == 3 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 3 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 1 if val == 3 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 1 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 0 if val == 3 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 0 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 1 if val == 3 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 1 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = -2 if val == 3 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = -2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 3 else 4",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 4\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 3 else 2",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 2\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 3 else 0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 0\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 3 else 1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 1\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 3 else -3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else -3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 1].append((v + 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v + 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 1].append((v * 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v * 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 1].append((u + 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u + 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 1].append((u * 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u * 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -2\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -0\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -0\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return --1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = False\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 4 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 4 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 2 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 2 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 0 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 0 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == 1 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 1 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "val = 2 if val == 3 else 3",
      "mutated_line": "val = 2 if val == -3 else 3",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == -3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u + 1].append((v - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u + 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u * 1].append((v - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u * 1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 1].append((v - 2, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 2, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 1].append((v - 0, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 0, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 1].append((v - 0, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 0, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 1].append((v - -1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - -1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v + 1].append((u - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v + 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v * 1].append((u - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v * 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 1].append((u - 2, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 2, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 1].append((u - 0, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 0, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 1].append((u - 0, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - 0, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 1].append((u - -1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 1].append((u - -1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 2].append((v - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 2].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 0].append((v - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 0].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - 0].append((v - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 0].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "T[u - 1].append((v - 1, i))",
      "mutated_line": "T[u - -1].append((v - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - -1].append((v - 1, i))\n        T[v - 1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 2].append((u - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 2].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 0].append((u - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 0].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - 0].append((u - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - 0].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "T[v - 1].append((u - 1, i))",
      "mutated_line": "T[v - -1].append((u - 1, i))",
      "code": "def assign_prime_tree_weights(n, edges):\n    T = [[] for _ in range(n)]\n    for (i, (u, v)) in enumerate(edges):\n        T[u - 1].append((v - 1, i))\n        T[v - -1].append((u - 1, i))\n    start = None\n    for (idx, edges) in enumerate(T):\n        if len(edges) > 2:\n            return -1\n        if len(edges) == 1:\n            start = idx\n    if start is None:\n        return -1\n    ret = [None] * (n - 1)\n    val = 2\n    p = start\n    parent = -1\n    while True:\n        found = False\n        for (q, idx) in T[p]:\n            if q != parent:\n                found = True\n                ret[idx] = val\n                parent = p\n                p = q\n                break\n        val = 2 if val == 3 else 3\n        if not found:\n            break\n    return ret"
    }
  ]
}