{
  "task_id": "taco_1730",
  "entry_point": "calculate_max_flow",
  "mutant_count": 48,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj_mat = [[0] * V for _ in range(V)]",
      "mutated_line": "for (u, v, c) in edges:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] / V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj_mat = [[0] * V for _ in range(V)]",
      "mutated_line": "for (u, v, c) in edges:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] + V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "adj_mat = [[0] * V for _ in range(V)]",
      "mutated_line": "for (u, v, c) in edges:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] ** V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "flow = [0] * V",
      "mutated_line": "flow = [0] / V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] / V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "flow = [0] * V",
      "mutated_line": "flow = [0] + V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] + V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "flow = [0] * V",
      "mutated_line": "flow = [0] ** V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] ** V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flow[start] = 10000",
      "mutated_line": "flow[start] = 10001",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10001\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flow[start] = 10000",
      "mutated_line": "flow[start] = 9999",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 9999\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flow[start] = 10000",
      "mutated_line": "flow[start] = 0",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 0\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flow[start] = 10000",
      "mutated_line": "flow[start] = 1",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 1\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flow[start] = 10000",
      "mutated_line": "flow[start] = -10000",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = -10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 1\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return -1\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 1\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 1\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = -1",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = -1\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "max_flow = 0",
      "mutated_line": "max_flow = 1",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 1\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while False:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(1, V - 1)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(1, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(-1, V - 1)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(-1, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(1, V - 1)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(1, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(0, V + 1)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(0, V * 1)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V * 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "parent = [None] * V",
      "mutated_line": "parent = [None] / V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] / V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "parent = [None] * V",
      "mutated_line": "parent = [None] + V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] + V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "parent = [None] * V",
      "mutated_line": "parent = [None] ** V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] ** V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "max_flow += aug_path_flow",
      "mutated_line": "max_flow -= aug_path_flow",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow -= aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(0, V - 2)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(0, V - 0)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(0, V - 0)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return ford_fulkerson(0, V - 1)",
      "mutated_line": "return ford_fulkerson(0, V - -1)",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - -1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adj_mat = [[0] * V for _ in range(V)]",
      "mutated_line": "for (u, v, c) in edges:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[1] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adj_mat = [[0] * V for _ in range(V)]",
      "mutated_line": "for (u, v, c) in edges:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[-1] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "adj_mat = [[0] * V for _ in range(V)]",
      "mutated_line": "for (u, v, c) in edges:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[1] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "flow = [0] * V",
      "mutated_line": "flow = [1] * V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [1] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "flow = [0] * V",
      "mutated_line": "flow = [-1] * V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [-1] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "flow = [0] * V",
      "mutated_line": "flow = [1] * V",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [1] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if not flow[v] and r_capacity > 0:",
      "mutated_line": "if not flow[v] or r_capacity > 0:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] or r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while v != source:",
      "mutated_line": "while v == source:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v == source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "adj_mat[u][v] -= aug_path_flow",
      "mutated_line": "adj_mat[u][v] += aug_path_flow",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] += aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "adj_mat[v][u] += aug_path_flow",
      "mutated_line": "adj_mat[v][u] -= aug_path_flow",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] -= aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if not flow[v] and r_capacity > 0:",
      "mutated_line": "if not flow[v] and r_capacity >= 0:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity >= 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if not flow[v] and r_capacity > 0:",
      "mutated_line": "if not flow[v] and r_capacity <= 0:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity <= 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if not flow[v] and r_capacity > 0:",
      "mutated_line": "if not flow[v] and r_capacity != 0:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity != 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if v == goal:",
      "mutated_line": "if v != goal:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 0:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v != goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not flow[v] and r_capacity > 0:",
      "mutated_line": "if not flow[v] and r_capacity > 1:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 1:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not flow[v] and r_capacity > 0:",
      "mutated_line": "if not flow[v] and r_capacity > -1:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > -1:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if not flow[v] and r_capacity > 0:",
      "mutated_line": "if not flow[v] and r_capacity > 1:",
      "code": "def calculate_max_flow(V, E, edges):\n    adj_mat = [[0] * V for _ in range(V)]\n    for (u, v, c) in edges:\n        adj_mat[u][v] = c\n\n    def bfs(start, goal, parent):\n        flow = [0] * V\n        queue = collections.deque()\n        queue.append(start)\n        flow[start] = 10000\n        while queue:\n            u = queue.popleft()\n            for (v, r_capacity) in enumerate(adj_mat[u]):\n                if not flow[v] and r_capacity > 1:\n                    queue.append(v)\n                    flow[v] = min(flow[u], r_capacity)\n                    parent[v] = u\n                    if v == goal:\n                        return flow[goal]\n        return 0\n\n    def ford_fulkerson(source, sink):\n        max_flow = 0\n        while True:\n            parent = [None] * V\n            aug_path_flow = bfs(source, sink, parent)\n            if aug_path_flow:\n                max_flow += aug_path_flow\n                v = sink\n                while v != source:\n                    u = parent[v]\n                    adj_mat[u][v] -= aug_path_flow\n                    adj_mat[v][u] += aug_path_flow\n                    v = u\n            else:\n                break\n        return max_flow\n    return ford_fulkerson(0, V - 1)"
    }
  ]
}