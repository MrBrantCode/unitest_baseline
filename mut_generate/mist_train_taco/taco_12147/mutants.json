{
  "task_id": "taco_12147",
  "entry_point": "can_vova_complete_wall",
  "mutant_count": 60,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n != 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if n == 2:",
      "mutated_line": "if n != 2:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n != 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) > 2:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) > 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) < 2:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) < 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) == 2:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) == 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 2:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 0:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 0:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == -1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return ''\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "parity = [height % 2 for height in heights]",
      "mutated_line": "parity = [height * 2 for height in heights]",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height * 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "parity = [height % 2 for height in heights]",
      "mutated_line": "parity = [height + 2 for height in heights]",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height + 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 3:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 3:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 1:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 0:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 0:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n == 2:",
      "mutated_line": "if n == 1:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 1:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if n == 2:",
      "mutated_line": "if n == -2:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == -2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[0] == parity[1]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] == parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 or QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 or QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) >= 3:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 3:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) >= 1:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 1:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) >= 0:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 0:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) >= 1:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 1:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if len(QUE) >= 2:",
      "mutated_line": "if len(QUE) >= -2:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= -2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return ''\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parity = [height % 2 for height in heights]",
      "mutated_line": "parity = [height % 3 for height in heights]",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 3 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parity = [height % 2 for height in heights]",
      "mutated_line": "parity = [height % 1 for height in heights]",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 1 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parity = [height % 2 for height in heights]",
      "mutated_line": "parity = [height % 0 for height in heights]",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 0 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parity = [height % 2 for height in heights]",
      "mutated_line": "parity = [height % 1 for height in heights]",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 1 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "parity = [height % 2 for height in heights]",
      "mutated_line": "parity = [height % -2 for height in heights]",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % -2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 'NO'",
      "mutated_line": "return ''",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return ''\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 'YES'",
      "mutated_line": "return ''",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return ''\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) > 2 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) > 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) < 2 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) < 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) == 2 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) == 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-1] != QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] != QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[1] != parity[1]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[1] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[-1] != parity[1]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[-1] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[1] != parity[1]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[1] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[0] != parity[2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[2]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[0] != parity[0]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[0]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[0] != parity[0]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[0]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if parity[0] != parity[1]:",
      "mutated_line": "if parity[0] != parity[-1]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[-1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 3 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 3 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 1 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 1 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 0 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 0 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 1 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 1 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= -2 and QUE[-1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= -2 and QUE[-1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[+1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[+1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-1] == QUE[+2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[+2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-2] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-2] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-0] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-0] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-0] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-0] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[--1] == QUE[-2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[--1] == QUE[-2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-3]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-3]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-1]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-1]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-0]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-0]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-1]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[-1]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while len(QUE) >= 2 and QUE[-1] == QUE[-2]:",
      "mutated_line": "while len(QUE) >= 2 and QUE[-1] == QUE[--2]:",
      "code": "def can_vova_complete_wall(n, heights):\n    if n == 1:\n        return 'YES'\n    parity = [height % 2 for height in heights]\n    if n == 2:\n        if parity[0] != parity[1]:\n            return 'NO'\n        else:\n            return 'YES'\n    from collections import deque\n    QUE = deque()\n    for p in parity:\n        QUE.append(p)\n        while len(QUE) >= 2 and QUE[-1] == QUE[--2]:\n            QUE.pop()\n            QUE.pop()\n    if len(QUE) >= 2:\n        return 'NO'\n    else:\n        return 'YES'"
    }
  ]
}