{
  "task_id": "taco_13195",
  "entry_point": "calculate_tournament_depth",
  "mutant_count": 35,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(3, N + 1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(3, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(1, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(0, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(1, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(-2, N + 1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(-2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N - 1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N - 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N * 1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N * 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if nxt in dic:",
      "mutated_line": "if nxt not in dic:",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt not in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "lst[i] += i + 1",
      "mutated_line": "lst[i] -= i + 1",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] -= i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return dfs(1)",
      "mutated_line": "return dfs(2)",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(2)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return dfs(1)",
      "mutated_line": "return dfs(0)",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return dfs(1)",
      "mutated_line": "return dfs(0)",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(0)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return dfs(1)",
      "mutated_line": "return dfs(-1)",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(-1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 2):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 2):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 0):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 0):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + -1):",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + -1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ai = a[i - 2]",
      "mutated_line": "ai = a[i + 2]",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i + 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ai = a[i - 2]",
      "mutated_line": "ai = a[i * 2]",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i * 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 1\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return -1\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 1\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lst[i] += i + 1",
      "mutated_line": "lst[i] += i - 1",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i - 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "lst[i] += i + 1",
      "mutated_line": "lst[i] += i * 1",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i * 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ai = a[i - 2]",
      "mutated_line": "ai = a[i - 3]",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 3]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ai = a[i - 2]",
      "mutated_line": "ai = a[i - 1]",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 1]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ai = a[i - 2]",
      "mutated_line": "ai = a[i - 0]",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 0]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ai = a[i - 2]",
      "mutated_line": "ai = a[i - 1]",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 1]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ai = a[i - 2]",
      "mutated_line": "ai = a[i - -2]",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - -2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "lst.sort(reverse=True)",
      "mutated_line": "lst.sort(reverse=False)",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=False)\n        for i in range(len(lst)):\n            lst[i] += i + 1\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst[i] += i + 1",
      "mutated_line": "lst[i] += i + 2",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 2\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst[i] += i + 1",
      "mutated_line": "lst[i] += i + 0",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 0\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst[i] += i + 1",
      "mutated_line": "lst[i] += i + 0",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + 0\n        return max(lst)\n    return dfs(1)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "lst[i] += i + 1",
      "mutated_line": "lst[i] += i + -1",
      "code": "def calculate_tournament_depth(N, a):\n    \"\"\"\n    Calculate the minimum possible depth of the tournament.\n\n    Parameters:\n    - N (int): The number of contestants.\n    - a (list of int): A list where a[i-2] indicates the contestant who defeated contestant i (for i from 2 to N).\n\n    Returns:\n    - int: The minimum possible depth of the tournament.\n    \"\"\"\n    from collections import defaultdict\n    dic = defaultdict(list)\n    for i in range(2, N + 1):\n        ai = a[i - 2]\n        dic[ai].append(i)\n\n    def dfs(nxt):\n        lst = []\n        if nxt in dic:\n            while dic[nxt]:\n                child = dic[nxt].pop()\n                tempmax = dfs(child)\n                lst.append(tempmax)\n        else:\n            return 0\n        lst.sort(reverse=True)\n        for i in range(len(lst)):\n            lst[i] += i + -1\n        return max(lst)\n    return dfs(1)"
    }
  ]
}