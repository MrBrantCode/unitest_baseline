{
  "task_id": "taco_11809",
  "entry_point": "calculate_max_loot",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 != 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 != 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n * 2 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n * 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n + 2 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n + 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 1:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == -1:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == -1:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 2 == 1:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 1:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 1\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return -1\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 1\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m <= math.ceil(n / 2):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m <= math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m >= math.ceil(n / 2):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m >= math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m != math.ceil(n / 2):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m != math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 3 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 3 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 1 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 0 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 0 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % 1 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 1 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n % 2 == 0:",
      "mutated_line": "if n % -2 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % -2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 1\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return -1\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 1\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m / math.ceil(n / 2)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m / math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m * math.ceil(n / 2)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m * math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = per_min * k",
      "mutated_line": "ans = per_min / k",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min / k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = per_min * k",
      "mutated_line": "ans = per_min + k",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min + k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ans = per_min * k",
      "mutated_line": "ans = per_min ** k",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min ** k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m < math.ceil(n * 2):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n * 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m < math.ceil(n // 2):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n // 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "max_loot = float('inf')",
      "mutated_line": "max_loot = float('')",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 != 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 != 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m < math.ceil(n / 3):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 3):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m < math.ceil(n / 1):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 1):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m < math.ceil(n / 0):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 0):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m < math.ceil(n / 1):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 1):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "elif m < math.ceil(n / 2):",
      "mutated_line": "elif m < math.ceil(n / -2):",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / -2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i * 2 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i * 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i + 2 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i + 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == 1:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 1:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == -1:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == -1:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 2 == 1:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 1:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m // math.ceil(n * 2)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n * 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m // math.ceil(n // 2)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n // 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 3 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 3 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 1 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 1 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 0 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 0 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % 1 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 1 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if i % 2 == 0:",
      "mutated_line": "if i % -2 == 0:",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % -2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m // math.ceil(n / 3)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 3)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m // math.ceil(n / 1)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 1)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m // math.ceil(n / 0)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 0)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m // math.ceil(n / 1)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / 1)\n        ans = per_min * k\n        return min(ans, max_loot)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "per_min = m // math.ceil(n / 2)",
      "mutated_line": "per_min = m // math.ceil(n / -2)",
      "code": "import math\n\ndef calculate_max_loot(n, m, k, diamonds):\n    if n % 2 == 0:\n        return 0\n    elif m < math.ceil(n / 2):\n        return 0\n    else:\n        max_loot = float('inf')\n        for i in range(n):\n            if i % 2 == 0:\n                max_loot = min(max_loot, diamonds[i])\n        per_min = m // math.ceil(n / -2)\n        ans = per_min * k\n        return min(ans, max_loot)"
    }
  ]
}