{
  "task_id": "taco_5569",
  "entry_point": "minimize_tower_instability",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if len(set(heights)) == 1:",
      "mutated_line": "return (0, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) != 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while k > 0:",
      "mutated_line": "while k >= 0:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k >= 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while k > 0:",
      "mutated_line": "while k <= 0:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k <= 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "while k > 0:",
      "mutated_line": "while k != 0:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k != 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "k -= 1",
      "mutated_line": "k += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k += 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][0] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] -= 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][0] += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] += 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "min_instability = max(final_heights) - min(final_heights)",
      "mutated_line": "return (min_instability, len(operations), operations)",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) + min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "min_instability = max(final_heights) - min(final_heights)",
      "mutated_line": "return (min_instability, len(operations), operations)",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) * min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(set(heights)) == 1:",
      "mutated_line": "return (0, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 2:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(set(heights)) == 1:",
      "mutated_line": "return (0, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 0:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(set(heights)) == 1:",
      "mutated_line": "return (0, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 0:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if len(set(heights)) == 1:",
      "mutated_line": "return (0, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == -1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 1:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while k > 0:",
      "mutated_line": "while k > -1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > -1:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while k > 0:",
      "mutated_line": "while k > 1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 1:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k -= 1",
      "mutated_line": "k -= 2",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 2\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 0\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k -= 1",
      "mutated_line": "k -= 0",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 0\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "k -= 1",
      "mutated_line": "k -= -1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= -1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][0] += 2",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 2\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][0] += 0",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 0\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][0] += 0",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 0\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][0] += -1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += -1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][0] -= 2",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 2\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][0] -= 0",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 0\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][0] -= 0",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 0\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][0] -= -1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= -1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][0] for i in range(n)))) != 1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) != 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "towers = [[heights[i], i + 1] for i in range(n)]",
      "mutated_line": "towers = [[heights[i], i - 1] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i - 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "towers = [[heights[i], i + 1] for i in range(n)]",
      "mutated_line": "towers = [[heights[i], i * 1] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i * 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0, 0, []",
      "mutated_line": "return (1, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (1, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0, 0, []",
      "mutated_line": "return (-1, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (-1, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0, 0, []",
      "mutated_line": "return (1, 0, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (1, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0, 0, []",
      "mutated_line": "return (0, 1, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 1, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0, 0, []",
      "mutated_line": "return (0, -1, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, -1, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 0, 0, []",
      "mutated_line": "return (0, 1, [])",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 1, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][1] += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][1] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][-1] += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][-1] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[0][1] += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][1] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][1] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][1] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][-1] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][-1] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-1][1] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][1] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][0] for i in range(n)))) == 2:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 2:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][0] for i in range(n)))) == 0:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 0:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][0] for i in range(n)))) == 0:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 0:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][0] for i in range(n)))) == -1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == -1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "final_heights = [towers[i][0] for i in range(n)]",
      "mutated_line": "final_heights = [towers[i][1] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][1] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "final_heights = [towers[i][0] for i in range(n)]",
      "mutated_line": "final_heights = [towers[i][-1] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][-1] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "final_heights = [towers[i][0] for i in range(n)]",
      "mutated_line": "final_heights = [towers[i][1] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][1] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "towers = [[heights[i], i + 1] for i in range(n)]",
      "mutated_line": "towers = [[heights[i], i + 2] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 2] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "towers = [[heights[i], i + 1] for i in range(n)]",
      "mutated_line": "towers = [[heights[i], i + 0] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 0] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "towers = [[heights[i], i + 1] for i in range(n)]",
      "mutated_line": "towers = [[heights[i], i + 0] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 0] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "towers = [[heights[i], i + 1] for i in range(n)]",
      "mutated_line": "towers = [[heights[i], i + -1] for i in range(n)]",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + -1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[1][0] += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[1][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[-1][0] += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[-1][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "towers[0][0] += 1",
      "mutated_line": "towers[1][0] += 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[1][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[+1][0] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[+1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-2][0] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-2][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-0][0] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-0][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[-0][0] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-0][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "towers[-1][0] -= 1",
      "mutated_line": "towers[--1][0] -= 1",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[--1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][2], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][2], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][0], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][0], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][0], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][0], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][-1], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][-1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][1], towers[0][2]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][2]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][1], towers[0][0]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][0]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][1], towers[0][0]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][0]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][1], towers[0][-1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][-1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[+1][1], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[+1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][1], towers[1][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[1][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][1], towers[-1][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[-1][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-1][1], towers[1][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[1][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-2][1], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-2][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-0][1], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-0][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[-0][1], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-0][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "operations.append((towers[-1][1], towers[0][1]))",
      "mutated_line": "operations.append((towers[--1][1], towers[0][1]))",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[--1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][0] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][1] for i in range(n)))) == 1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][1] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][-1] for i in range(n)))) == 1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][-1] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if len(set((towers[i][0] for i in range(n)))) == 1:",
      "mutated_line": "if len(set((towers[i][1] for i in range(n)))) == 1:",
      "code": "def minimize_tower_instability(n, k, heights):\n    towers = [[heights[i], i + 1] for i in range(n)]\n    towers.sort()\n    operations = []\n    k1 = k\n    if len(set(heights)) == 1:\n        return (0, 0, [])\n    while k > 0:\n        k -= 1\n        towers[0][0] += 1\n        towers[-1][0] -= 1\n        operations.append((towers[-1][1], towers[0][1]))\n        towers.sort()\n        if len(set((towers[i][1] for i in range(n)))) == 1:\n            break\n    final_heights = [towers[i][0] for i in range(n)]\n    min_instability = max(final_heights) - min(final_heights)\n    return (min_instability, len(operations), operations)"
    }
  ]
}