{
  "task_id": "taco_13857",
  "entry_point": "find_lexicographically_smallest_permutation",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] / (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] / (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] + (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] + (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] ** (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] ** (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prev = 0",
      "mutated_line": "prev = 1",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 1\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prev = 0",
      "mutated_line": "prev = -1",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = -1\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prev = 0",
      "mutated_line": "prev = 1",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 1\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "prev += len(z[i])",
      "mutated_line": "prev -= len(z[i])",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev -= len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] / (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] / (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] + (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] + (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] ** (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] ** (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] * (N - 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N - 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] * (N * 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N * 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x] = 1",
      "mutated_line": "visited[x] = 2",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 2\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x] = 1",
      "mutated_line": "visited[x] = 0",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 0\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x] = 1",
      "mutated_line": "visited[x] = 0",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 0\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[x] = 1",
      "mutated_line": "visited[x] = -1",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = -1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(2, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(0, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(0, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(-1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N - 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N * 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if prev + len(z[i]) > i:",
      "mutated_line": "if prev + len(z[i]) >= i:",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) >= i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if prev + len(z[i]) > i:",
      "mutated_line": "if prev + len(z[i]) <= i:",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) <= i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if prev + len(z[i]) > i:",
      "mutated_line": "if prev + len(z[i]) != i:",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) != i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(2, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(0, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(0, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(-1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N - 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N * 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] * (N - 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N - 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] * (N * 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N * 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 1, -1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 1, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, -1, -1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, -1, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 1, -1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 1, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, +1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, +1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "ans[i] = -heappop(heap)",
      "mutated_line": "ans[i] = +heappop(heap)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = +heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [1] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [1] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [-1] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [-1] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [1] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [1] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] * (N + 2)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 2)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 0)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 0)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited = [0] * (N + 1)",
      "mutated_line": "visited = [0] * (N + -1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + -1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 2):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 0):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 0):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + -1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if prev + len(z[i]) > i:",
      "mutated_line": "if prev - len(z[i]) > i:",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev - len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if prev + len(z[i]) > i:",
      "mutated_line": "if prev * len(z[i]) > i:",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev * len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 2):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 0):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 0):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + -1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [1] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [1] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [-1] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [-1] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [1] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [1] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] * (N + 2)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 2)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 0)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 0)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = [0] * (N + 1)",
      "mutated_line": "ans = [0] * (N + -1)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + -1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -2):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -2):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -0):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -0):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, -0):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -0):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(N, 0, -1):",
      "mutated_line": "for i in range(N, 0, --1):",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, --1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ans[1:]",
      "mutated_line": "return ans[2:]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[2:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ans[1:]",
      "mutated_line": "return ans[0:]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ans[1:]",
      "mutated_line": "return ans[0:]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[0:]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return ans[1:]",
      "mutated_line": "return ans[-1:]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[-1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "z = [[] for _ in range(N + 1)]",
      "mutated_line": "z = [[] for _ in range(N - 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N - 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "z = [[] for _ in range(N + 1)]",
      "mutated_line": "z = [[] for _ in range(N * 1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N * 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return [-1]",
      "mutated_line": "return [+1]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [+1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "heappush(heap, -z[i].pop())",
      "mutated_line": "heappush(heap, +z[i].pop())",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, +z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "z = [[] for _ in range(N + 1)]",
      "mutated_line": "z = [[] for _ in range(N + 2)]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 2)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "z = [[] for _ in range(N + 1)]",
      "mutated_line": "z = [[] for _ in range(N + 0)]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 0)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "z = [[] for _ in range(N + 1)]",
      "mutated_line": "z = [[] for _ in range(N + 0)]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 0)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "z = [[] for _ in range(N + 1)]",
      "mutated_line": "z = [[] for _ in range(N + -1)]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + -1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [-1]",
      "mutated_line": "return [-2]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-2]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [-1]",
      "mutated_line": "return [-0]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-0]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [-1]",
      "mutated_line": "return [-0]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-0]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return [-1]",
      "mutated_line": "return [--1]",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [--1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "z[-1].append(i)",
      "mutated_line": "z[+1].append(i)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[+1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "z[-1].append(i)",
      "mutated_line": "z[-2].append(i)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-2].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "z[-1].append(i)",
      "mutated_line": "z[-0].append(i)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-0].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "z[-1].append(i)",
      "mutated_line": "z[-0].append(i)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[-0].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "z[-1].append(i)",
      "mutated_line": "z[--1].append(i)",
      "code": "from heapq import heappush, heappop\n\ndef find_lexicographically_smallest_permutation(N, M, conditions):\n    z = [[] for _ in range(N + 1)]\n    visited = [0] * (N + 1)\n    for (x, y) in conditions:\n        z[y].append(x)\n        visited[x] = 1\n    prev = 0\n    for i in range(1, N + 1):\n        if prev + len(z[i]) > i:\n            return [-1]\n        prev += len(z[i])\n    for i in range(1, N + 1):\n        if not visited[i]:\n            z[--1].append(i)\n    ans = [0] * (N + 1)\n    heap = []\n    for i in range(N, 0, -1):\n        while z[i]:\n            heappush(heap, -z[i].pop())\n        ans[i] = -heappop(heap)\n    return ans[1:]"
    }
  ]
}