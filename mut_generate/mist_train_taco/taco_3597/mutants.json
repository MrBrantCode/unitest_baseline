{
  "task_id": "taco_3597",
  "entry_point": "maximize_truck_values",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n / [-1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n / [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n + [-1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n + [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n ** [-1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n ** [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "best_res = 0",
      "mutated_line": "best_res = 1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 1\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "best_res = 0",
      "mutated_line": "best_res = -1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = -1\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "best_res = 0",
      "mutated_line": "best_res = 1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 1\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "best_last = -1",
      "mutated_line": "best_last = +1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = +1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ii = 0",
      "mutated_line": "ii = 1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 1\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ii = 0",
      "mutated_line": "ii = -1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = -1\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "ii = 0",
      "mutated_line": "ii = 1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 1\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while ii < n:",
      "mutated_line": "while ii <= n:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii <= n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while ii < n:",
      "mutated_line": "while ii >= n:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii >= n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while ii < n:",
      "mutated_line": "while ii != n:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii != n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while best_last != -1:",
      "mutated_line": "while best_last == -1:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last == -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "ans[i] += 1",
      "mutated_line": "ans[i] -= 1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] -= 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_last = -1",
      "mutated_line": "best_last = -2",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -2\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_last = -1",
      "mutated_line": "best_last = -0",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -0\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_last = -1",
      "mutated_line": "best_last = -0",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -0\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "best_last = -1",
      "mutated_line": "best_last = --1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = --1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while jj < n:",
      "mutated_line": "while jj <= n:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj <= n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while jj < n:",
      "mutated_line": "while jj >= n:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj >= n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while jj < n:",
      "mutated_line": "while jj != n:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj != n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "jj += 1",
      "mutated_line": "jj -= 1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj -= 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "while best_last != -1:",
      "mutated_line": "while best_last != +1:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != +1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans[i] += 1",
      "mutated_line": "ans[i] += 2",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 2\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans[i] += 1",
      "mutated_line": "ans[i] += 0",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 0\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans[i] += 1",
      "mutated_line": "ans[i] += 0",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 0\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ans[i] += 1",
      "mutated_line": "ans[i] += -1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += -1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [truck[0] for truck in trucks]",
      "mutated_line": "v = [truck[1] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[1] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [truck[0] for truck in trucks]",
      "mutated_line": "v = [truck[-1] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[-1] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "v = [truck[0] for truck in trucks]",
      "mutated_line": "v = [truck[1] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[1] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "c = [truck[1] for truck in trucks]",
      "mutated_line": "c = [truck[2] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[2] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "c = [truck[1] for truck in trucks]",
      "mutated_line": "c = [truck[0] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[0] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "c = [truck[1] for truck in trucks]",
      "mutated_line": "c = [truck[0] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[0] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "c = [truck[1] for truck in trucks]",
      "mutated_line": "c = [truck[-1] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[-1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = [truck[2] for truck in trucks]",
      "mutated_line": "L = [truck[3] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[3] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = [truck[2] for truck in trucks]",
      "mutated_line": "L = [truck[1] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[1] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = [truck[2] for truck in trucks]",
      "mutated_line": "L = [truck[0] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[0] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = [truck[2] for truck in trucks]",
      "mutated_line": "L = [truck[1] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[1] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "L = [truck[2] for truck in trucks]",
      "mutated_line": "L = [truck[-2] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[-2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "R = [truck[3] for truck in trucks]",
      "mutated_line": "R = [truck[4] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[4] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "R = [truck[3] for truck in trucks]",
      "mutated_line": "R = [truck[2] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[2] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "R = [truck[3] for truck in trucks]",
      "mutated_line": "R = [truck[0] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[0] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "R = [truck[3] for truck in trucks]",
      "mutated_line": "R = [truck[1] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[1] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "R = [truck[3] for truck in trucks]",
      "mutated_line": "R = [truck[-3] for truck in trucks]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[-3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n * [+1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [+1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {1: (0, -1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {1: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {-1: (0, -1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {-1: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {1: (0, -1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {1: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] + L[i] + R[i] == c[j] + L[j] + R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] == c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if x is not None:",
      "mutated_line": "if x is None:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "jj += 1",
      "mutated_line": "jj += 2",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 2\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "jj += 1",
      "mutated_line": "jj += 0",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 0\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "jj += 1",
      "mutated_line": "jj += 0",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 0\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "jj += 1",
      "mutated_line": "jj += -1",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += -1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while best_last != -1:",
      "mutated_line": "while best_last != -2:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -2:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while best_last != -1:",
      "mutated_line": "while best_last != -0:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -0:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while best_last != -1:",
      "mutated_line": "while best_last != -0:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -0:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while best_last != -1:",
      "mutated_line": "while best_last != --1:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != --1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n * [-2]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-2]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n * [-0]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-0]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n * [-0]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-0]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prev = n * [-1]",
      "mutated_line": "prev = n * [--1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [--1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (1, -1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (1, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (-1, -1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (-1, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (1, -1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (1, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (0, +1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, +1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] + L[i] - R[i] != c[j] + L[j] + R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] - R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if (c[i] + L[i]) * R[i] != c[j] + L[j] + R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if (c[i] + L[i]) * R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] + L[i] + R[i] != c[j] + L[j] - R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] - R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] + L[i] + R[i] != (c[j] + L[j]) * R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != (c[j] + L[j]) * R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cur = v[j] + x[0]",
      "mutated_line": "cur = v[j] - x[0]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] - x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "cur = v[j] + x[0]",
      "mutated_line": "cur = v[j] * x[0]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] * x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] == 0 or cur > best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 or cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is None and cur > y[0]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None and cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "index.sort(key=lambda i: (c[i] + L[i] + R[i], i))",
      "mutated_line": "index.sort(key=lambda i: (c[i] + L[i] - R[i], i))",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] - R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "index.sort(key=lambda i: (c[i] + L[i] + R[i], i))",
      "mutated_line": "index.sort(key=lambda i: ((c[i] + L[i]) * R[i], i))",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: ((c[i] + L[i]) * R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (0, -2)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -2)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (0, -0)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -0)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (0, -0)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -0)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = {0: (0, -1)}",
      "mutated_line": "d = {0: (0, --1)}",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, --1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] - L[i] + R[i] != c[j] + L[j] + R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] - L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] * L[i] + R[i] != c[j] + L[j] + R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] * L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] + L[i] + R[i] != c[j] - L[j] + R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] - L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:",
      "mutated_line": "if c[i] + L[i] + R[i] != c[j] * L[j] + R[j]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] * L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev[j] = x[1]",
      "mutated_line": "prev[j] = x[2]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[2]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev[j] = x[1]",
      "mutated_line": "prev[j] = x[0]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[0]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev[j] = x[1]",
      "mutated_line": "prev[j] = x[0]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[0]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "prev[j] = x[1]",
      "mutated_line": "prev[j] = x[-1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[-1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] != 0 and cur > best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] != 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] == 0 and cur >= best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur >= best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] == 0 and cur <= best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur <= best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] == 0 and cur != best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur != best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "y = d.get(L[j] + c[j])",
      "mutated_line": "y = d.get(L[j] - c[j])",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] - c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "y = d.get(L[j] + c[j])",
      "mutated_line": "y = d.get(L[j] * c[j])",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] * c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is not None or cur > y[0]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is not None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is None or cur >= y[0]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur >= y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is None or cur <= y[0]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur <= y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is None or cur != y[0]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur != y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "index.sort(key=lambda i: (c[i] + L[i] + R[i], i))",
      "mutated_line": "index.sort(key=lambda i: (c[i] - L[i] + R[i], i))",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] - L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "index.sort(key=lambda i: (c[i] + L[i] + R[i], i))",
      "mutated_line": "index.sort(key=lambda i: (c[i] * L[i] + R[i], i))",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] * L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cur = v[j] + x[0]",
      "mutated_line": "cur = v[j] + x[1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[1]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cur = v[j] + x[0]",
      "mutated_line": "cur = v[j] + x[-1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[-1]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cur = v[j] + x[0]",
      "mutated_line": "cur = v[j] + x[1]",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[1]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] == 1 and cur > best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 1 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] == -1 and cur > best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == -1 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if R[j] == 0 and cur > best_res:",
      "mutated_line": "if R[j] == 1 and cur > best_res:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 1 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d[L[j] + c[j]] = (cur, j)",
      "mutated_line": "d[L[j] - c[j]] = (cur, j)",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] - c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "d[L[j] + c[j]] = (cur, j)",
      "mutated_line": "d[L[j] * c[j]] = (cur, j)",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[0]:\n                    d[L[j] * c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is None or cur > y[1]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[1]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is None or cur > y[-1]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[-1]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if y is None or cur > y[0]:",
      "mutated_line": "if y is None or cur > y[1]:",
      "code": "def maximize_truck_values(n, trucks):\n    v = [truck[0] for truck in trucks]\n    c = [truck[1] for truck in trucks]\n    L = [truck[2] for truck in trucks]\n    R = [truck[3] for truck in trucks]\n    index = [i for i in range(n)]\n    index.sort(key=lambda i: (c[i] + L[i] + R[i], i))\n    prev = n * [-1]\n    best_res = 0\n    best_last = -1\n    ii = 0\n    while ii < n:\n        i = index[ii]\n        jj = ii\n        d = {0: (0, -1)}\n        while jj < n:\n            j = index[jj]\n            if c[i] + L[i] + R[i] != c[j] + L[j] + R[j]:\n                break\n            x = d.get(L[j])\n            if x is not None:\n                cur = v[j] + x[0]\n                prev[j] = x[1]\n                if R[j] == 0 and cur > best_res:\n                    best_res = cur\n                    best_last = j\n                y = d.get(L[j] + c[j])\n                if y is None or cur > y[1]:\n                    d[L[j] + c[j]] = (cur, j)\n            jj += 1\n        ii = jj\n    ans = []\n    while best_last != -1:\n        ans.append(best_last)\n        best_last = prev[best_last]\n    ans.reverse()\n    for i in range(len(ans)):\n        ans[i] += 1\n    k = len(ans)\n    return (k, ans)"
    }
  ]
}