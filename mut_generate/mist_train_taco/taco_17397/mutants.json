{
  "task_id": "taco_17397",
  "entry_point": "prime_maxlength_chain",
  "mutant_count": 183,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "LIMIT = 500000",
      "mutated_line": "LIMIT = 500001",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500001\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "LIMIT = 500000",
      "mutated_line": "LIMIT = 499999",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 499999\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "LIMIT = 500000",
      "mutated_line": "LIMIT = 0",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 0\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "LIMIT = 500000",
      "mutated_line": "LIMIT = 1",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 1\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "LIMIT = 500000",
      "mutated_line": "LIMIT = -500000",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = -500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] / (LIMIT // 2)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] / (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] + LIMIT // 2",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] + LIMIT // 2\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] ** (LIMIT // 2)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] ** (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] - [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] - [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] * [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] * [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max <= 5:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max <= 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max >= 5:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max >= 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max != 5:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max != 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] * (LIMIT / 2)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT / 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] * (LIMIT * 2)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT * 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(4, int(LIMIT ** 0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(4, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(2, int(LIMIT ** 0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(2, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(0, int(LIMIT ** 0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(0, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(1, int(LIMIT ** 0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(1, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(-3, int(LIMIT ** 0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(-3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) - 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) - 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) * 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) * 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 3):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 3):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 1):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 0):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 0):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 1):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 1, -2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, -2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max < 6:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 6:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max < 4:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 4:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max < 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 0:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max < 1:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 1:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if val_max < 5:",
      "mutated_line": "if val_max < -5:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < -5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(3, 400):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(3, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(1, 400):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(1, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(0, 400):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(0, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(1, 400):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(1, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(-2, 400):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(-2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(2, 401):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 401):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(2, 399):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 399):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(2, 0):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 0):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(2, 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 1):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(2, 400):",
      "mutated_line": "for n in range(2, -400):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, -400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if sum(PRIMES[:n]) >= val_max:",
      "mutated_line": "if sum(PRIMES[:n]) > val_max:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) > val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if sum(PRIMES[:n]) >= val_max:",
      "mutated_line": "if sum(PRIMES[:n]) < val_max:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) < val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if sum(PRIMES[:n]) >= val_max:",
      "mutated_line": "if sum(PRIMES[:n]) == val_max:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) == val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 2, -1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 2, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 0, -1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 0, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 0, -1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 0, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, -1, -1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, -1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 1, +1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, +1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 2 != 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 != 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [False] * (LIMIT // 2)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [False] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] * (LIMIT // 3)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 3)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] * (LIMIT // 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 1)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] * (LIMIT // 0)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 0)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] * (LIMIT // 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 1)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sieve = [True] * (LIMIT // 2)",
      "mutated_line": "sieve = [True] * (LIMIT // -2)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // -2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 2, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 2, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 0, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 0, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + 0, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 0, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0.5) + -1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + -1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if sieve[n // 2]:",
      "mutated_line": "if sieve[n / 2]:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n / 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if sieve[n // 2]:",
      "mutated_line": "if sieve[n * 2]:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n * 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] / ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] / ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] + ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] + ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] ** ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] ** ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [3] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [3] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [1] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [1] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [0] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [0] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [1] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [1] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [-2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [-2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i - 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i - 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i * 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i * 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 1, -2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -2):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 1, -0):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -0):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 1, -0):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -0):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for size in range(max_size, 1, -1):",
      "mutated_line": "for size in range(max_size, 1, --1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, --1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size * 2 == 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size * 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size + 2 == 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size + 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 2 == 1:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 1:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 2 == -1:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == -1:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 2 == 1:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 1:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n < val_max or n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max or n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT * 0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT * 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT + 0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT + 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sieve[n // 2]:",
      "mutated_line": "if sieve[n // 3]:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 3]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sieve[n // 2]:",
      "mutated_line": "if sieve[n // 1]:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 1]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sieve[n // 2]:",
      "mutated_line": "if sieve[n // 0]:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 0]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sieve[n // 2]:",
      "mutated_line": "if sieve[n // 1]:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 1]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if sieve[n // 2]:",
      "mutated_line": "if sieve[n // -2]:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // -2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n - 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n - 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n * 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n * 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 / i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 / i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 + i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 + i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 ** i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 ** i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 2 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 2 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 0 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 0 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 0 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 0 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + -1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + -1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 3 == 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 3 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 1 == 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 1 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 0 == 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 0 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % 1 == 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 1 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if size % 2 == 0:",
      "mutated_line": "if size % -2 == 0:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % -2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n <= val_max and n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n <= val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n >= val_max and n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n >= val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n != val_max and n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n != val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n < val_max and n not in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n not in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(2, max_size - size + 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(2, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(0, max_size - size + 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(0, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(0, max_size - size + 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(0, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(-1, max_size - size + 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(-1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, max_size - size - 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size - 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, (max_size - size) * 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, (max_size - size) * 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n < val_max or n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max or n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 1.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 1.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** -0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** -0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 0) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** 1) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 1) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for n in range(3, int(LIMIT ** 0.5) + 1, 2):",
      "mutated_line": "for n in range(3, int(LIMIT ** -0.5) + 1, 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** -0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n / 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n / 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n * 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n * 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [True] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [True] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 / n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 / n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 * n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 * n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 2)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 2)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 0)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 0)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 0)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 0)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + -1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + -1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [3 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [3 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [1 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [1 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [0 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [0 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [1 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [1 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [-2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [-2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(2, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(2, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(0, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(0, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(0, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(0, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(-1, LIMIT // 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(-1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT / 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT / 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT * 2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT * 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, max_size + size + 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size + size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, max_size * size + 1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size * size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, max_size - size + 2):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 2):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, max_size - size + 0):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 0):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, max_size - size + 0):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 0):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for start in range(1, max_size - size + 1):",
      "mutated_line": "for start in range(1, max_size - size + -1):",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + -1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n <= val_max and n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n <= val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n >= val_max and n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n >= val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n != val_max and n in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n != val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if n < val_max and n in PRIMES:",
      "mutated_line": "if n < val_max and n not in PRIMES:",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n not in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n / n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n / n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[(n + n) // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[(n + n) // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n ** n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n ** n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 3::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 3::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 1::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 1::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 0::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 0::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 1::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 1::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // -2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // -2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) / 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) / 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) * 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) * 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 3) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 3) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 1) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 1) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 0) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 0) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 1) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 1) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]",
      "mutated_line": "PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // -2) if sieve[i]]",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // -2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n + 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n + 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n) * 1 // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n) * 1 // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 3 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 3 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 1 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 1 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 0 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 0 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 1 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 1 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // -2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // -2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "n = sum(PRIMES[start:start + size])",
      "mutated_line": "n = sum(PRIMES[start:start - size])",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start - size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "n = sum(PRIMES[start:start + size])",
      "mutated_line": "n = sum(PRIMES[start:start * size])",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start * size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT + n * n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT + n * n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT * (n * n) - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT * (n * n) - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 2) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 2) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 0) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 0) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 0) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 0) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - -1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - -1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n / n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n / n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - (n + n) - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - (n + n) - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n * n - 1) // 2 // n + 1)",
      "mutated_line": "sieve[n * n // 2::n] = [False] * ((LIMIT - n ** n - 1) // 2 // n + 1)",
      "code": "def prime_maxlength_chain(val_max):\n    LIMIT = 500000\n    sieve = [True] * (LIMIT // 2)\n    for n in range(3, int(LIMIT ** 0.5) + 1, 2):\n        if sieve[n // 2]:\n            sieve[n * n // 2::n] = [False] * ((LIMIT - n ** n - 1) // 2 // n + 1)\n    PRIMES = [2] + [2 * i + 1 for i in range(1, LIMIT // 2) if sieve[i]]\n    if val_max < 5:\n        return []\n    found = []\n    for n in range(2, 400):\n        if sum(PRIMES[:n]) >= val_max:\n            max_size = n\n            break\n    for size in range(max_size, 1, -1):\n        if size % 2 == 0:\n            n = sum(PRIMES[:size])\n            if n < val_max and n in PRIMES:\n                return [n]\n        else:\n            for start in range(1, max_size - size + 1):\n                n = sum(PRIMES[start:start + size])\n                if n < val_max and n in PRIMES:\n                    found.append(n)\n            if found:\n                return sorted(found)\n    return []"
    }
  ]
}