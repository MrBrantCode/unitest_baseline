{
  "task_id": "taco_16007",
  "entry_point": "calculate_minimum_sealing_cost",
  "mutant_count": 141,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 10 * 18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 * 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 10 + 18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 + 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 11 ** 18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 11 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 9 ** 18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 9 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 0 ** 18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 0 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 1 ** 18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 1 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = -10 ** 18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = -10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 10 ** 19",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 19\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 10 ** 17",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 17\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 10 ** 0",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 0\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 10 ** 1",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 1\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "intMax = 10 ** 18",
      "mutated_line": "intMax = 10 ** -18",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** -18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 0 or rl > 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 or rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if rl <= 0:",
      "mutated_line": "if rl < 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl < 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if rl <= 0:",
      "mutated_line": "if rl > 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl > 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if rl <= 0:",
      "mutated_line": "if rl == 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl == 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 1\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = -1\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 1\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "ans += knapsack(k, length, cost, m)",
      "mutated_line": "ans -= knapsack(k, length, cost, m)",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans -= knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m != 0 and rl > 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m != 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 0 and rl >= 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl >= 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 0 and rl <= 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl <= 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 0 and rl != 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl != 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if rl <= 0:",
      "mutated_line": "if rl <= 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 1:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if rl <= 0:",
      "mutated_line": "if rl <= -1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= -1:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if rl <= 0:",
      "mutated_line": "if rl <= 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 1:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 1\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return -1\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 1\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] - knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] - knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] * knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] * knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i != 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 1 and rl > 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 1 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == -1 and rl > 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == -1 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 1 and rl > 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 1 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 0 and rl > 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 1:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 0 and rl > -1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > -1:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if m == 0 and rl > 0:",
      "mutated_line": "if m == 0 and rl > 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 1:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m + 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m + 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m * 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m * 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "n = len(case['vertices'])",
      "mutated_line": "n = len(case[''])",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case[''])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 1:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == -1:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 1:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "elif i == n - 1:",
      "mutated_line": "elif i != n - 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i != n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "length = [stripe[0] for stripe in case['stripes']]",
      "mutated_line": "length = [stripe[1] for stripe in case['stripes']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[1] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "length = [stripe[0] for stripe in case['stripes']]",
      "mutated_line": "length = [stripe[-1] for stripe in case['stripes']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[-1] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "length = [stripe[0] for stripe in case['stripes']]",
      "mutated_line": "length = [stripe[1] for stripe in case['stripes']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[1] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = [stripe[1] for stripe in case['stripes']]",
      "mutated_line": "cost = [stripe[2] for stripe in case['stripes']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[2] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = [stripe[1] for stripe in case['stripes']]",
      "mutated_line": "cost = [stripe[0] for stripe in case['stripes']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[0] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = [stripe[1] for stripe in case['stripes']]",
      "mutated_line": "cost = [stripe[0] for stripe in case['stripes']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[0] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = [stripe[1] for stripe in case['stripes']]",
      "mutated_line": "cost = [stripe[-1] for stripe in case['stripes']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[-1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "m = len(case['stripes'])",
      "mutated_line": "m = len(case[''])",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case[''])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m + 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m + 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m * 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m * 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl + l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl + l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl * l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl * l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 2))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 0))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 0))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 0))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 0))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - -1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - -1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x, y = case['vertices'][i]",
      "mutated_line": "(x, y) = case[''][i]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case[''][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "elif i == n - 1:",
      "mutated_line": "elif i == n + 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n + 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "elif i == n - 1:",
      "mutated_line": "elif i == n * 1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n * 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "length = [stripe[0] for stripe in case['stripes']]",
      "mutated_line": "length = [stripe[0] for stripe in case['']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost = [stripe[1] for stripe in case['stripes']]",
      "mutated_line": "cost = [stripe[1] for stripe in case['']]",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 2] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 2] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 0] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 0] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 0] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 0] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - -1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - -1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif i == n - 1:",
      "mutated_line": "elif i == n - 2:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 2:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif i == n - 1:",
      "mutated_line": "elif i == n - 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 0:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif i == n - 1:",
      "mutated_line": "elif i == n - 0:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 0:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "elif i == n - 1:",
      "mutated_line": "elif i == n - -1:",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - -1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m + 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m + 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m * 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m * 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 - (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 - (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 * (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 * (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 - (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 - (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 * (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 * (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 - (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 - (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 * (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 * (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 2], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 2], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 0], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 0], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - 0], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 0], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))",
      "mutated_line": "return min(c[m - 1] + knapsack(rl - l[m - -1], l, c, m), knapsack(rl, l, c, m - 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - -1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) * 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) * 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt(prevx - x + 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt(prevx - x + 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) * 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) * 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y + 2)))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y + 2)))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) * 2 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) * 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt(x0 - x + 2 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt(x0 - x + 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) * 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) * 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y + 2)))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y + 2)))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) * 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) * 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt(prevx - x + 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt(prevx - x + 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) * 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) * 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y + 2)))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y + 2)))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx + x) ** 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx + x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx * x) ** 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx * x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 3 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 3 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 0 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 0 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** -2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** -2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy + y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy + y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy * y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy * y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 3))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 3))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 0))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 0))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** -2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** -2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 + x) ** 2 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 + x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 * x) ** 2 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 * x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 3 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 3 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 1 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 1 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 0 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 0 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 1 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 1 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** -2 + (y0 - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** -2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 + y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 + y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 * y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 * y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 3))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 3))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 1))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 0))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 0))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 1))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))",
      "mutated_line": "sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** -2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** -2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx + x) ** 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx + x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx * x) ** 2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx * x) ** 2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 3 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 3 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 0 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 0 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 1 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** -2 + (prevy - y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** -2 + (prevy - y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy + y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy + y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy * y) ** 2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy * y) ** 2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 3))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 3))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 0))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 0))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 1))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))",
      "mutated_line": "sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** -2))",
      "code": "from math import sqrt\n\ndef calculate_minimum_sealing_cost(test_cases):\n    intMax = 10 ** 18\n\n    def knapsack(rl, l, c, m):\n        if m == 0 and rl > 0:\n            return intMax\n        if rl <= 0:\n            return 0\n        return min(c[m - 1] + knapsack(rl - l[m - 1], l, c, m), knapsack(rl, l, c, m - 1))\n    results = []\n    for case in test_cases:\n        n = len(case['vertices'])\n        sides = []\n        for i in range(n):\n            (x, y) = case['vertices'][i]\n            if i == 0:\n                (x0, y0) = (x, y)\n                (prevx, prevy) = (x, y)\n            elif i == n - 1:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** 2))\n                sides.append(sqrt((x0 - x) ** 2 + (y0 - y) ** 2))\n            else:\n                sides.append(sqrt((prevx - x) ** 2 + (prevy - y) ** -2))\n                (prevx, prevy) = (x, y)\n        length = [stripe[0] for stripe in case['stripes']]\n        cost = [stripe[1] for stripe in case['stripes']]\n        m = len(case['stripes'])\n        ans = 0\n        for k in sides:\n            ans += knapsack(k, length, cost, m)\n        results.append(int(ans))\n    return results"
    }
  ]
}