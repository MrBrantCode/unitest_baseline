{
  "task_id": "taco_3660",
  "entry_point": "can_fill_squares",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = N - 1 + i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 + i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = (N - 1) * i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = (N - 1) * i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "floor = B + C * j",
      "mutated_line": "floor = B - C * j",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B - C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "floor = B + C * j",
      "mutated_line": "floor = B * (C * j)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B * (C * j)\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ceil = B + D * j",
      "mutated_line": "ceil = B - D * j",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B - D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ceil = B + D * j",
      "mutated_line": "ceil = B * (D * j)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B * (D * j)\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'",
      "mutated_line": "return '' if any((solve_local(i) for i in range(N))) else 'NO'",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return '' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'",
      "mutated_line": "return 'YES' if any((solve_local(i) for i in range(N))) else ''",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else ''"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A - C * i, A + D * i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A - C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A * (C * i), A + D * i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A * (C * i), A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + C * i, A - D * i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A - D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + C * i, A * (D * i))",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A * (D * i))\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = N + 1 - i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N + 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = N * 1 - i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N * 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "floor = B + C * j",
      "mutated_line": "floor = B + C / j",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C / j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "floor = B + C * j",
      "mutated_line": "floor = B + (C + j)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + (C + j)\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "floor = B + C * j",
      "mutated_line": "floor = B + C ** j",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C ** j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ceil = B + D * j",
      "mutated_line": "ceil = B + D / j",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D / j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ceil = B + D * j",
      "mutated_line": "ceil = B + (D + j)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + (D + j)\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "ceil = B + D * j",
      "mutated_line": "ceil = B + D ** j",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D ** j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "return not (m > ceil or M < floor)",
      "mutated_line": "return not (m > ceil and M < floor)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil and M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + C / i, A + D * i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C / i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + (C + i), A + D * i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + (C + i), A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + C ** i, A + D * i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C ** i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + C * i, A + D / i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D / i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + C * i, A + (D + i))",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + (D + i))\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (A + C * i, A + D * i)",
      "mutated_line": "return (A + C * i, A + D ** i)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D ** i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = N - 2 - i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 2 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = N - 0 - i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 0 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = N - 0 - i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 0 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "j = N - 1 - i",
      "mutated_line": "j = N - -1 - i",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - -1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return not (m > ceil or M < floor)",
      "mutated_line": "return not (m >= ceil or M < floor)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m >= ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return not (m > ceil or M < floor)",
      "mutated_line": "return not (m <= ceil or M < floor)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m <= ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return not (m > ceil or M < floor)",
      "mutated_line": "return not (m != ceil or M < floor)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m != ceil or M < floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return not (m > ceil or M < floor)",
      "mutated_line": "return not (m > ceil or M <= floor)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M <= floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return not (m > ceil or M < floor)",
      "mutated_line": "return not (m > ceil or M >= floor)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M >= floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return not (m > ceil or M < floor)",
      "mutated_line": "return not (m > ceil or M != floor)",
      "code": "def can_fill_squares(N, A, B, C, D):\n\n    def ascending_range(i):\n        return (A + C * i, A + D * i)\n\n    def descendable_range(i, m, M):\n        j = N - 1 - i\n        floor = B + C * j\n        ceil = B + D * j\n        return not (m > ceil or M != floor)\n\n    def solve_local(i):\n        return descendable_range(i, *ascending_range(i))\n    return 'YES' if any((solve_local(i) for i in range(N))) else 'NO'"
    }
  ]
}