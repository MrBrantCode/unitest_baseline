{
  "task_id": "taco_7302",
  "entry_point": "count_connected_components",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] / n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] + n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] ** n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) * (p + q) - q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) - q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = (r * (2 * n - r) + (p + q) * (p + q)) * (q * q)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = (r * (2 * n - r) + (p + q) * (p + q)) * (q * q)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (1, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (1, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (-1, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (-1, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (1, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (1, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (0, 1, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 1, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (0, -1, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, -1, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (0, 1, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 1, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (0, 0, 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 1)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (0, 0, -1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, -1)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p, q, r = 0, 0, 0",
      "mutated_line": "(p, q, r) = (0, 0, 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 1)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[v] = 0",
      "mutated_line": "seen[v] = 1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 1\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[v] = 0",
      "mutated_line": "seen[v] = -1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = -1\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "seen[v] = 0",
      "mutated_line": "seen[v] = 1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 1\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f = False",
      "mutated_line": "f = True",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = True\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p -= 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "q += 1",
      "mutated_line": "q -= 1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q -= 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if seen[v] != -1:",
      "mutated_line": "if seen[v] == -1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] == -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "r += 1",
      "mutated_line": "r -= 1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r -= 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) - (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) - (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) * ((p + q) * (p + q)) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) * ((p + q) * (p + q)) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q / q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q / q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + (q + q)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + (q + q)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q ** q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q ** q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v + 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v + 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v * 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v * 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u + 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u + 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u * 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u * 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [+1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 2\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 0\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 0\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += -1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "q += 1",
      "mutated_line": "q += 2",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 2\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "q += 1",
      "mutated_line": "q += 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 0\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "q += 1",
      "mutated_line": "q += 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 0\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "q += 1",
      "mutated_line": "q += -1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += -1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if seen[v] != -1:",
      "mutated_line": "if seen[v] != +1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != +1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r += 1",
      "mutated_line": "r += 2",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 2\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 0\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r += 1",
      "mutated_line": "r += 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 0\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "r += 1",
      "mutated_line": "r += -1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += -1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r / (2 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r / (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r + (2 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r + (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r ** (2 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r ** (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) / (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) / (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q + (p + q)) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q + (p + q)) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) ** (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) ** (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 2)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 2)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - -1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - -1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 2)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 2)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - -1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - -1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-2] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-0] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-0] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "seen = [-1] * n",
      "mutated_line": "(p, q, r) = (0, 0, 0)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [--1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(v, 0)]",
      "mutated_line": "stack = [(v, 1)]",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 1)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(v, 0)]",
      "mutated_line": "stack = [(v, -1)]",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, -1)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(v, 0)]",
      "mutated_line": "stack = [(v, 1)]",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 1)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if seen[nv] == -1:",
      "mutated_line": "if seen[nv] != -1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] != -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if seen[v] != -1:",
      "mutated_line": "if seen[v] != -2:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -2:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if seen[v] != -1:",
      "mutated_line": "if seen[v] != -0:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -0:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if seen[v] != -1:",
      "mutated_line": "if seen[v] != -0:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -0:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if seen[v] != -1:",
      "mutated_line": "if seen[v] != --1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != --1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n + r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n + r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n * r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n * r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p - q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p - q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + p * q * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + p * q * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) * (p - q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p - q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 * n - r) + (p + q) * (p * q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p * q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u + 1].append(v - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u + 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u * 1].append(v - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u * 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v + 1].append(u - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v + 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v * 1].append(u - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v * 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "if seen[nv] == -1:",
      "mutated_line": "if seen[nv] == +1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == +1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "seen[nv] = c ^ 1",
      "mutated_line": "seen[nv] = c | 1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c | 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif seen[nv] ^ c == 0:",
      "mutated_line": "elif seen[nv] ^ c != 0:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c != 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 / n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 / n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 + n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 + n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (2 ** n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 ** n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 2].append(v - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 2].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - -1].append(v - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - -1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 2].append(u - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 2].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - -1].append(u - 1)",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - -1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if seen[nv] == -1:",
      "mutated_line": "if seen[nv] == -2:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -2:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if seen[nv] == -1:",
      "mutated_line": "if seen[nv] == -0:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -0:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if seen[nv] == -1:",
      "mutated_line": "if seen[nv] == -0:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -0:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if seen[nv] == -1:",
      "mutated_line": "if seen[nv] == --1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == --1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "seen[nv] = c ^ 1",
      "mutated_line": "seen[nv] = c ^ 2",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 2\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "seen[nv] = c ^ 1",
      "mutated_line": "seen[nv] = c ^ 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 0\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "seen[nv] = c ^ 1",
      "mutated_line": "seen[nv] = c ^ 0",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 0\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "seen[nv] = c ^ 1",
      "mutated_line": "seen[nv] = c ^ -1",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ -1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif seen[nv] ^ c == 0:",
      "mutated_line": "elif seen[nv] | c == 0:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] | c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif seen[nv] ^ c == 0:",
      "mutated_line": "elif seen[nv] ^ c == 1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 1:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif seen[nv] ^ c == 0:",
      "mutated_line": "elif seen[nv] ^ c == -1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == -1:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif seen[nv] ^ c == 0:",
      "mutated_line": "elif seen[nv] ^ c == 1:",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 1:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f = True",
      "mutated_line": "f = False",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = False\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (3 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (3 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (1 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (1 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (0 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (0 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (1 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (1 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = r * (2 * n - r) + (p + q) * (p + q) + q * q",
      "mutated_line": "ans = r * (-2 * n - r) + (p + q) * (p + q) + q * q",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (-2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "stack.append((nv, c ^ 1))",
      "mutated_line": "stack.append((nv, c | 1))",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c | 1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stack.append((nv, c ^ 1))",
      "mutated_line": "stack.append((nv, c ^ 2))",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 2))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stack.append((nv, c ^ 1))",
      "mutated_line": "stack.append((nv, c ^ 0))",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 0))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stack.append((nv, c ^ 1))",
      "mutated_line": "stack.append((nv, c ^ 0))",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ 0))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stack.append((nv, c ^ 1))",
      "mutated_line": "stack.append((nv, c ^ -1))",
      "code": "def count_connected_components(n, m, edges):\n    G = [[] for _ in range(n)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    seen = [-1] * n\n    (p, q, r) = (0, 0, 0)\n\n    def dfs(v):\n        nonlocal p, q\n        stack = [(v, 0)]\n        seen[v] = 0\n        f = False\n        while stack:\n            (v, c) = stack.pop()\n            for nv in G[v]:\n                if seen[nv] == -1:\n                    seen[nv] = c ^ 1\n                    stack.append((nv, c ^ -1))\n                elif seen[nv] ^ c == 0:\n                    f = True\n        if f:\n            p += 1\n        else:\n            q += 1\n    for v in range(n):\n        if seen[v] != -1:\n            continue\n        if not G[v]:\n            r += 1\n        else:\n            dfs(v)\n    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q\n    return ans"
    }
  ]
}