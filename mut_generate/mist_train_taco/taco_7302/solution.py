"""
QUESTION:
Takahashi has received an undirected graph with N vertices, numbered 1, 2, ..., N. The edges in this graph are represented by (u_i, v_i). There are no self-loops and multiple edges in this graph.

Based on this graph, Takahashi is now constructing a new graph with N^2 vertices, where each vertex is labeled with a pair of integers (a, b) (1 \leq a \leq N, 1 \leq b \leq N). The edges in this new graph are generated by the following rule:

* Span an edge between vertices (a, b) and (a', b') if and only if both of the following two edges exist in the original graph: an edge between vertices a and a', and an edge between vertices b and b'.



How many connected components are there in this new graph?

Constraints

* 2 \leq N \leq 100,000
* 0 \leq M \leq 200,000
* 1 \leq u_i < v_i \leq N
* There exists no pair of distinct integers i and j such that u_i = u_j and v_i = v_j.

Input

The input is given from Standard Input in the following format:


N M
u_1 v_1
u_2 v_2
:
u_M v_M


Output

Print the number of the connected components in the graph constructed by Takahashi.

Examples

Input

3 1
1 2


Output

7


Input

7 5
1 2
3 4
3 5
4 5
2 6


Output

18
"""

def count_connected_components(n, m, edges):
    G = [[] for _ in range(n)]
    for u, v in edges:
        G[u - 1].append(v - 1)
        G[v - 1].append(u - 1)
    
    seen = [-1] * n
    p, q, r = 0, 0, 0

    def dfs(v):
        nonlocal p, q
        stack = [(v, 0)]
        seen[v] = 0
        f = False
        while stack:
            v, c = stack.pop()
            for nv in G[v]:
                if seen[nv] == -1:
                    seen[nv] = c ^ 1
                    stack.append((nv, c ^ 1))
                elif seen[nv] ^ c == 0:
                    f = True
        if f:
            p += 1
        else:
            q += 1

    for v in range(n):
        if seen[v] != -1:
            continue
        if not G[v]:
            r += 1
        else:
            dfs(v)

    ans = r * (2 * n - r) + (p + q) * (p + q) + q * q
    return ans