{
  "task_id": "taco_18793",
  "entry_point": "shortest_path_cost_and_combinations",
  "mutant_count": 179,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 - 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 * 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 9 - 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 - 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 9 * 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 * 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dists[start_i][start_j] = 0",
      "mutated_line": "dists[start_i][start_j] = 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 1\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dists[start_i][start_j] = 0",
      "mutated_line": "dists[start_i][start_j] = -1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = -1\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dists[start_i][start_j] = 0",
      "mutated_line": "dists[start_i][start_j] = 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 1\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ptns[start_i][start_j] = 1",
      "mutated_line": "ptns[start_i][start_j] = 2",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 2\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ptns[start_i][start_j] = 1",
      "mutated_line": "ptns[start_i][start_j] = 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 0\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ptns[start_i][start_j] = 1",
      "mutated_line": "ptns[start_i][start_j] = 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 0\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ptns[start_i][start_j] = 1",
      "mutated_line": "ptns[start_i][start_j] = -1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = -1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 * 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 + 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 8\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 6\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 0\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 1\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + -7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 * 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 * 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 + 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 + 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 9 + 8",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 8\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 9 + 6",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 6\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 9 + 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 0\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 9 + 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 1\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 9 + -7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + -7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dists = [[INF] * C for _ in range(R)]",
      "mutated_line": "dists = [[INF] / C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] / C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dists = [[INF] * C for _ in range(R)]",
      "mutated_line": "dists = [[INF] + C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] + C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dists = [[INF] * C for _ in range(R)]",
      "mutated_line": "dists = [[INF] ** C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] ** C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ptns = [[0] * C for _ in range(R)]",
      "mutated_line": "ptns = [[0] / C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] / C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ptns = [[0] * C for _ in range(R)]",
      "mutated_line": "ptns = [[0] + C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] + C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ptns = [[0] * C for _ in range(R)]",
      "mutated_line": "ptns = [[0] ** C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] ** C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [2, 0, -1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [2, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [0, 0, -1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [0, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [0, 0, -1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [0, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [-1, 0, -1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [-1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 1, -1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 1, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, -1, -1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, -1, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 1, -1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 1, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, +1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, +1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, -1, 1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 1]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, -1, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, -1]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, -1, 1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 1]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [1, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [-1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [-1, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [1, 1, 0, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [1, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 2, 0, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 2, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 0, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 0, 0, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 0, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, -1, 0, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, -1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 1, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, -1, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, -1, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, 1, -1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 1, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, 0, +1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, +1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if ans_d is not None and d > ans_d:",
      "mutated_line": "if ans_d is not None or d > ans_d:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None or d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if (x, y) == (end_j, end_i):",
      "mutated_line": "if (x, y) != (end_j, end_i):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) != (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d > dists[y][x]:",
      "mutated_line": "if d >= dists[y][x]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d >= dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d > dists[y][x]:",
      "mutated_line": "if d <= dists[y][x]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d <= dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if d > dists[y][x]:",
      "mutated_line": "if d != dists[y][x]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d != dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "ptns[ny][nx] += ptns[y][x]",
      "mutated_line": "ptns[ny][nx] -= ptns[y][x]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] -= ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "ptns[ny][nx] += ptns[y][x]",
      "mutated_line": "ptns[ny][nx] -= ptns[y][x]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] -= ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return ans_d, ptns[end_i][end_j] % MOD",
      "mutated_line": "return (ans_d, ptns[end_i][end_j] * MOD)",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] * MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return ans_d, ptns[end_i][end_j] % MOD",
      "mutated_line": "return (ans_d, ptns[end_i][end_j] + MOD)",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] + MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 11 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 9 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 0 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 1 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = -10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 10 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 8 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 0 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 1 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** -9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 11 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 11 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 9 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 9 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 0 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 0 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 1 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 1 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = -10 ** 9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = -10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 10 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 10 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 8 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 8 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 0 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 0 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** 1 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 1 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 10 ** 9 + 7",
      "mutated_line": "INF = 10 ** -9 + 7",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** -9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, -2, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -2, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, -0, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -0, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, -0, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -0, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dxs = [1, 0, -1, 0]",
      "mutated_line": "dxs = [1, 0, --1, 0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, --1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, 0, -2]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -2]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -0]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, 0, -0]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -0]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dys = [0, 1, 0, -1]",
      "mutated_line": "dys = [0, 1, 0, --1]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, --1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if ans_d is not None and d > ans_d:",
      "mutated_line": "if ans_d is None and d > ans_d:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if ans_d is not None and d > ans_d:",
      "mutated_line": "if ans_d is not None and d >= ans_d:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d >= ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if ans_d is not None and d > ans_d:",
      "mutated_line": "if ans_d is not None and d <= ans_d:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d <= ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if ans_d is not None and d > ans_d:",
      "mutated_line": "if ans_d is not None and d != ans_d:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d != ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 <= nx < C and (not 0 <= ny < R):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C and (not 0 <= ny < R):\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 1 >= dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 >= dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 1 <= dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 <= dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 1 != dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 != dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if dists[ny][nx] == INF:",
      "mutated_line": "if dists[ny][nx] != INF:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] != INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 1 >= dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 >= dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 1 <= dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 <= dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 1 != dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 != dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if dists[ny][nx] == INF:",
      "mutated_line": "if dists[ny][nx] != INF:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] != INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ptns = [[0] * C for _ in range(R)]",
      "mutated_line": "ptns = [[1] * C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[1] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ptns = [[0] * C for _ in range(R)]",
      "mutated_line": "ptns = [[-1] * C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[-1] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ptns = [[0] * C for _ in range(R)]",
      "mutated_line": "ptns = [[1] * C for _ in range(R)]",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[1] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, start_j, start_i)])",
      "mutated_line": "q = deque([(1, start_j, start_i)])",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(1, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, start_j, start_i)])",
      "mutated_line": "q = deque([(-1, start_j, start_i)])",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(-1, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, start_j, start_i)])",
      "mutated_line": "q = deque([(1, start_j, start_i)])",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(1, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x - dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x * dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y - dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "(nx, ny) = (x + dx, y + dy)",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y * dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d - 1 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d - 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d * 1 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d * 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d - 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d - 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d * 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d * 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 1), (x, R - 1), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 1), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, -1), (x, R - 1), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, -1), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 1), (x, R - 1), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 1), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R + 1), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R + 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R * 1), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R * 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (1, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (1, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (-1, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (-1, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (1, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (1, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C + 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C + 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C * 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C * 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d - 1 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d - 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d * 1 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d * 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d - 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d - 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d * 1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d * 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 < nx < C or not 0 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 < nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 > nx < C or not 0 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 > nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 == nx < C or not 0 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 == nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 <= nx < C or not 0 < ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 < ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 <= nx < C or not 0 > ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 > ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 <= nx < C or not 0 == ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 == ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 2 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 2 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 0 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 0 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 0 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 0 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + -1 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + -1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + 2",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 2\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 0\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 0\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + -1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + -1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 2), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 2), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 0), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 0), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 0), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 0), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - -1), (0, y), (C - 1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - -1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 2, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 2, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 0, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 0, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 0, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 0, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):",
      "mutated_line": "for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - -1, y)):",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - -1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 2 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 2 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 0 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 0 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + 0 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 0 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if d + 1 > dists[ny][nx]:",
      "mutated_line": "if d + -1 > dists[ny][nx]:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + -1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + 2",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 2\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 0\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + 0",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 0\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "dists[ny][nx] = d + 1",
      "mutated_line": "dists[ny][nx] = d + -1",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + -1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 1 <= nx < C or not 0 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 1 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not -1 <= nx < C or not 0 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not -1 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 1 <= nx < C or not 0 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 1 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 <= nx < C or not 1 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 1 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 <= nx < C or not -1 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not -1 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if not 0 <= nx < C or not 0 <= ny < R:",
      "mutated_line": "if not 0 <= nx < C or not 1 <= ny < R:",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 1 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d - 1, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d - 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d * 1, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d * 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d - 1, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d - 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d * 1, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d * 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + 2, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 2, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + 0, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 0, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + 0, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 0, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + -1, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + -1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + 2, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 2, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + 0, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 0, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + 0, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 0, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((d + 1, nx, ny))",
      "mutated_line": "q.append((d + -1, nx, ny))",
      "code": "from collections import deque\n\ndef shortest_path_cost_and_combinations(R, C, start_i, start_j, end_i, end_j):\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 9 + 7\n    dists = [[INF] * C for _ in range(R)]\n    dists[start_i][start_j] = 0\n    ptns = [[0] * C for _ in range(R)]\n    ptns[start_i][start_j] = 1\n    q = deque([(0, start_j, start_i)])\n    dxs = [1, 0, -1, 0]\n    dys = [0, 1, 0, -1]\n    ans_d = None\n    while q:\n        (d, x, y) = q.popleft()\n        if ans_d is not None and d > ans_d:\n            break\n        if (x, y) == (end_j, end_i):\n            ans_d = d\n        if d > dists[y][x]:\n            continue\n        dists[y][x] = d\n        for (dx, dy) in zip(dxs, dys):\n            (nx, ny) = (x + dx, y + dy)\n            if not 0 <= nx < C or not 0 <= ny < R:\n                continue\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + 1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n        for (nx, ny) in ((x, 0), (x, R - 1), (0, y), (C - 1, y)):\n            if d + 1 > dists[ny][nx]:\n                continue\n            if dists[ny][nx] == INF:\n                q.append((d + -1, nx, ny))\n                dists[ny][nx] = d + 1\n            ptns[ny][nx] += ptns[y][x]\n            ptns[ny][nx] %= MOD\n    return (ans_d, ptns[end_i][end_j] % MOD)"
    }
  ]
}