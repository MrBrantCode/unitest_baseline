{
  "task_id": "taco_18326",
  "entry_point": "find_lexicographically_smallest_A",
  "mutant_count": 95,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "count[c] += 1",
      "mutated_line": "count[c] -= 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] -= 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 1\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = -1\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 1\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) <= len(S) / 2:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) <= len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) >= len(S) / 2:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) >= len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) != len(S) / 2:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) != len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "need[S[min_char_at]] -= 1",
      "mutated_line": "need[S[min_char_at]] += 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] += 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count[c] += 1",
      "mutated_line": "count[c] += 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 2\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count[c] += 1",
      "mutated_line": "count[c] += 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 0\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count[c] += 1",
      "mutated_line": "count[c] += 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 0\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count[c] += 1",
      "mutated_line": "count[c] += -1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += -1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "need[c] = count[c] / 2",
      "mutated_line": "need[c] = count[c] * 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] * 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "need[c] = count[c] / 2",
      "mutated_line": "need[c] = count[c] // 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] // 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) < len(S) * 2:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) * 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) < len(S) // 2:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) // 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "min_char_at = -1",
      "mutated_line": "min_char_at = +1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = +1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while False:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "count[c] -= 1",
      "mutated_line": "count[c] += 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] += 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i -= 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "count[S[j]] += 1",
      "mutated_line": "count[S[j]] -= 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] -= 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "need[S[min_char_at]] -= 1",
      "mutated_line": "need[S[min_char_at]] -= 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 2\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "need[S[min_char_at]] -= 1",
      "mutated_line": "need[S[min_char_at]] -= 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 0\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "need[S[min_char_at]] -= 1",
      "mutated_line": "need[S[min_char_at]] -= 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 0\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "need[S[min_char_at]] -= 1",
      "mutated_line": "need[S[min_char_at]] -= -1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= -1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "i = min_char_at + 1",
      "mutated_line": "i = min_char_at - 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at - 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "i = min_char_at + 1",
      "mutated_line": "i = min_char_at * 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at * 1\n    return ''.join(solution)"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "S = S[::-1]",
      "mutated_line": "S = S[::+1]",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::+1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "need[c] = count[c] / 2",
      "mutated_line": "need[c] = count[c] / 3",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 3\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "need[c] = count[c] / 2",
      "mutated_line": "need[c] = count[c] / 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 1\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "need[c] = count[c] / 2",
      "mutated_line": "need[c] = count[c] / 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 0\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "need[c] = count[c] / 2",
      "mutated_line": "need[c] = count[c] / 1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 1\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "need[c] = count[c] / 2",
      "mutated_line": "need[c] = count[c] / -2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / -2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) < len(S) / 3:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 3:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) < len(S) / 1:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 1:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) < len(S) / 0:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 0:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) < len(S) / 1:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 1:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while len(solution) < len(S) / 2:",
      "mutated_line": "while len(solution) < len(S) / -2:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / -2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_char_at = -1",
      "mutated_line": "min_char_at = -2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -2\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_char_at = -1",
      "mutated_line": "min_char_at = -0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -0\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_char_at = -1",
      "mutated_line": "min_char_at = -0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -0\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "min_char_at = -1",
      "mutated_line": "min_char_at = --1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = --1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 or (min_char_at < 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 or (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count[c] -= 1",
      "mutated_line": "count[c] -= 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 2\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count[c] -= 1",
      "mutated_line": "count[c] -= 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 0\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count[c] -= 1",
      "mutated_line": "count[c] -= 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 0\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count[c] -= 1",
      "mutated_line": "count[c] -= -1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= -1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if count[c] < need[c]:",
      "mutated_line": "if count[c] <= need[c]:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] <= need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if count[c] < need[c]:",
      "mutated_line": "if count[c] >= need[c]:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] >= need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if count[c] < need[c]:",
      "mutated_line": "if count[c] != need[c]:",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] != need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 2\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 0\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 0\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += -1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at - 1, i + 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at - 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at * 1, i + 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at * 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 1, i - 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i - 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 1, i * 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i * 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count[S[j]] += 1",
      "mutated_line": "count[S[j]] += 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 2\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count[S[j]] += 1",
      "mutated_line": "count[S[j]] += 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 0\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count[S[j]] += 1",
      "mutated_line": "count[S[j]] += 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 0\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "count[S[j]] += 1",
      "mutated_line": "count[S[j]] += -1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += -1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min_char_at + 1",
      "mutated_line": "i = min_char_at + 2",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 2\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min_char_at + 1",
      "mutated_line": "i = min_char_at + 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 0\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min_char_at + 1",
      "mutated_line": "i = min_char_at + 0",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 0\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "i = min_char_at + 1",
      "mutated_line": "i = min_char_at + -1",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + -1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return ''.join(solution)",
      "mutated_line": "return 'MUTATED'.join(solution)",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return 'MUTATED'.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = S[::-1]",
      "mutated_line": "S = S[::-2]",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-2]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = S[::-1]",
      "mutated_line": "S = S[::-0]",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-0]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = S[::-1]",
      "mutated_line": "S = S[::-0]",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-0]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "S = S[::-1]",
      "mutated_line": "S = S[::--1]",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::--1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] >= 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] >= 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] <= 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] <= 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] != 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] != 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at < 0 and c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 and c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 2, i + 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 2, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 0, i + 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 0, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 0, i + 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 0, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + -1, i + 1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + -1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 1, i + 2):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 2):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 1, i + 0):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 0):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 1, i + 0):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 0):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for j in range(min_char_at+1, i+1):",
      "mutated_line": "for j in range(min_char_at + 1, i + -1):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + -1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 1 and (min_char_at < 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 1 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > -1 and (min_char_at < 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > -1 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 1 and (min_char_at < 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 1 and (min_char_at < 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at <= 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at <= 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at >= 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at >= 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at != 0 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at != 0 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at < 0 or c <= S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c <= S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at < 0 or c >= S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c >= S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at < 0 or c != S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 0 or c != S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at < 1 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 1 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at < -1 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < -1 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if need[c] > 0 and (min_char_at < 0 or c < S[min_char_at]):",
      "mutated_line": "if need[c] > 0 and (min_char_at < 1 or c < S[min_char_at]):",
      "code": "from collections import defaultdict\n\ndef find_lexicographically_smallest_A(S):\n    S = S[::-1]\n    count = defaultdict(int)\n    for c in S:\n        count[c] += 1\n    need = {}\n    for c in count:\n        need[c] = count[c] / 2\n    solution = []\n    i = 0\n    while len(solution) < len(S) / 2:\n        min_char_at = -1\n        while True:\n            c = S[i]\n            if need[c] > 0 and (min_char_at < 1 or c < S[min_char_at]):\n                min_char_at = i\n            count[c] -= 1\n            if count[c] < need[c]:\n                break\n            i += 1\n        for j in range(min_char_at + 1, i + 1):\n            count[S[j]] += 1\n        need[S[min_char_at]] -= 1\n        solution.append(S[min_char_at])\n        i = min_char_at + 1\n    return ''.join(solution)"
    }
  ]
}