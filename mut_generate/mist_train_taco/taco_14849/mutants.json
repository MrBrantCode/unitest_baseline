{
  "task_id": "taco_14849",
  "entry_point": "max_sweets_buyable",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 1\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = -1\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 1\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while False:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if r >= sorted_pv_list[i][0]:",
      "mutated_line": "if r > sorted_pv_list[i][0]:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r > sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if r >= sorted_pv_list[i][0]:",
      "mutated_line": "if r < sorted_pv_list[i][0]:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r < sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if r >= sorted_pv_list[i][0]:",
      "mutated_line": "if r == sorted_pv_list[i][0]:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r == sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "count += to_buy + 1",
      "mutated_line": "count -= to_buy + 1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count -= to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] + x[1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] + x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] * x[1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] * x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "budget = r - sorted_pv_list[i][0]",
      "mutated_line": "budget = r + sorted_pv_list[i][0]",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r + sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "budget = r - sorted_pv_list[i][0]",
      "mutated_line": "budget = r * sorted_pv_list[i][0]",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r * sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "to_buy = 0",
      "mutated_line": "to_buy = 1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 1\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "to_buy = 0",
      "mutated_line": "to_buy = -1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = -1\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "to_buy = 0",
      "mutated_line": "to_buy = 1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 1\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if budget > 0:",
      "mutated_line": "if budget >= 0:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget >= 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if budget > 0:",
      "mutated_line": "if budget <= 0:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget <= 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if budget > 0:",
      "mutated_line": "if budget != 0:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget != 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r + (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r + (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r * ((to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r * ((to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "count += to_buy + 1",
      "mutated_line": "count += to_buy - 1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy - 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "count += to_buy + 1",
      "mutated_line": "count += to_buy * 1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy * 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sort_by_p_list = sorted(pv_list, key=lambda x: x[0])",
      "mutated_line": "sort_by_p_list = sorted(pv_list, key=lambda x: x[1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[1])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sort_by_p_list = sorted(pv_list, key=lambda x: x[0])",
      "mutated_line": "sort_by_p_list = sorted(pv_list, key=lambda x: x[-1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[-1])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sort_by_p_list = sorted(pv_list, key=lambda x: x[0])",
      "mutated_line": "sort_by_p_list = sorted(pv_list, key=lambda x: x[1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[1])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if r >= sorted_pv_list[i][0]:",
      "mutated_line": "if r >= sorted_pv_list[i][1]:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][1]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if r >= sorted_pv_list[i][0]:",
      "mutated_line": "if r >= sorted_pv_list[i][-1]:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][-1]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if r >= sorted_pv_list[i][0]:",
      "mutated_line": "if r >= sorted_pv_list[i][1]:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][1]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if budget > 0:",
      "mutated_line": "if budget > 1:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 1:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if budget > 0:",
      "mutated_line": "if budget > -1:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > -1:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if budget > 0:",
      "mutated_line": "if budget > 1:",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 1:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) / (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) / (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1 + (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1 + (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) ** (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) ** (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += to_buy + 1",
      "mutated_line": "count += to_buy + 2",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 2\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += to_buy + 1",
      "mutated_line": "count += to_buy + 0",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 0\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += to_buy + 1",
      "mutated_line": "count += to_buy + 0",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 0\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "count += to_buy + 1",
      "mutated_line": "count += to_buy + -1",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + -1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[1] - x[1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[1] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[-1] - x[1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[-1] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[1] - x[1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[1] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[2])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[2])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[0])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[0])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[0])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[0])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])",
      "mutated_line": "sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[-1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[-1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "budget = r - sorted_pv_list[i][0]",
      "mutated_line": "budget = r - sorted_pv_list[i][1]",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][1]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "budget = r - sorted_pv_list[i][0]",
      "mutated_line": "budget = r - sorted_pv_list[i][-1]",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][-1]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "budget = r - sorted_pv_list[i][0]",
      "mutated_line": "budget = r - sorted_pv_list[i][1]",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][1]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget * (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget * (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget // (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget // (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy - 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy - 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - to_buy * 1 * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - to_buy * 1 * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] + sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] + sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] * sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] * sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] + sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] + sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] * sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] * sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 2) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 2) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 0) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 0) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 0) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 0) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + -1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + -1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][1] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][1] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][-1] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][-1] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][1] - sorted_pv_list[i][1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][1] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][2])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][2])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][0])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][0])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][0])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][0])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])",
      "mutated_line": "r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][-1])",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][-1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][1] - sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][1] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][-1] - sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][-1] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][1] - sorted_pv_list[i][1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][1] - sorted_pv_list[i][1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][2]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][2]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][0]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][0]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][0]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][0]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][1]))",
      "mutated_line": "to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][-1]))",
      "code": "import math\n\ndef max_sweets_buyable(N, R, A, B):\n    pv_list = [(A[i], B[i]) for i in range(N)]\n    sort_by_p_list = sorted(pv_list, key=lambda x: x[0])\n    sorted_pv_list = sorted(sort_by_p_list, key=lambda x: x[0] - x[1])\n    count = 0\n    r = R\n    while True:\n        for i in range(N):\n            if r >= sorted_pv_list[i][0]:\n                budget = r - sorted_pv_list[i][0]\n                to_buy = 0\n                if budget > 0:\n                    to_buy = math.floor(budget / (sorted_pv_list[i][0] - sorted_pv_list[i][-1]))\n                r = r - (to_buy + 1) * (sorted_pv_list[i][0] - sorted_pv_list[i][1])\n                count += to_buy + 1\n                break\n        else:\n            break\n    return count"
    }
  ]
}