{
  "task_id": "taco_1761",
  "entry_point": "find_optimal_capital",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total_rev = g.dfs(1)",
      "mutated_line": "total_rev = g.dfs(2)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(2)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total_rev = g.dfs(1)",
      "mutated_line": "total_rev = g.dfs(0)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(0)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total_rev = g.dfs(1)",
      "mutated_line": "total_rev = g.dfs(0)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(0)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "total_rev = g.dfs(1)",
      "mutated_line": "total_rev = g.dfs(-1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(-1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 0 or g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 or g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 1 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 1 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = -1 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = -1 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 1 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 1 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return total_rev + min_distance, optimal_capitals",
      "mutated_line": "return (total_rev - min_distance, optimal_capitals)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev - min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return total_rev + min_distance, optimal_capitals",
      "mutated_line": "return (total_rev * min_distance, optimal_capitals)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev * min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] / (n + 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] / (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] + (n + 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] + (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] ** (n + 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] ** (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 1) / 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) / 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 1) * 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) * 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rev = 0",
      "mutated_line": "rev = 1",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 1\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rev = 0",
      "mutated_line": "rev = -1",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = -1\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "rev = 0",
      "mutated_line": "rev = 1",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 1\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visited[root] = True",
      "mutated_line": "visited[root] = False",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = False\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation >= 0 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation >= 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation <= 0 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation <= 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation != 0 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation != 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 0 and g.min_dist >= 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist >= 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 0 and g.min_dist <= 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist <= 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 0 and g.min_dist != 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist != 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] != min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] != min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] * (n - 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n - 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] * (n * 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n * 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "self.distance[0] = sys.maxsize",
      "mutated_line": "self.distance[1] = sys.maxsize",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[1] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "self.distance[0] = sys.maxsize",
      "mutated_line": "self.distance[-1] = sys.maxsize",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[-1] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "self.distance[0] = sys.maxsize",
      "mutated_line": "self.distance[1] = sys.maxsize",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[1] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n / (n + 1) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n / (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = (n + (n + 1)) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = (n + (n + 1)) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n ** (n + 1) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n ** (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 1) // 3",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 3\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 1) // 1",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 1\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 1) // 0",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 0\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 1) // 1",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 1\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 1) // -2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // -2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[s] = True",
      "mutated_line": "visited[s] = False",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = False\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "g.graph[x].append([y, 1])",
      "mutated_line": "g.graph[x].append([y, 2])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 2])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "g.graph[x].append([y, 1])",
      "mutated_line": "g.graph[x].append([y, 0])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 0])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "g.graph[x].append([y, 1])",
      "mutated_line": "g.graph[x].append([y, 0])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 0])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "g.graph[x].append([y, 1])",
      "mutated_line": "g.graph[x].append([y, -1])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, -1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "g.graph[y].append([x, -1])",
      "mutated_line": "g.graph[y].append([x, +1])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, +1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 1 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 1 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > -1 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > -1 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 1 and g.min_dist > 0 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 1 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 1 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 1 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 0 and g.min_dist > -1 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > -1 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist",
      "mutated_line": "min_distance = 0 if g.summation > 0 and g.min_dist > 1 else g.min_dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 1 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(2, n + 1) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(2, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(0, n + 1) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(0, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(0, n + 1) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(0, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(-1, n + 1) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(-1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(1, n - 1) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n - 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(1, n * 1) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n * 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [1] * (n + 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [1] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [-1] * (n + 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [-1] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [1] * (n + 1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [1] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] * (n + 2)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 2)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] * (n + 0)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 0)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] * (n + 0)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 0)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "self.distance = [0] * (n + 1)",
      "mutated_line": "self.distance = [0] * (n + -1)",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + -1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n - 1) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n - 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n * 1) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n * 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if v[0] not in visited:",
      "mutated_line": "if v[0] in visited:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "self.summation -= v[0]",
      "mutated_line": "self.summation += v[0]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation += v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "g.graph[y].append([x, -1])",
      "mutated_line": "g.graph[y].append([x, -2])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -2])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "g.graph[y].append([x, -1])",
      "mutated_line": "g.graph[y].append([x, -0])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -0])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "g.graph[y].append([x, -1])",
      "mutated_line": "g.graph[y].append([x, -0])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -0])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "g.graph[y].append([x, -1])",
      "mutated_line": "g.graph[y].append([x, --1])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, --1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(1, n + 2) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 2) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(1, n + 0) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 0) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(1, n + 0) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 0) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]",
      "mutated_line": "optimal_capitals = [i for i in range(1, n + -1) if g.distance[i] == min_distance]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + -1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(2, n + 1)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(2, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(0, n + 1)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(0, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(0, n + 1)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(0, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(-1, n + 1)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(-1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(1, n - 1)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n - 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(1, n * 1)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n * 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 2) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 2) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 0) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 0) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + 0) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 0) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "self.summation = n * (n + 1) // 2",
      "mutated_line": "self.summation = n * (n + -1) // 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + -1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = self.distance[s] + v[1]",
      "mutated_line": "dist = self.distance[s] - v[1]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] - v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = self.distance[s] + v[1]",
      "mutated_line": "dist = self.distance[s] * v[1]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] * v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dist < self.min_dist:",
      "mutated_line": "if dist <= self.min_dist:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist <= self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dist < self.min_dist:",
      "mutated_line": "if dist >= self.min_dist:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist >= self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if dist < self.min_dist:",
      "mutated_line": "if dist != self.min_dist:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist != self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[1] != -1:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] != -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "rev += 1",
      "mutated_line": "rev -= 1",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev -= 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(1, n + 2)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 2)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(1, n + 0)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 0)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(1, n + 0)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 0)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.graph = {i: [] for i in range(1, n + 1)}",
      "mutated_line": "self.graph = {i: [] for i in range(1, n + -1)}",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + -1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v[0] not in visited:",
      "mutated_line": "if v[1] not in visited:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[1] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v[0] not in visited:",
      "mutated_line": "if v[-1] not in visited:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[-1] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v[0] not in visited:",
      "mutated_line": "if v[1] not in visited:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[1] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "self.summation -= v[0]",
      "mutated_line": "self.summation -= v[1]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[1]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "self.summation -= v[0]",
      "mutated_line": "self.summation -= v[-1]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[-1]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "self.summation -= v[0]",
      "mutated_line": "self.summation -= v[1]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[1]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[1] == +1:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == +1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rev += 1",
      "mutated_line": "rev += 2",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 2\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rev += 1",
      "mutated_line": "rev += 0",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 0\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rev += 1",
      "mutated_line": "rev += 0",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 0\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rev += 1",
      "mutated_line": "rev += -1",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += -1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = self.distance[s] + v[1]",
      "mutated_line": "dist = self.distance[s] + v[2]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[2]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = self.distance[s] + v[1]",
      "mutated_line": "dist = self.distance[s] + v[0]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[0]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = self.distance[s] + v[1]",
      "mutated_line": "dist = self.distance[s] + v[0]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[0]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = self.distance[s] + v[1]",
      "mutated_line": "dist = self.distance[s] + v[-1]",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[-1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.distance[v[0]] = dist",
      "mutated_line": "self.distance[v[1]] = dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[1]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.distance[v[0]] = dist",
      "mutated_line": "self.distance[v[-1]] = dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[-1]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "self.distance[v[0]] = dist",
      "mutated_line": "self.distance[v[1]] = dist",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[1]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[2] == -1:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[2] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[0] == -1:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[0] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[0] == -1:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[0] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[-1] == -1:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[-1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[1] == -2:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -2:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[1] == -0:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -0:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[1] == -0:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -0:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if v[1] == -1:",
      "mutated_line": "if v[1] == --1:",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == --1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[0])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "stack.append(v[0])",
      "mutated_line": "stack.append(v[1])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[1])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "stack.append(v[0])",
      "mutated_line": "stack.append(v[-1])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[-1])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "stack.append(v[0])",
      "mutated_line": "stack.append(v[1])",
      "code": "import sys\nfrom collections import defaultdict\n\ndef find_optimal_capital(n, roads):\n\n    class Graph:\n\n        def __init__(self, n):\n            self.graph = {i: [] for i in range(1, n + 1)}\n            self.distance = [0] * (n + 1)\n            self.distance[0] = sys.maxsize\n            self.min_dist = sys.maxsize\n            self.summation = n * (n + 1) // 2\n\n        def dfs(self, root, visited=defaultdict(bool)):\n            (stack, path) = ([root], [])\n            rev = 0\n            visited[root] = True\n            while stack:\n                s = stack.pop()\n                visited[s] = True\n                for v in self.graph[s]:\n                    if v[0] not in visited:\n                        dist = self.distance[s] + v[1]\n                        if dist < self.min_dist:\n                            self.min_dist = dist\n                        self.distance[v[0]] = dist\n                        self.summation -= v[0]\n                        if v[1] == -1:\n                            rev += 1\n                        path.append(s)\n                        stack.append(v[1])\n            return rev\n\n        def get_min_distance(self):\n            return min(self.distance)\n    g = Graph(n)\n    for (x, y) in roads:\n        g.graph[x].append([y, 1])\n        g.graph[y].append([x, -1])\n    total_rev = g.dfs(1)\n    min_distance = 0 if g.summation > 0 and g.min_dist > 0 else g.min_dist\n    optimal_capitals = [i for i in range(1, n + 1) if g.distance[i] == min_distance]\n    return (total_rev + min_distance, optimal_capitals)"
    }
  ]
}