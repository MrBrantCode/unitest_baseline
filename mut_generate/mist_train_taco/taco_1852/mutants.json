{
  "task_id": "taco_1852",
  "entry_point": "calculate_minimum_distance",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cur_a = 0",
      "mutated_line": "cur_a = 1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 1\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cur_a = 0",
      "mutated_line": "cur_a = -1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = -1\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cur_a = 0",
      "mutated_line": "cur_a = 1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 1\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_b = 0",
      "mutated_line": "cur_b = 1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 1\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_b = 0",
      "mutated_line": "cur_b = -1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = -1\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_b = 0",
      "mutated_line": "cur_b = 1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 1\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 1\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = -1\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 1\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total -= min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total -= min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_a = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_a = indexed_numbers.pop(0)[2]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[2]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_a = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_a = indexed_numbers.pop(0)[0]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[0]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_a = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_a = indexed_numbers.pop(0)[0]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[0]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_a = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_a = indexed_numbers.pop(0)[-1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[-1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_b = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_b = indexed_numbers.pop(0)[2]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[2]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_b = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_b = indexed_numbers.pop(0)[0]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[0]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_b = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_b = indexed_numbers.pop(0)[0]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[0]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_b = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_b = indexed_numbers.pop(0)[-1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[-1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) - abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) - abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) * abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) * abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) - abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) - abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) * abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) * abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(2 / n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 / n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(2 + n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 + n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(2 ** n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 ** n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_a = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_a = indexed_numbers.pop(1)[1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(1)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_a = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_a = indexed_numbers.pop(-1)[1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(-1)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_a = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_a = indexed_numbers.pop(1)[1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(1)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_b = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_b = indexed_numbers.pop(1)[1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(1)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_b = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_b = indexed_numbers.pop(-1)[1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(-1)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "next_b = indexed_numbers.pop(0)[1]",
      "mutated_line": "next_b = indexed_numbers.pop(1)[1]",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(1)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(3 * n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(3 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(1 * n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(1 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(0 * n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(0 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(1 * n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(1 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "indexed_numbers = list(zip(tiers, range(2 * n)))",
      "mutated_line": "indexed_numbers = list(zip(tiers, range(-2 * n)))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(-2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "indexed_numbers.sort(key=lambda x: x[0])",
      "mutated_line": "indexed_numbers.sort(key=lambda x: x[1])",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[1])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "indexed_numbers.sort(key=lambda x: x[0])",
      "mutated_line": "indexed_numbers.sort(key=lambda x: x[-1])",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[-1])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "indexed_numbers.sort(key=lambda x: x[0])",
      "mutated_line": "indexed_numbers.sort(key=lambda x: x[1])",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[1])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a + next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a + next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a * next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a * next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b + next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b + next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b * next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b * next_b), abs(cur_a - next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a + next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a + next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a * next_b) + abs(cur_b - next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a * next_b) + abs(cur_b - next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b + next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b + next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b - next_a))",
      "mutated_line": "total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b * next_a))",
      "code": "def calculate_minimum_distance(n, tiers):\n    indexed_numbers = list(zip(tiers, range(2 * n)))\n    indexed_numbers.sort(key=lambda x: x[0])\n    cur_a = 0\n    cur_b = 0\n    total = 0\n    while indexed_numbers:\n        next_a = indexed_numbers.pop(0)[1]\n        next_b = indexed_numbers.pop(0)[1]\n        total += min(abs(cur_a - next_a) + abs(cur_b - next_b), abs(cur_a - next_b) + abs(cur_b * next_a))\n        cur_a = next_a\n        cur_b = next_b\n    return total"
    }
  ]
}