{
  "task_id": "taco_3490",
  "entry_point": "max_non_overlapping_bundles",
  "mutant_count": 30,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 1\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = -1\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 1\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "prev_end = -1",
      "mutated_line": "prev_end = +1",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = +1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_end = -1",
      "mutated_line": "prev_end = -2",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -2\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_end = -1",
      "mutated_line": "prev_end = -0",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -0\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_end = -1",
      "mutated_line": "prev_end = -0",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -0\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_end = -1",
      "mutated_line": "prev_end = --1",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = --1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if r[0] >= prev_end:",
      "mutated_line": "if r[0] > prev_end:",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] > prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if r[0] >= prev_end:",
      "mutated_line": "if r[0] < prev_end:",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] < prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if r[0] >= prev_end:",
      "mutated_line": "if r[0] == prev_end:",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] == prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count -= 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 2\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 0\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 0\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += -1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if r[0] >= prev_end:",
      "mutated_line": "if r[1] >= prev_end:",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[1] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if r[0] >= prev_end:",
      "mutated_line": "if r[-1] >= prev_end:",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[-1] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if r[0] >= prev_end:",
      "mutated_line": "if r[1] >= prev_end:",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[1] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prev_end = r[1]",
      "mutated_line": "prev_end = r[2]",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[2]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prev_end = r[1]",
      "mutated_line": "prev_end = r[0]",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[0]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prev_end = r[1]",
      "mutated_line": "prev_end = r[0]",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[0]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "prev_end = r[1]",
      "mutated_line": "prev_end = r[-1]",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[-1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ranges.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "ranges.sort(key=lambda x: (x[2], x[0]))",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[2], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ranges.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "ranges.sort(key=lambda x: (x[0], x[0]))",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[0], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ranges.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "ranges.sort(key=lambda x: (x[0], x[0]))",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[0], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ranges.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "ranges.sort(key=lambda x: (x[-1], x[0]))",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[-1], x[0]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ranges.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "ranges.sort(key=lambda x: (x[1], x[1]))",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[1]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ranges.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "ranges.sort(key=lambda x: (x[1], x[-1]))",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[-1]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ranges.sort(key=lambda x: (x[1], x[0]))",
      "mutated_line": "ranges.sort(key=lambda x: (x[1], x[1]))",
      "code": "def max_non_overlapping_bundles(ranges):\n    ranges.sort(key=lambda x: (x[1], x[1]))\n    count = 0\n    prev_end = -1\n    for r in ranges:\n        if r[0] >= prev_end:\n            count += 1\n            prev_end = r[1]\n    return count"
    }
  ]
}