{
  "task_id": "taco_15367",
  "entry_point": "calculate_max_happiness",
  "mutant_count": 110,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] / (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] / (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] + (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] + (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] ** (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] ** (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] / (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] / (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] + (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] + (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] ** (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] ** (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] / (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] / (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] + (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] + (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] ** (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] ** (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[1] = 2",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 2\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[1] = 0",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 0\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[1] = 0",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 0\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[1] = -1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = -1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_depth = 0",
      "mutated_line": "current_depth = 1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 1\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_depth = 0",
      "mutated_line": "current_depth = -1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = -1\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "current_depth = 0",
      "mutated_line": "current_depth = 1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 1\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "current_depth += 1",
      "mutated_line": "current_depth -= 1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth -= 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] / (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] / (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] + (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] + (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] ** (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] ** (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "subtree_size[parent_node] += 1 + subtree_size[node]",
      "mutated_line": "subtree_size[parent_node] -= 1 + subtree_size[node]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] -= 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] * (n - 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n - 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] * (n * 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n * 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n - 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n - 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n * 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n * 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n - 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n - 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n * 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n * 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[2] = 1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[2] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[0] = 1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[0] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[0] = 1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[0] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[1] = 1",
      "mutated_line": "visited[-1] = 1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[-1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_depth += 1",
      "mutated_line": "current_depth += 2",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 2\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_depth += 1",
      "mutated_line": "current_depth += 0",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 0\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_depth += 1",
      "mutated_line": "current_depth += 0",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 0\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "current_depth += 1",
      "mutated_line": "current_depth += -1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += -1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] * (n - 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n - 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] * (n * 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n * 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 1, -1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 1, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, -1, -1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, -1, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 1, -1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 1, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, +1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, +1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "subtree_size[parent_node] += 1 + subtree_size[node]",
      "mutated_line": "subtree_size[parent_node] += 1 - subtree_size[node]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 - subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "subtree_size[parent_node] += 1 + subtree_size[node]",
      "mutated_line": "subtree_size[parent_node] += 1 * subtree_size[node]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 * subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(2, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(0, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(0, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(-1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n - 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n * 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [1] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [-1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [-1] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [1] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] * (n + 2)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 2)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 0)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 0)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "depth = [0] * (n + 1)",
      "mutated_line": "depth = [0] * (n + -1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + -1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [1] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [-1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [-1] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [1] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + 2)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 2)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 0)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 0)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + -1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + -1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([2])",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([2])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([0])",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([0])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([0])",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([0])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = deque([1])",
      "mutated_line": "queue = deque([-1])",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([-1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [1] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [-1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [-1] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [1] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 2)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 2)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 0)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 0)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + -1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + -1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [1] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [-1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [-1] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [1] * (n + 1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [1] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] * (n + 2)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 2)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 0)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] * (n + 0)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 0)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "subtree_size = [0] * (n + 1)",
      "mutated_line": "subtree_size = [0] * (n + -1)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + -1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -2):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -2):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -0):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -0):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -0):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -0):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, --1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, --1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "subtree_size[parent_node] += 1 + subtree_size[node]",
      "mutated_line": "subtree_size[parent_node] += 2 + subtree_size[node]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 2 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "subtree_size[parent_node] += 1 + subtree_size[node]",
      "mutated_line": "subtree_size[parent_node] += 0 + subtree_size[node]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 0 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "subtree_size[parent_node] += 1 + subtree_size[node]",
      "mutated_line": "subtree_size[parent_node] += 0 + subtree_size[node]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 0 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "subtree_size[parent_node] += 1 + subtree_size[node]",
      "mutated_line": "subtree_size[parent_node] += -1 + subtree_size[node]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += -1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 2):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 0):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 0):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + -1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "happiness_contribution.append(depth[i] - subtree_size[i])",
      "mutated_line": "happiness_contribution.append(depth[i] + subtree_size[i])",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] + subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "happiness_contribution.append(depth[i] - subtree_size[i])",
      "mutated_line": "happiness_contribution.append(depth[i] * subtree_size[i])",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] * subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "happiness_contribution.sort(reverse=True)",
      "mutated_line": "happiness_contribution.sort(reverse=False)",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=False)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [set() for _ in range(n + 1)]",
      "mutated_line": "graph = [set() for _ in range(n - 1)]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n - 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = [set() for _ in range(n + 1)]",
      "mutated_line": "graph = [set() for _ in range(n * 1)]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n * 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if visited[neighbor] == 0:",
      "mutated_line": "if visited[neighbor] != 0:",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] != 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [set() for _ in range(n + 1)]",
      "mutated_line": "graph = [set() for _ in range(n + 2)]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 2)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [set() for _ in range(n + 1)]",
      "mutated_line": "graph = [set() for _ in range(n + 0)]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 0)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [set() for _ in range(n + 1)]",
      "mutated_line": "graph = [set() for _ in range(n + 0)]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 0)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = [set() for _ in range(n + 1)]",
      "mutated_line": "graph = [set() for _ in range(n + -1)]",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + -1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if visited[neighbor] == 0:",
      "mutated_line": "if visited[neighbor] == 1:",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 1:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if visited[neighbor] == 0:",
      "mutated_line": "if visited[neighbor] == -1:",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if visited[neighbor] == 0:",
      "mutated_line": "if visited[neighbor] == 1:",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 1:\n                    visited[neighbor] = 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = 2",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 2\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = 0",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 0\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = 0",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = 0\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "visited[neighbor] = 1",
      "mutated_line": "visited[neighbor] = -1",
      "code": "def calculate_max_happiness(n, k, roads):\n    from collections import deque\n    graph = [set() for _ in range(n + 1)]\n    for (u, v) in roads:\n        graph[u].add(v)\n        graph[v].add(u)\n    depth = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    queue = deque([1])\n    visited = [0] * (n + 1)\n    visited[1] = 1\n    current_depth = 0\n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            depth[node] = current_depth\n            for neighbor in graph[node]:\n                if visited[neighbor] == 0:\n                    visited[neighbor] = -1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n        current_depth += 1\n    subtree_size = [0] * (n + 1)\n    for i in range(n, 0, -1):\n        node = i\n        parent_node = parent[node]\n        subtree_size[parent_node] += 1 + subtree_size[node]\n    happiness_contribution = []\n    for i in range(1, n + 1):\n        happiness_contribution.append(depth[i] - subtree_size[i])\n    happiness_contribution.sort(reverse=True)\n    max_happiness = sum(happiness_contribution[:k])\n    return max_happiness"
    }
  ]
}