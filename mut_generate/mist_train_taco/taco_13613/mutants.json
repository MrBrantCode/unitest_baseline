{
  "task_id": "taco_13613",
  "entry_point": "calculate_soulmate_distances",
  "mutant_count": 195,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "tail += 1",
      "mutated_line": "tail -= 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail -= 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] / (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] / (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] + (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] + (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] ** (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] ** (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "counts[a] += 1",
      "mutated_line": "counts[a] -= 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] -= 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "counts[b] += 1",
      "mutated_line": "counts[b] -= 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] -= 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] / (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] / (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] + (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] + (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] ** (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] ** (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] / (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] / (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] + (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] + (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] ** (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] ** (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "root = 1",
      "mutated_line": "root = 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 2\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "root = 1",
      "mutated_line": "root = 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 0\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "root = 1",
      "mutated_line": "root = 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 0\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "root = 1",
      "mutated_line": "root = -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = -1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] / (2 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] / (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] + 2 * k",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] + 2 * k\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] ** (2 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] ** (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tail += 1",
      "mutated_line": "tail += 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 2\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tail += 1",
      "mutated_line": "tail += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 0\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tail += 1",
      "mutated_line": "tail += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 0\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tail += 1",
      "mutated_line": "tail += -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += -1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while head < tail:",
      "mutated_line": "while head <= tail:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head <= tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while head < tail:",
      "mutated_line": "while head >= tail:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head >= tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while head < tail:",
      "mutated_line": "while head != tail:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head != tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "head += 1",
      "mutated_line": "head -= 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head -= 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] / (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] / (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] + (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] + (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] ** (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] ** (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimum = maximum = 0",
      "mutated_line": "minimum = maximum = 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 1\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimum = maximum = 0",
      "mutated_line": "minimum = maximum = -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = -1\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "minimum = maximum = 0",
      "mutated_line": "minimum = maximum = 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 1\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "index = len(queue) - 1",
      "mutated_line": "index = len(queue) + 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) + 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "index = len(queue) - 1",
      "mutated_line": "index = len(queue) * 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) * 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while index >= 0:",
      "mutated_line": "while index > 0:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index > 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while index >= 0:",
      "mutated_line": "while index < 0:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index < 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while index >= 0:",
      "mutated_line": "while index == 0:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index == 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "subtree_sizes[parents[node]] += subtree_sizes[node]",
      "mutated_line": "subtree_sizes[parents[node]] -= subtree_sizes[node]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] -= subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum -= weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum -= weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "index -= 1",
      "mutated_line": "index += 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index += 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 * k - 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k - 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 * k * 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k * 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counts[a] += 1",
      "mutated_line": "counts[a] += 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 2\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counts[a] += 1",
      "mutated_line": "counts[a] += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 0\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counts[a] += 1",
      "mutated_line": "counts[a] += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 0\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "counts[a] += 1",
      "mutated_line": "counts[a] += -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += -1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[b] += 1",
      "mutated_line": "counts[b] += 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 2\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[b] += 1",
      "mutated_line": "counts[b] += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 0\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[b] += 1",
      "mutated_line": "counts[b] += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 0\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "counts[b] += 1",
      "mutated_line": "counts[b] += -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += -1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 * k - 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k - 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 * k * 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k * 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 * k - 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k - 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 * k * 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k * 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * (2 / k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 / k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * (2 + k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 + k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * 2 ** k",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * 2 ** k\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "head, tail = 0, 0",
      "mutated_line": "(head, tail) = (1, 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (1, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "head, tail = 0, 0",
      "mutated_line": "(head, tail) = (-1, 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (-1, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "head, tail = 0, 0",
      "mutated_line": "(head, tail) = (1, 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (1, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "head, tail = 0, 0",
      "mutated_line": "(head, tail) = (0, 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 1)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "head, tail = 0, 0",
      "mutated_line": "(head, tail) = (0, -1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, -1)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "head, tail = 0, 0",
      "mutated_line": "(head, tail) = (0, 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 1)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "head += 1",
      "mutated_line": "head += 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 2\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "head += 1",
      "mutated_line": "head += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 0\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "head += 1",
      "mutated_line": "head += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 0\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "head += 1",
      "mutated_line": "head += -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += -1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 * k - 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k - 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 * k * 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k * 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "index = len(queue) - 1",
      "mutated_line": "index = len(queue) - 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 2\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "index = len(queue) - 1",
      "mutated_line": "index = len(queue) - 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 0\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "index = len(queue) - 1",
      "mutated_line": "index = len(queue) - 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 0\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "index = len(queue) - 1",
      "mutated_line": "index = len(queue) - -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - -1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while index >= 0:",
      "mutated_line": "while index >= 1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 1:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while index >= 0:",
      "mutated_line": "while index >= -1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= -1:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "while index >= 0:",
      "mutated_line": "while index >= 1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 1:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if subtree_sizes[node] & 1:",
      "mutated_line": "if subtree_sizes[node] | 1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] | 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "minimum += weights[node]",
      "mutated_line": "minimum -= weights[node]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum -= weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] / min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] / min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] + min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] + min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] ** min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] ** min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "index -= 1",
      "mutated_line": "index -= 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 2\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "index -= 1",
      "mutated_line": "index -= 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 0\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "index -= 1",
      "mutated_line": "index -= 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 0\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "index -= 1",
      "mutated_line": "index -= -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= -1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [1] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [-1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [-1] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [1] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 / k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 / k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 + k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 + k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 ** k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 ** k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 * k + 2)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 2)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 0)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 0)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (2 * k + -1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + -1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [1] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [-1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [-1] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [1] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 / k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 / k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 + k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 + k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 ** k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 ** k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 * k + 2)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 2)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 0)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 0)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (2 * k + -1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + -1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [1] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [-1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [-1] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [1] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 / k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 / k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 + k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 + k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 ** k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 ** k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 * k + 2)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 2)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 0)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 0)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (2 * k + -1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + -1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [1] * (2 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [1] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [-1] * (2 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [-1] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [1] * (2 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [1] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * (3 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (3 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * (1 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (1 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * (0 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (0 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * (1 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (1 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue = [0] * (2 * k)",
      "mutated_line": "queue = [0] * (-2 * k)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (-2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if parents[child] < 1:",
      "mutated_line": "if parents[child] <= 1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] <= 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if parents[child] < 1:",
      "mutated_line": "if parents[child] >= 1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] >= 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if parents[child] < 1:",
      "mutated_line": "if parents[child] != 1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] != 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "tail += 1",
      "mutated_line": "tail -= 1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail -= 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [2] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [2] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [0] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [0] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [0] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [0] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [-1] * (2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [-1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 / k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 / k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 + k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 + k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 ** k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 ** k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 * k + 2)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 2)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 0)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 * k + 0)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 0)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (2 * k + -1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + -1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if subtree_sizes[node] & 1:",
      "mutated_line": "if subtree_sizes[node] & 2:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 2:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if subtree_sizes[node] & 1:",
      "mutated_line": "if subtree_sizes[node] & 0:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 0:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if subtree_sizes[node] & 1:",
      "mutated_line": "if subtree_sizes[node] & 0:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 0:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if subtree_sizes[node] & 1:",
      "mutated_line": "if subtree_sizes[node] & -1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & -1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (3 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (3 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (1 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (0 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (0 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (1 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "counts = [0] * (2 * k + 1)",
      "mutated_line": "counts = [0] * (-2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (-2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 * k - 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k - 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 * k * 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k * 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (3 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (3 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (1 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (0 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (0 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (1 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "parents = [0] * (2 * k + 1)",
      "mutated_line": "parents = [0] * (-2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (-2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (3 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (3 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (1 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (0 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (0 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (1 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "weights = [0] * (2 * k + 1)",
      "mutated_line": "weights = [0] * (-2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (-2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if parents[child] < 1:",
      "mutated_line": "if parents[child] < 2:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 2:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if parents[child] < 1:",
      "mutated_line": "if parents[child] < 0:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 0:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if parents[child] < 1:",
      "mutated_line": "if parents[child] < 0:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 0:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if parents[child] < 1:",
      "mutated_line": "if parents[child] < -1:",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < -1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tail += 1",
      "mutated_line": "tail += 2",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 2\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tail += 1",
      "mutated_line": "tail += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 0\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tail += 1",
      "mutated_line": "tail += 0",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 0\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tail += 1",
      "mutated_line": "tail += -1",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += -1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (3 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (3 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (1 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (0 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (0 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (1 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (1 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "subtree_sizes = [1] * (2 * k + 1)",
      "mutated_line": "subtree_sizes = [1] * (-2 * k + 1)",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (-2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k + subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k + subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k * subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k * subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 / k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 / k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 + k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 + k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 ** k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 ** k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 * k + 2)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 2)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 * k + 0)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 0)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 * k + 0)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 0)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(2 * k + -1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + -1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 2 / k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 / k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 2 + k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 + k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 2 ** k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 ** k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(3 * k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(3 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(1 * k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(1 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(0 * k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(0 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(1 * k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(1 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adjacencies = [list() for _ in range(2 * k + 1)]",
      "mutated_line": "adjacencies = [list() for _ in range(-2 * k + 1)]",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(-2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 3 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 3 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 1 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 1 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 0 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 0 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], 1 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], 1 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "maximum += weights[node] * min(subtree_sizes[node], 2 * k - subtree_sizes[node])",
      "mutated_line": "maximum += weights[node] * min(subtree_sizes[node], -2 * k - subtree_sizes[node])",
      "code": "def calculate_soulmate_distances(t, test_cases):\n    results = []\n    for test_case in test_cases:\n        (k, roads) = test_case\n        counts = [0] * (2 * k + 1)\n        adjacencies = [list() for _ in range(2 * k + 1)]\n        for (a, b, weight) in roads:\n            counts[a] += 1\n            counts[b] += 1\n            adjacencies[a].append((b, weight))\n            adjacencies[b].append((a, weight))\n        parents = [0] * (2 * k + 1)\n        weights = [0] * (2 * k + 1)\n        root = 1\n        parents[root] = root\n        queue = [0] * (2 * k)\n        (head, tail) = (0, 0)\n        queue[tail] = root\n        tail += 1\n        while head < tail:\n            node = queue[head]\n            for (child, weight) in adjacencies[node]:\n                if parents[child] < 1:\n                    parents[child] = node\n                    weights[child] = weight\n                    queue[tail] = child\n                    tail += 1\n            head += 1\n        subtree_sizes = [1] * (2 * k + 1)\n        minimum = maximum = 0\n        index = len(queue) - 1\n        while index >= 0:\n            node = queue[index]\n            subtree_sizes[parents[node]] += subtree_sizes[node]\n            if subtree_sizes[node] & 1:\n                minimum += weights[node]\n            maximum += weights[node] * min(subtree_sizes[node], -2 * k - subtree_sizes[node])\n            index -= 1\n        results.append((minimum, maximum))\n    return results"
    }
  ]
}