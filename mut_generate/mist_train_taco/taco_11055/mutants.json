{
  "task_id": "taco_11055",
  "entry_point": "is_satisfiable",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = False",
      "mutated_line": "ans = True",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = True\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "f = True",
      "mutated_line": "f = False",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = False\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "f = e.split('&')",
      "mutated_line": "f = e.split('')",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if t == '~':",
      "mutated_line": "if t != '~':",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t != '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t in dic or dic[t] + pm == 0:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic or dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "exp = list(expression.split('|'))",
      "mutated_line": "exp = list(expression.split(''))",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split(''))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = True",
      "mutated_line": "ans = False",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = False\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(pm, t) = (1, x[0])",
      "mutated_line": "(pm, t) = (2, x[0])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (2, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(pm, t) = (1, x[0])",
      "mutated_line": "(pm, t) = (0, x[0])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (0, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(pm, t) = (1, x[0])",
      "mutated_line": "(pm, t) = (0, x[0])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (0, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(pm, t) = (1, x[0])",
      "mutated_line": "(pm, t) = (-1, x[0])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (-1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if t == '~':",
      "mutated_line": "if t == '':",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t not in dic and dic[t] + pm == 0:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t not in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t in dic and dic[t] + pm != 0:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm != 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "f = False",
      "mutated_line": "f = True",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = True\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(pm, t) = (1, x[0])",
      "mutated_line": "(pm, t) = (1, x[1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[1])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(pm, t) = (1, x[0])",
      "mutated_line": "(pm, t) = (1, x[-1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[-1])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(pm, t) = (1, x[0])",
      "mutated_line": "(pm, t) = (1, x[1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[1])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (+1, x[1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (+1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t in dic and dic[t] - pm == 0:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] - pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t in dic and dic[t] * pm == 0:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] * pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t in dic and dic[t] + pm == 1:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 1:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t in dic and dic[t] + pm == -1:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == -1:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t in dic and dic[t] + pm == 0:",
      "mutated_line": "if t in dic and dic[t] + pm == 1:",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 1:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[2:-1]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[2:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[0:-1]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[0:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[0:-1]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[0:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[-1:-1]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[-1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[1:+1]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:+1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (-2, x[1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-2, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (-0, x[1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-0, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (-0, x[1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-0, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (--1, x[1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (--1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (-1, x[2])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[2])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (-1, x[0])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[0])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (-1, x[0])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[0])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(pm, t) = (-1, x[1])",
      "mutated_line": "(pm, t) = (-1, x[-1])",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[-1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-1]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[1:-2]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-2]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[1:-0]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-0]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[1:-0]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:-0]):\n            ans = True\n            break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if clause(e[1:-1]):",
      "mutated_line": "if clause(e[1:--1]):",
      "code": "def is_satisfiable(expression: str) -> bool:\n    \"\"\"\n    Determines if the given logical expression in additive canonical form is satisfiable.\n\n    Parameters:\n    expression (str): A string representing the logical expression in additive canonical form.\n\n    Returns:\n    bool: True if the expression is satisfiable, False otherwise.\n    \"\"\"\n\n    def clause(e: str) -> bool:\n        \"\"\"\n        Checks if a single clause is satisfiable.\n\n        Parameters:\n        e (str): A string representing a single clause.\n\n        Returns:\n        bool: True if the clause is satisfiable, False otherwise.\n        \"\"\"\n        f = True\n        dic = {}\n        f = e.split('&')\n        for x in f:\n            (pm, t) = (1, x[0])\n            if t == '~':\n                (pm, t) = (-1, x[1])\n            if t in dic and dic[t] + pm == 0:\n                f = False\n            dic[t] = pm\n        return f\n    exp = list(expression.split('|'))\n    ans = False\n    for e in exp:\n        if clause(e[1:--1]):\n            ans = True\n            break\n    return ans"
    }
  ]
}