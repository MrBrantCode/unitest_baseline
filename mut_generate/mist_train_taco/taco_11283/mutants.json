{
  "task_id": "taco_11283",
  "entry_point": "minimum_quarantine_stations",
  "mutant_count": 122,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 * 9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 * 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 + 9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 + 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if res < INF:",
      "mutated_line": "if res <= INF:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res <= INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if res < INF:",
      "mutated_line": "if res >= INF:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res >= INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if res < INF:",
      "mutated_line": "if res != INF:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res != INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 11 ** 9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 11 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 9 ** 9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 9 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 0 ** 9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 0 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 1 ** 9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 1 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = -10 ** 9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = -10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 10",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 10\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 8",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 8\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 0\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 1\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "INF = 10 ** 9",
      "mutated_line": "INF = 10 ** -9",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** -9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if i == N:",
      "mutated_line": "if i != N:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i != N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if c + len(e1) <= K:",
      "mutated_line": "if c + len(e1) < K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) < K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if c + len(e1) <= K:",
      "mutated_line": "if c + len(e1) > K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) > K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if c + len(e1) <= K:",
      "mutated_line": "if c + len(e1) == K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) == K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 or c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 or c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(1, [0] * N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(1, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(-1, [0] * N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(-1, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(1, [0] * N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(1, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [0] / N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] / N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [0] + N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] + N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [0] ** N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] ** N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [0] * N, 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 1)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [0] * N, -1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, -1)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [0] * N, 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 1)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return \"Impossible\"",
      "mutated_line": "return ''",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return ''"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b + 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b + 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b * 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b * 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a + 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a + 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a * 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a * 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "I.sort(key=D.__getitem__, reverse=True)",
      "mutated_line": "I.sort(key=D.__getitem__, reverse=False)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=False)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if c + len(e1) <= K:",
      "mutated_line": "if c - len(e1) <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c - len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if c + len(e1) <= K:",
      "mutated_line": "if c * len(e1) <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c * len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "k = i + 1",
      "mutated_line": "k = i - 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i - 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "k = i + 1",
      "mutated_line": "k = i * 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i * 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k < N or state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N or state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k -= 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) >= 1 and c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) >= 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) <= 1 and c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) <= 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) != 1 and c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) != 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c + 1 < K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 < K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c + 1 > K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 > K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c + 1 == K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 == K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "state[v] = 1",
      "mutated_line": "state[v] = 2",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 2\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "state[v] = 1",
      "mutated_line": "state[v] = 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 0\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "state[v] = 1",
      "mutated_line": "state[v] = 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 0\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "state[v] = 1",
      "mutated_line": "state[v] = -1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = -1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k < N or state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N or state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k -= 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "state[v] = 0",
      "mutated_line": "state[v] = 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 1\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "state[v] = 0",
      "mutated_line": "state[v] = -1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = -1\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "state[v] = 0",
      "mutated_line": "state[v] = 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 1\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - 2)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 2)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 0)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 0)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 1].append(b - -1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - -1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - 2)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 2)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 0)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 0)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 1].append(a - -1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - -1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "state[w] = 1",
      "mutated_line": "state[w] = 2",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 2\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "state[w] = 1",
      "mutated_line": "state[w] = 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 0\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "state[w] = 1",
      "mutated_line": "state[w] = 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 0\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "state[w] = 1",
      "mutated_line": "state[w] = -1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = -1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k = i + 1",
      "mutated_line": "k = i + 2",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 2\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k = i + 1",
      "mutated_line": "k = i + 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 0\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k = i + 1",
      "mutated_line": "k = i + 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 0\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "k = i + 1",
      "mutated_line": "k = i + -1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + -1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k <= N and state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k <= N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k >= N and state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k >= N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k != N and state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k != N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 2\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 0\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 0\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += -1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "state[w] = 0",
      "mutated_line": "state[w] = 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 1\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "state[w] = 0",
      "mutated_line": "state[w] = -1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = -1\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "state[w] = 0",
      "mutated_line": "state[w] = 1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 1\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 2 and c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 2 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 0 and c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 0 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 0 and c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 0 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > -1 and c + 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > -1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c - 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c - 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c * 1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c * 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k <= N and state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k <= N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k >= N and state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k >= N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "while k < N and state[I[k]]:",
      "mutated_line": "while k != N and state[I[k]]:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k != N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 2\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 0\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 0\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += -1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [1] * N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [1] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [-1] * N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [-1] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res = dfs(0, [0] * N, 0)",
      "mutated_line": "res = dfs(0, [1] * N, 0)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [1] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a + 1].append(b - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a + 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a * 1].append(b - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a * 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b + 1].append(a - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b + 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b * 1].append(a - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b * 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res = min(res, dfs(k, state, c + len(e1)))",
      "mutated_line": "res = min(res, dfs(k, state, c - len(e1)))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c - len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res = min(res, dfs(k, state, c + len(e1)))",
      "mutated_line": "res = min(res, dfs(k, state, c * len(e1)))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c * len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c + 2 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 2 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c + 0 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 0 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c + 0 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 0 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if len(e1) > 1 and c + 1 <= K:",
      "mutated_line": "if len(e1) > 1 and c + -1 <= K:",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + -1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, dfs(k, state, c + 1))",
      "mutated_line": "res = min(res, dfs(k, state, c - 1))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c - 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "res = min(res, dfs(k, state, c + 1))",
      "mutated_line": "res = min(res, dfs(k, state, c * 1))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c * 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 2].append(b - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 2].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 0].append(b - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 0].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - 0].append(b - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 0].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[a - 1].append(b - 1)",
      "mutated_line": "G[a - -1].append(b - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - -1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 2].append(a - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 2].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 0].append(a - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 0].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - 0].append(a - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 0].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "G[b - 1].append(a - 1)",
      "mutated_line": "G[b - -1].append(a - 1)",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - -1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = min(res, dfs(k, state, c + 1))",
      "mutated_line": "res = min(res, dfs(k, state, c + 2))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 2))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = min(res, dfs(k, state, c + 1))",
      "mutated_line": "res = min(res, dfs(k, state, c + 0))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 0))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = min(res, dfs(k, state, c + 1))",
      "mutated_line": "res = min(res, dfs(k, state, c + 0))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + 0))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "res = min(res, dfs(k, state, c + 1))",
      "mutated_line": "res = min(res, dfs(k, state, c + -1))",
      "code": "from collections import deque\nimport sys\n\ndef minimum_quarantine_stations(N, M, K, ocean_liners):\n    G = [[] for _ in range(N)]\n    for (a, b) in ocean_liners:\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n    D = list(map(len, G))\n    I = list(range(N))\n    I.sort(key=D.__getitem__, reverse=True)\n    INF = 10 ** 9\n\n    def dfs(i, state, c):\n        if i == N:\n            return c\n        v = I[i]\n        res = INF\n        e1 = []\n        for w in G[v]:\n            if state[w]:\n                continue\n            e1.append(w)\n        if c + len(e1) <= K:\n            for w in e1:\n                state[w] = 1\n            k = i + 1\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + len(e1)))\n            for w in e1:\n                state[w] = 0\n        if len(e1) > 1 and c + 1 <= K:\n            state[v] = 1\n            k = i\n            while k < N and state[I[k]]:\n                k += 1\n            res = min(res, dfs(k, state, c + -1))\n            state[v] = 0\n        return res\n    res = dfs(0, [0] * N, 0)\n    if res < INF:\n        return res\n    else:\n        return 'Impossible'"
    }
  ]
}