{
  "task_id": "taco_12812",
  "entry_point": "generate_minimal_lexicographical_string",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 'a' <= initial_state[i] <= 'z':",
      "mutated_line": "if 'a' < initial_state[i] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' < initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 'a' <= initial_state[i] <= 'z':",
      "mutated_line": "if 'a' > initial_state[i] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' > initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if 'a' <= initial_state[i] <= 'z':",
      "mutated_line": "if 'a' == initial_state[i] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' == initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 'a' <= initial_state[i] <= 'z':",
      "mutated_line": "if '' <= initial_state[i] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if '' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if 'a' <= initial_state[i] <= 'z':",
      "mutated_line": "if 'a' <= initial_state[i] <= '':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= '':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 'a' <= initial_state[neighbor] <= 'z':",
      "mutated_line": "if 'a' < initial_state[neighbor] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' < initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 'a' <= initial_state[neighbor] <= 'z':",
      "mutated_line": "if 'a' > initial_state[neighbor] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' > initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if 'a' <= initial_state[neighbor] <= 'z':",
      "mutated_line": "if 'a' == initial_state[neighbor] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' == initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "initial_state[i] = chr(min(possible_letters) + ord('a'))",
      "mutated_line": "initial_state[i] = chr(min(possible_letters) - ord('a'))",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) - ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "initial_state[i] = chr(min(possible_letters) + ord('a'))",
      "mutated_line": "initial_state[i] = chr(min(possible_letters) * ord('a'))",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) * ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "minimal_string = ''.join(initial_state)",
      "mutated_line": "minimal_string = 'MUTATED'.join(initial_state)",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = 'MUTATED'.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 'a' <= initial_state[neighbor] <= 'z':",
      "mutated_line": "if '' <= initial_state[neighbor] <= 'z':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if '' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if 'a' <= initial_state[neighbor] <= 'z':",
      "mutated_line": "if 'a' <= initial_state[neighbor] <= '':",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= '':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_letters = {i for i in range(26)}",
      "mutated_line": "possible_letters = {i for i in range(27)}",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(27)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_letters = {i for i in range(26)}",
      "mutated_line": "possible_letters = {i for i in range(25)}",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(25)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_letters = {i for i in range(26)}",
      "mutated_line": "possible_letters = {i for i in range(0)}",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(0)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_letters = {i for i in range(26)}",
      "mutated_line": "possible_letters = {i for i in range(1)}",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(1)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "possible_letters = {i for i in range(26)}",
      "mutated_line": "possible_letters = {i for i in range(-26)}",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(-26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))",
      "mutated_line": "possible_letters.discard(ord(initial_state[neighbor]) + ord('a'))",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) + ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))",
      "mutated_line": "possible_letters.discard(ord(initial_state[neighbor]) * ord('a'))",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) * ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "initial_state[i] = chr(min(possible_letters) + ord('a'))",
      "mutated_line": "initial_state[i] = chr(min(possible_letters) + ord(''))",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))\n        initial_state[i] = chr(min(possible_letters) + ord(''))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "possible_letters.discard(ord(initial_state[neighbor]) - ord('a'))",
      "mutated_line": "possible_letters.discard(ord(initial_state[neighbor]) - ord(''))",
      "code": "def generate_minimal_lexicographical_string(V, E, initial_state, edges):\n    adjacency_list = [[] for _ in range(V)]\n    for (s, t) in edges:\n        adjacency_list[s].append(t)\n        adjacency_list[t].append(s)\n    for i in range(V):\n        if 'a' <= initial_state[i] <= 'z':\n            continue\n        possible_letters = {i for i in range(26)}\n        for neighbor in adjacency_list[i]:\n            if 'a' <= initial_state[neighbor] <= 'z':\n                possible_letters.discard(ord(initial_state[neighbor]) - ord(''))\n        initial_state[i] = chr(min(possible_letters) + ord('a'))\n    minimal_string = ''.join(initial_state)\n    return minimal_string"
    }
  ]
}