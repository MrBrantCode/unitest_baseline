{
  "task_id": "taco_10893",
  "entry_point": "stir",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000000.0 - 7)",
      "code": "import numpy as np\nmod = int(1000000000.0 - 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000000.0 * 7)",
      "code": "import numpy as np\nmod = int(1000000000.0 * 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if st >= en:",
      "mutated_line": "if st > en:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st > en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if st >= en:",
      "mutated_line": "if st < en:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st < en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if st >= en:",
      "mutated_line": "if st == en:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st == en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st + en) / 2",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) / 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st + en) * 2",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) * 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = (n + 1) / p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) / p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = (n + 1) * p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) * p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while n > 0:",
      "mutated_line": "while n >= 0:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n >= 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while n > 0:",
      "mutated_line": "while n <= 0:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n <= 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while n > 0:",
      "mutated_line": "while n != 0:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n != 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000001.0 + 7)",
      "code": "import numpy as np\nmod = int(1000000001.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(999999999.0 + 7)",
      "code": "import numpy as np\nmod = int(999999999.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(0 + 7)",
      "code": "import numpy as np\nmod = int(0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1 + 7)",
      "code": "import numpy as np\nmod = int(1 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(-1000000000.0 + 7)",
      "code": "import numpy as np\nmod = int(-1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000000.0 + 8)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 8)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000000.0 + 6)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 6)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000000.0 + 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 0)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000000.0 + 1)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 1)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = int(1000000000.0 + 7)",
      "mutated_line": "mod = int(1000000000.0 + -7)",
      "code": "import numpy as np\nmod = int(1000000000.0 + -7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st - en) // 2",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st - en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = st * en // 2",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = st * en // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st + en) // 3",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 3\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st + en) // 1",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 1\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st + en) // 0",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 0\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st + en) // 1",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 1\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "m = (st + en) // 2",
      "mutated_line": "m = (st + en) // -2",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // -2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p != p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p != p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 2 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 2 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 0 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 0 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 0 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 0 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = -1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = -1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = (n - 1) // p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n - 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = n * 1 // p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = n * 1 // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 1:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while n > 0:",
      "mutated_line": "while n > -1:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > -1:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 1:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return [1, en]",
      "mutated_line": "return [2, en]",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [2, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return [1, en]",
      "mutated_line": "return [0, en]",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [0, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return [1, en]",
      "mutated_line": "return [0, en]",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [0, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return [1, en]",
      "mutated_line": "return [-1, en]",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [-1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))",
      "mutated_line": "ret = np.polymul(stir(p, st, m), stir(p, m - 1, en))",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m - 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))",
      "mutated_line": "ret = np.polymul(stir(p, st, m), stir(p, m * 1, en))",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m * 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n * p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n * p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n + p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n + p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p + 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p + 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p * 1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p * 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) == 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) == 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = (n + 2) // p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 2) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = (n + 0) // p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 0) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = (n + 0) // p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 0) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "n = (n + 1) // p",
      "mutated_line": "n = (n + -1) // p",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + -1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + 1) * mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) * mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + 1) + mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) + mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + 1) % mod, n / p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n / p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + 1) % mod, n * p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n * p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))",
      "mutated_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 2, en))",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 2, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))",
      "mutated_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 0, en))",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 0, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))",
      "mutated_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 0, en))",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 0, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))",
      "mutated_line": "ret = np.polymul(stir(p, st, m), stir(p, m + -1, en))",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + -1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 2 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 2 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 0 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 0 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 0 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 0 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - -1 else np.sum(stir(p, 1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - -1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 1)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 1)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != -1)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != -1)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 1)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 1)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst / (n % p + 1) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst / (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = ((nst + (n % p + 1)) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = ((nst + (n % p + 1)) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst ** (n % p + 1) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst ** (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 2, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 2, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 0, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 0, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 0, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 0, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, -1, n % p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, -1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n * p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n * p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)",
      "mutated_line": "nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n + p) != 0)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n + p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p - 1) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p - 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p * 1) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p * 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n * p + 1) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n * p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n + p + 1) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n + p + 1) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + 2) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 2) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + 0) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 0) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + 0) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + 0) % mod, n // p)\n    return nst"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(nst, n) = (nst * (n % p + 1) % mod, n // p)",
      "mutated_line": "(nst, n) = (nst * (n % p + -1) % mod, n // p)",
      "code": "import numpy as np\nmod = int(1000000000.0 + 7)\n\ndef stir(p, st, en):\n    if st >= en:\n        return [1, en]\n    m = (st + en) // 2\n    ret = np.polymul(stir(p, st, m), stir(p, m + 1, en))\n    return np.mod(ret, p)\n\ndef count_k_subsets_not_divisible_by_p(n, p):\n    nst = 1 if n % p == p - 1 else np.sum(stir(p, 1, n % p) != 0)\n    n = (n + 1) // p\n    while n > 0:\n        (nst, n) = (nst * (n % p + -1) % mod, n // p)\n    return nst"
    }
  ]
}