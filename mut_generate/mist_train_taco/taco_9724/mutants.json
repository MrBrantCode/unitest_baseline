{
  "task_id": "taco_9724",
  "entry_point": "can_draw_snakes",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if '.' in pos:",
      "mutated_line": "if '.' not in pos:",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' not in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if [''.join(s) for s in C] == grid:",
      "mutated_line": "return (True, moves)",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] != grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if '.' in pos:",
      "mutated_line": "if '' in pos:",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "del pos['.']",
      "mutated_line": "del pos['']",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [list('.' * m) for _ in range(n)]",
      "mutated_line": "C = [list('.' / m) for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' / m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [list('.' * m) for _ in range(n)]",
      "mutated_line": "C = [list('.' + m) for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' + m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "C = [list('.' * m) for _ in range(n)]",
      "mutated_line": "C = [list('.' ** m) for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' ** m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(98, ord(mxx) + 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(98, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(96, ord(mxx) + 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(96, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(0, ord(mxx) + 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(0, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(1, ord(mxx) + 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(1, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(-97, ord(mxx) + 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(-97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(97, ord(mxx) - 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) - 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(97, ord(mxx) * 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) * 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if c not in pos:",
      "mutated_line": "if c in pos:",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return True, moves",
      "mutated_line": "return (False, moves)",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (False, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return False, []",
      "mutated_line": "return (True, [])",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (True, [])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "C = [list('.' * m) for _ in range(n)]",
      "mutated_line": "C = [list('' * m) for _ in range(n)]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(97, ord(mxx) + 2):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 2):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(97, ord(mxx) + 0):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 0):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(97, ord(mxx) + 0):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 0):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(97, ord(mxx) + 1):",
      "mutated_line": "for i in range(97, ord(mxx) + -1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + -1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[0] != P[0][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] != P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = P[0][0]",
      "mutated_line": "i = P[0][1]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][1]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = P[0][0]",
      "mutated_line": "i = P[0][-1]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][-1]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = P[0][0]",
      "mutated_line": "i = P[0][1]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][1]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(mn, mx + 1):",
      "mutated_line": "for j in range(mn, mx - 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx - 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(mn, mx + 1):",
      "mutated_line": "for j in range(mn, mx * 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx * 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if [''.join(s) for s in C] == grid:",
      "mutated_line": "return (True, moves)",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if ['MUTATED'.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = P[0][0]",
      "mutated_line": "i = P[1][0]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[1][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = P[0][0]",
      "mutated_line": "i = P[-1][0]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[-1][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "i = P[0][0]",
      "mutated_line": "i = P[1][0]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[1][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(mn, mx + 1):",
      "mutated_line": "for j in range(mn, mx + 2):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 2):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(mn, mx + 1):",
      "mutated_line": "for j in range(mn, mx + 0):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 0):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(mn, mx + 1):",
      "mutated_line": "for j in range(mn, mx + 0):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 0):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(mn, mx + 1):",
      "mutated_line": "for j in range(mn, mx + -1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + -1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i - 1, mn + 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i - 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i * 1, mn + 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i * 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn - 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn - 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn * 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn * 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i - 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i - 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i * 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i * 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 1, mx - 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx - 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 1, mx * 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx * 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] != P[0][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] != P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j = P[0][1]",
      "mutated_line": "j = P[0][2]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][2]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j = P[0][1]",
      "mutated_line": "j = P[0][0]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][0]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j = P[0][1]",
      "mutated_line": "j = P[0][0]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][0]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j = P[0][1]",
      "mutated_line": "j = P[0][-1]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][-1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(mn, mx + 1):",
      "mutated_line": "for i in range(mn, mx - 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx - 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(mn, mx + 1):",
      "mutated_line": "for i in range(mn, mx * 1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx * 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[1] == P[0][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[1] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[-1] == P[0][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[-1] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[1] == P[0][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[1] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[0] == P[0][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][1] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[0] == P[0][-1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][-1] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[0] == P[0][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][1] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = min((p[1] for p in P))",
      "mutated_line": "mn = min((p[2] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[2] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = min((p[1] for p in P))",
      "mutated_line": "mn = min((p[0] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = min((p[1] for p in P))",
      "mutated_line": "mn = min((p[0] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = min((p[1] for p in P))",
      "mutated_line": "mn = min((p[-1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[-1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mx = max((p[1] for p in P))",
      "mutated_line": "mx = max((p[2] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[2] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mx = max((p[1] for p in P))",
      "mutated_line": "mx = max((p[0] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[0] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mx = max((p[1] for p in P))",
      "mutated_line": "mx = max((p[0] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[0] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mx = max((p[1] for p in P))",
      "mutated_line": "mx = max((p[-1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[-1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 2, mn + 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 2, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 0, mn + 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 0, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 0, mn + 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 0, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + -1, mn + 1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + -1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 2, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 2, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 0, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 0, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 0, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 0, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + -1, i + 1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + -1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 2, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 2, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 0, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 0, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 0, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 0, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + -1, mx + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + -1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 1, mx + 2))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 2))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 1, mx + 0))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 0))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 1, mx + 0))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 0))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves.append((i + 1, mn + 1, i + 1, mx + 1))",
      "mutated_line": "moves.append((i + 1, mn + 1, i + 1, mx + -1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + -1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j = P[0][1]",
      "mutated_line": "j = P[1][1]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[1][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j = P[0][1]",
      "mutated_line": "j = P[-1][1]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[-1][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "j = P[0][1]",
      "mutated_line": "j = P[1][1]",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[1][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(mn, mx + 1):",
      "mutated_line": "for i in range(mn, mx + 2):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 2):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(mn, mx + 1):",
      "mutated_line": "for i in range(mn, mx + 0):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 0):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(mn, mx + 1):",
      "mutated_line": "for i in range(mn, mx + 0):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 0):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(mn, mx + 1):",
      "mutated_line": "for i in range(mn, mx + -1):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + -1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn - 1, j + 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn - 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn * 1, j + 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn * 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j - 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j - 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j * 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j * 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx - 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx - 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx * 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx * 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 1, j - 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j - 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 1, j * 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j * 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[0] == P[1][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[1][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[0] == P[-1][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[-1][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if all((p[0] == P[0][0] for p in P)):",
      "mutated_line": "if all((p[0] == P[1][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[1][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[2] == P[0][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[2] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[0] == P[0][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[0] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[0] == P[0][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[0] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[-1] == P[0][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[-1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] == P[0][2] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][2] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] == P[0][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][0] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] == P[0][0] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][0] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] == P[0][-1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][-1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mn = min((p[0] for p in P))",
      "mutated_line": "mn = min((p[1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mn = min((p[0] for p in P))",
      "mutated_line": "mn = min((p[-1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[-1] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mn = min((p[0] for p in P))",
      "mutated_line": "mn = min((p[1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mx = max((p[0] for p in P))",
      "mutated_line": "mx = max((p[1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[1] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mx = max((p[0] for p in P))",
      "mutated_line": "mx = max((p[-1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[-1] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "mx = max((p[0] for p in P))",
      "mutated_line": "mx = max((p[1] for p in P))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[1] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 2, j + 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 2, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 0, j + 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 0, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 0, j + 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 0, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + -1, j + 1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + -1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 2, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 2, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 0, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 0, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 0, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 0, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + -1, mx + 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + -1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 2, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 2, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 0, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 0, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 0, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 0, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + -1, j + 1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + -1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 1, j + 2))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 2))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 1, j + 0))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 0))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 1, j + 0))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 0))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "moves.append((mn + 1, j + 1, mx + 1, j + 1))",
      "mutated_line": "moves.append((mn + 1, j + 1, mx + 1, j + -1))",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[0][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + -1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] == P[1][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[1][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] == P[-1][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[-1][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif all((p[1] == P[0][1] for p in P)):",
      "mutated_line": "elif all((p[1] == P[1][1] for p in P)):",
      "code": "from collections import defaultdict\n\ndef can_draw_snakes(n, m, grid):\n    pos = defaultdict(list)\n    for i in range(n):\n        for j in range(m):\n            pos[grid[i][j]].append((i, j))\n    if '.' in pos:\n        del pos['.']\n    C = [list('.' * m) for _ in range(n)]\n    moves = []\n    if pos:\n        mxx = max(pos)\n        for i in range(97, ord(mxx) + 1):\n            c = chr(i)\n            if c not in pos:\n                pos[c] = pos[mxx]\n            P = pos[c]\n            if all((p[0] == P[0][0] for p in P)):\n                mn = min((p[1] for p in P))\n                mx = max((p[1] for p in P))\n                i = P[0][0]\n                for j in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((i + 1, mn + 1, i + 1, mx + 1))\n            elif all((p[1] == P[1][1] for p in P)):\n                mn = min((p[0] for p in P))\n                mx = max((p[0] for p in P))\n                j = P[0][1]\n                for i in range(mn, mx + 1):\n                    C[i][j] = c\n                moves.append((mn + 1, j + 1, mx + 1, j + 1))\n    if [''.join(s) for s in C] == grid:\n        return (True, moves)\n    else:\n        return (False, [])"
    }
  ]
}