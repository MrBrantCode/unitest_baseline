{
  "task_id": "taco_8712",
  "entry_point": "find_max_f_value",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "cnt[num] += 1",
      "mutated_line": "cnt[num] -= 1",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] -= 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "best = -1",
      "mutated_line": "for (count_u, group_u) in count_groups.items():",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = +1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cnt[num] += 1",
      "mutated_line": "cnt[num] += 2",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 2\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cnt[num] += 1",
      "mutated_line": "cnt[num] += 0",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 0\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cnt[num] += 1",
      "mutated_line": "cnt[num] += 0",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 0\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "cnt[num] += 1",
      "mutated_line": "cnt[num] += -1",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += -1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "best = -1",
      "mutated_line": "for (count_u, group_u) in count_groups.items():",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -2\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "best = -1",
      "mutated_line": "for (count_u, group_u) in count_groups.items():",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -0\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "best = -1",
      "mutated_line": "for (count_u, group_u) in count_groups.items():",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -0\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "best = -1",
      "mutated_line": "for (count_u, group_u) in count_groups.items():",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = --1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "a.sort(reverse=True)",
      "mutated_line": "a.sort(reverse=False)",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=False)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if count_u < count_v:",
      "mutated_line": "if count_u <= count_v:",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u <= count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if count_u < count_v:",
      "mutated_line": "if count_u >= count_v:",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u >= count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if count_u < count_v:",
      "mutated_line": "if count_u != count_v:",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u != count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if u != v:",
      "mutated_line": "if u == v:",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u == v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if (u, v) not in bad and (v, u) not in bad:",
      "mutated_line": "if (u, v) not in bad or (v, u) not in bad:",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad or (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if (u, v) not in bad and (v, u) not in bad:",
      "mutated_line": "if (u, v) in bad and (v, u) not in bad:",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if (u, v) not in bad and (v, u) not in bad:",
      "mutated_line": "if (u, v) not in bad and (v, u) in bad:",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "best = max(best, (cnt[u] + cnt[v]) * (u + v))",
      "mutated_line": "best = max(best, (cnt[u] + cnt[v]) / (u + v))",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) / (u + v))\n                            break\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "best = max(best, (cnt[u] + cnt[v]) * (u + v))",
      "mutated_line": "best = max(best, cnt[u] + cnt[v] + (u + v))",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, cnt[u] + cnt[v] + (u + v))\n                            break\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "best = max(best, (cnt[u] + cnt[v]) * (u + v))",
      "mutated_line": "best = max(best, (cnt[u] + cnt[v]) ** (u + v))",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) ** (u + v))\n                            break\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "best = max(best, (cnt[u] + cnt[v]) * (u + v))",
      "mutated_line": "best = max(best, (cnt[u] - cnt[v]) * (u + v))",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] - cnt[v]) * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "best = max(best, (cnt[u] + cnt[v]) * (u + v))",
      "mutated_line": "best = max(best, cnt[u] * cnt[v] * (u + v))",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, cnt[u] * cnt[v] * (u + v))\n                            break\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "best = max(best, (cnt[u] + cnt[v]) * (u + v))",
      "mutated_line": "best = max(best, (cnt[u] + cnt[v]) * (u - v))",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u - v))\n                            break\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "best = max(best, (cnt[u] + cnt[v]) * (u + v))",
      "mutated_line": "best = max(best, (cnt[u] + cnt[v]) * (u * v))",
      "code": "def find_max_f_value(n, m, a, bad_pairs):\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    for num in a:\n        cnt[num] += 1\n    bad = set(bad_pairs)\n    a.sort(reverse=True)\n    count_groups = defaultdict(list)\n    for num in a:\n        count_groups[cnt[num]].append(num)\n    best = -1\n    for (count_u, group_u) in count_groups.items():\n        for (count_v, group_v) in count_groups.items():\n            if count_u < count_v:\n                continue\n            for u in group_u:\n                for v in group_v:\n                    if u != v:\n                        if (u, v) not in bad and (v, u) not in bad:\n                            best = max(best, (cnt[u] + cnt[v]) * (u * v))\n                            break\n    return best"
    }
  ]
}