{
  "task_id": "taco_2178",
  "entry_point": "determine_winner_and_move",
  "mutant_count": 144,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] / (len(s) + 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] / (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] + (len(s) + 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] + (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] ** (len(s) + 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] ** (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DP[0] = 0",
      "mutated_line": "DP[0] = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 1\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DP[0] = 0",
      "mutated_line": "DP[0] = -1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = -1\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DP[0] = 0",
      "mutated_line": "DP[0] = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 1\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if Grundy(s) != 0:",
      "mutated_line": "if Grundy(s) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) == 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] * (len(s) - 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) - 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] * (len(s) * 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) * 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DP[0] = 0",
      "mutated_line": "DP[1] = 0",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[1] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DP[0] = 0",
      "mutated_line": "DP[-1] = 0",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[-1] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "DP[0] = 0",
      "mutated_line": "DP[1] = 0",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[1] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(2, len(s) + 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(2, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(0, len(s) + 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(0, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(0, len(s) + 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(0, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(-1, len(s) + 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(-1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(1, len(s) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) - 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(1, len(s) * 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) * 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mex = 0",
      "mutated_line": "mex = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 1\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mex = 0",
      "mutated_line": "mex = -1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = -1\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "mex = 0",
      "mutated_line": "mex = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 1\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while mex in s_set:",
      "mutated_line": "while mex not in s_set:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex not in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "mex += 1",
      "mutated_line": "mex -= 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex -= 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if S in memo2:",
      "mutated_line": "if S not in memo2:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S not in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 1\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = -1\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 1\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consec = 0",
      "mutated_line": "consec = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 1\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consec = 0",
      "mutated_line": "consec = -1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = -1\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "consec = 0",
      "mutated_line": "consec = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 1\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if Grundy(s) != 0:",
      "mutated_line": "if Grundy(s) != 1:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 1:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if Grundy(s) != 0:",
      "mutated_line": "if Grundy(s) != -1:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != -1:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if Grundy(s) != 0:",
      "mutated_line": "if Grundy(s) != 1:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 1:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [1] * (len(s) + 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [1] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [-1] * (len(s) + 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [-1] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [1] * (len(s) + 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [1] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] * (len(s) + 2)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 2)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] * (len(s) + 0)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 0)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] * (len(s) + 0)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 0)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "DP = [0] * (len(s) + 1)",
      "mutated_line": "DP = [0] * (len(s) + -1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + -1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(1, len(s) + 2):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 2):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(1, len(s) + 0):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 0):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(1, len(s) + 0):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 0):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(s) + 1):",
      "mutated_line": "for j in range(1, len(s) + -1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + -1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mex += 1",
      "mutated_line": "mex += 2",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 2\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mex += 1",
      "mutated_line": "mex += 0",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 0\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mex += 1",
      "mutated_line": "mex += 0",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 0\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "mex += 1",
      "mutated_line": "mex += -1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += -1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(2, len(S) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(2, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(0, len(S) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(0, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(0, len(S) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(0, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(-1, len(S) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(-1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(1, len(S) + 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) + 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(1, len(S) * 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) * 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 1] != S[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] != S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "consec += 1",
      "mutated_line": "consec -= 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec -= 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(2, len(s) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(2, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(0, len(s) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(0, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(0, len(s) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(0, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(-1, len(s) - 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(-1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(1, len(s) + 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) + 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(1, len(s) * 1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) * 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 1] != s[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] != s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return (\"First\", None)  # This line should never be reached if there's a winning move",
      "mutated_line": "return ('', None)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return (\"Second\", None)",
      "mutated_line": "return ('', None)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('', None)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] | DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] | DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(1, len(S) - 2):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 2):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(1, len(S) - 0):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 0):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(1, len(S) - 0):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 0):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(1, len(S) - 1):",
      "mutated_line": "for i in range(1, len(S) - -1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - -1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "consec += 1",
      "mutated_line": "consec += 2",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 2\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "consec += 1",
      "mutated_line": "consec += 0",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 0\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "consec += 1",
      "mutated_line": "consec += 0",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 0\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "consec += 1",
      "mutated_line": "consec += -1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += -1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "consec = 0",
      "mutated_line": "consec = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 1\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "consec = 0",
      "mutated_line": "consec = -1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = -1\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "consec = 0",
      "mutated_line": "consec = 1",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 1\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(1, len(s) - 2):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 2):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(1, len(s) - 0):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 0):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(1, len(s) - 0):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 0):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for i in range(1, len(s) - 1):",
      "mutated_line": "for i in range(1, len(s) - -1):",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - -1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) != 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) != 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i + 1] == S[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i + 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i * 1] == S[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i * 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 1] == S[i - 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i - 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 1] == S[i * 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i * 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i + 1] == s[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i + 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i * 1] == s[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i * 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 1] == s[i - 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i - 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 1] == s[i * 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i * 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) | Grundy(s[i + 1:]) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) | Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 1:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 1:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == -1:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == -1:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 1:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 1:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 2] == S[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 2] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 0] == S[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 0] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 0] == S[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 0] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - -1] == S[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - -1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 1] == S[i + 2]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 2]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 1] == S[i + 0]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 0]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 1] == S[i + 0]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 0]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if S[i - 1] == S[i + 1]:",
      "mutated_line": "if S[i - 1] == S[i + -1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + -1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 2] == s[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 2] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 0] == s[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 0] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 0] == s[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 0] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - -1] == s[i + 1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - -1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 1] == s[i + 2]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 2]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 1] == s[i + 0]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 0]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 1] == s[i + 0]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 0]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if s[i - 1] == s[i + 1]:",
      "mutated_line": "if s[i - 1] == s[i + -1]:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + -1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (\"First\", i + 1)",
      "mutated_line": "return ('', i + 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (\"First\", i + 1)",
      "mutated_line": "return ('First', i - 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i - 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (\"First\", i + 1)",
      "mutated_line": "return ('First', i * 1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i * 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(1, i - 1)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(1, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(-1, i - 1)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(-1, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(1, i - 1)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(1, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i + 1)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i + 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i * 1)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i * 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(1, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(1, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(-1, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(-1, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(1, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(1, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i + 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i + 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, (j - i) * 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, (j - i) * 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (\"First\", i + 1)",
      "mutated_line": "return ('First', i + 2)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 2)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (\"First\", i + 1)",
      "mutated_line": "return ('First', i + 0)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 0)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (\"First\", i + 1)",
      "mutated_line": "return ('First', i + 0)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 0)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (\"First\", i + 1)",
      "mutated_line": "return ('First', i + -1)",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + -1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 2)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 2)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 0)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 0)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 0)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 0)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - -1)] ^ DP[max(0, j - i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - -1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j + i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j + i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j * i - 2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j * i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 3)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 3)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 1)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 1)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 0)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 0)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 1)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 1)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])",
      "mutated_line": "s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - -2)])",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - -2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i - 1:]) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i - 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i * 1:]) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i * 1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + 2:]) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 2:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + 0:]) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 0:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + 0:]) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + 0:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if Grundy(s[:i]) ^ Grundy(s[i + 1:]) == 0:",
      "mutated_line": "if Grundy(s[:i]) ^ Grundy(s[i + -1:]) == 0:",
      "code": "def determine_winner_and_move(s: str) -> tuple:\n    memo = {}\n    DP = [0] * (len(s) + 1)\n    DP[0] = 0\n    for j in range(1, len(s) + 1):\n        s_set = set()\n        for i in range(j):\n            s_set.add(DP[max(0, i - 1)] ^ DP[max(0, j - i - 2)])\n        mex = 0\n        while mex in s_set:\n            mex += 1\n        DP[j] = mex\n    memo2 = {}\n\n    def Grundy(S):\n        if S in memo2:\n            return memo2[S]\n        total = 0\n        consec = 0\n        for i in range(1, len(S) - 1):\n            if S[i - 1] == S[i + 1]:\n                consec += 1\n            else:\n                total ^= DP[consec]\n                consec = 0\n        total ^= DP[consec]\n        memo2[S] = total\n        return total\n    if Grundy(s) != 0:\n        for i in range(1, len(s) - 1):\n            if s[i - 1] == s[i + 1]:\n                if Grundy(s[:i]) ^ Grundy(s[i + -1:]) == 0:\n                    return ('First', i + 1)\n        return ('First', None)\n    else:\n        return ('Second', None)"
    }
  ]
}