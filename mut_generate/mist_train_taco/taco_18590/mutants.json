{
  "task_id": "taco_18590",
  "entry_point": "winning_lines",
  "mutant_count": 70,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if dimension == 1:",
      "mutated_line": "if dimension != 1:",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension != 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return 'No winner'",
      "mutated_line": "return ''",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if dimension == 1:",
      "mutated_line": "if dimension == 2:",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 2:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if dimension == 1:",
      "mutated_line": "if dimension == 0:",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 0:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if dimension == 1:",
      "mutated_line": "if dimension == 0:",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 0:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if dimension == 1:",
      "mutated_line": "if dimension == -1:",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == -1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):",
      "mutated_line": "for (line, idx, val) in product(winning_lines(size, dimension + 1), range(dimension), range(size)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension + 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):",
      "mutated_line": "for (line, idx, val) in product(winning_lines(size, dimension * 1), range(dimension), range(size)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension * 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((+1, 1), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((+1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 2), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 2), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 0), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 0), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 0), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 0), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, -1), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, -1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 1), repeat=dimension + 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension + 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 1), repeat=dimension * 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension * 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(5, 3))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(5, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(3, 3))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(3, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(0, 3))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(0, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(1, 3))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(1, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(-4, 3))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(-4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(4, 4))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 4))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(4, 2))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 2))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(4, 0))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 0))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(4, 1))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 1))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(grid, lines) = ([], winning_lines(4, 3))",
      "mutated_line": "(grid, lines) = ([], winning_lines(4, -3))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, -3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):",
      "mutated_line": "for (line, idx, val) in product(winning_lines(size, dimension - 2), range(dimension), range(size)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 2), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):",
      "mutated_line": "for (line, idx, val) in product(winning_lines(size, dimension - 0), range(dimension), range(size)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 0), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):",
      "mutated_line": "for (line, idx, val) in product(winning_lines(size, dimension - 0), range(dimension), range(size)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 0), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):",
      "mutated_line": "for (line, idx, val) in product(winning_lines(size, dimension - -1), range(dimension), range(size)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - -1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-2, 1), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-2, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-0, 1), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-0, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-0, 1), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-0, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((--1, 1), repeat=dimension - 1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((--1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 1), repeat=dimension - 2):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 2):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 1), repeat=dimension - 0):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 0):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 1), repeat=dimension - 0):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 0):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for dirs in product((-1, 1), repeat=dimension - 1):",
      "mutated_line": "for dirs in product((-1, 1), repeat=dimension - -1):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - -1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line < set(grid[-1::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line < set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line > set(grid[-1::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line > set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line == set(grid[-1::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line == set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))",
      "mutated_line": "lines.add(frozenset({cell[:idx] + (val,) - cell[idx:] for cell in line}))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) - cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))",
      "mutated_line": "lines.add(frozenset({(cell[:idx] + (val,)) * cell[idx:] for cell in line}))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({(cell[:idx] + (val,)) * cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return ''.format('XO'[len(grid) % 2], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return ''.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format(''[len(grid) % 2], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format(''[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format('XO'[len(grid) * 2], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) * 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format('XO'[len(grid) + 2], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) + 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))",
      "mutated_line": "lines.add(frozenset({cell[:idx] - (val,) + cell[idx:] for cell in line}))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] - (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))",
      "mutated_line": "lines.add(frozenset({cell[:idx] * (val,) + cell[idx:] for cell in line}))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] * (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 3], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 3], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 1], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 1], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 0], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 0], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 1], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 1], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))",
      "mutated_line": "return '{} wins after {} moves'.format('XO'[len(grid) % -2], len(grid))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % -2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))",
      "mutated_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] - list(dirs)))))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] - list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))",
      "mutated_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] * list(dirs)))))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] * list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[+1::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[+1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-1::+2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::+2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-2::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-2::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-0::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-0::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-0::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-0::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[--1::-2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[--1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-1::-3]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-3]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-1::-1]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-1]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-1::-0]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-0]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-1::-1]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-1]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if any((line <= set(grid[-1::-2]) for line in lines)):",
      "mutated_line": "if any((line <= set(grid[-1::--2]) for line in lines)):",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::--2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))",
      "mutated_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [2] + list(dirs)))))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [2] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))",
      "mutated_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [0] + list(dirs)))))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [0] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))",
      "mutated_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [0] + list(dirs)))))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [0] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [1] + list(dirs)))))",
      "mutated_line": "lines.add(frozenset(zip(*(range(size)[::d] for d in [-1] + list(dirs)))))",
      "code": "from itertools import product\n\ndef winning_lines(size, dimension):\n    if dimension == 1:\n        return frozenset({frozenset({(n,) for n in range(size)})})\n    lines = set()\n    for (line, idx, val) in product(winning_lines(size, dimension - 1), range(dimension), range(size)):\n        lines.add(frozenset({cell[:idx] + (val,) + cell[idx:] for cell in line}))\n    for dirs in product((-1, 1), repeat=dimension - 1):\n        lines.add(frozenset(zip(*(range(size)[::d] for d in [-1] + list(dirs)))))\n    return lines\n\ndef determine_3d_tic_tac_toe_winner(moves):\n    (grid, lines) = ([], winning_lines(4, 3))\n    for m in moves:\n        grid.append(tuple(m))\n        if any((line <= set(grid[-1::-2]) for line in lines)):\n            return '{} wins after {} moves'.format('XO'[len(grid) % 2], len(grid))\n    return 'No winner'"
    }
  ]
}