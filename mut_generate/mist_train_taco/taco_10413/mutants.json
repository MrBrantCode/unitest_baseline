{
  "task_id": "taco_10413",
  "entry_point": "restore_graph",
  "mutant_count": 126,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(0) >= 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) >= 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(0) <= 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) <= 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(0) != 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) != 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 1\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "now = 0",
      "mutated_line": "now = -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = -1\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "now = 0",
      "mutated_line": "now = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 1\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tf = 1",
      "mutated_line": "tf = 2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 2\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tf = 1",
      "mutated_line": "tf = 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 0\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tf = 1",
      "mutated_line": "tf = 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 0\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "tf = 1",
      "mutated_line": "tf = -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = -1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now + 1 < d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 < d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now + 1 > d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 > d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now + 1 == d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 == d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "now += 1",
      "mutated_line": "now -= 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now -= 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(0) > 2:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 2:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(0) > 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 0:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(0) > 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 0:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(0) > -1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > -1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return +1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "elif 0 not in d:",
      "mutated_line": "elif 0 in d:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now - 1 <= d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now - 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now * 1 <= d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now * 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + 1]) != 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) != 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ii = 0",
      "mutated_line": "ii = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 1\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ii = 0",
      "mutated_line": "ii = -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = -1\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ii = 0",
      "mutated_line": "ii = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 1\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k <= len(f[now + 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k <= len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k >= len(f[now + 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k >= len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k != len(f[now + 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k != len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "now += 1",
      "mutated_line": "now += 2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 2\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "now += 1",
      "mutated_line": "now += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 0\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "now += 1",
      "mutated_line": "now += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 0\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "now += 1",
      "mutated_line": "now += -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += -1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return +1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(1) > 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(1) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(-1) > 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(-1) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if d.count(0) > 1:",
      "mutated_line": "if d.count(1) > 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(1) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -2\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -0\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -0\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return --1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif 0 not in d:",
      "mutated_line": "elif 1 not in d:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 1 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif 0 not in d:",
      "mutated_line": "elif -1 not in d:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif -1 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "elif 0 not in d:",
      "mutated_line": "elif 1 not in d:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 1 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return +1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "prev = [d.index(0)]",
      "mutated_line": "prev = [d.index(1)]",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(1)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "prev = [d.index(0)]",
      "mutated_line": "prev = [d.index(-1)]",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(-1)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "prev = [d.index(0)]",
      "mutated_line": "prev = [d.index(1)]",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(1)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now + 2 <= d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 2 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now + 0 <= d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 0 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now + 0 <= d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 0 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while now + 1 <= d_max:",
      "mutated_line": "while now + -1 <= d_max:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + -1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + 1]) == 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 1:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + 1]) == -1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == -1:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + 1]) == 1:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 1:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tf = 0",
      "mutated_line": "tf = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 1\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tf = 0",
      "mutated_line": "tf = -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = -1\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "tf = 0",
      "mutated_line": "tf = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 1\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll / k < len(f[now + 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll / k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll + k < len(f[now + 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll + k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll ** k < len(f[now + 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll ** k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tf = 0",
      "mutated_line": "tf = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 1\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tf = 0",
      "mutated_line": "tf = -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = -1\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "tf = 0",
      "mutated_line": "tf = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 1\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -2\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -0\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -0\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return --1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -2\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -0\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -0\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return --1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for j in f[now + 1]:",
      "mutated_line": "for j in f[now - 1]:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now - 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for j in f[now + 1]:",
      "mutated_line": "for j in f[now * 1]:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now * 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ch[prev[ii]] < k:",
      "mutated_line": "if ch[prev[ii]] <= k:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] <= k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ch[prev[ii]] < k:",
      "mutated_line": "if ch[prev[ii]] >= k:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] >= k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ch[prev[ii]] < k:",
      "mutated_line": "if ch[prev[ii]] != k:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] != k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "ch[prev[ii]] += 1",
      "mutated_line": "ch[prev[ii]] -= 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] -= 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "ch[j] += 1",
      "mutated_line": "ch[j] -= 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] -= 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "ii += 1",
      "mutated_line": "ii -= 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii -= 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ar.sort(key=lambda x: x[0])",
      "mutated_line": "ar.sort(key=lambda x: x[1])",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[1])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ar.sort(key=lambda x: x[0])",
      "mutated_line": "ar.sort(key=lambda x: x[-1])",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[-1])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ar.sort(key=lambda x: x[0])",
      "mutated_line": "ar.sort(key=lambda x: x[1])",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[1])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now - 1]) == 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now - 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now * 1]) == 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now * 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k < len(f[now - 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now - 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k < len(f[now * 1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now * 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in f[now + 1]:",
      "mutated_line": "for j in f[now + 2]:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 2]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in f[now + 1]:",
      "mutated_line": "for j in f[now + 0]:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 0]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in f[now + 1]:",
      "mutated_line": "for j in f[now + 0]:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 0]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for j in f[now + 1]:",
      "mutated_line": "for j in f[now + -1]:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + -1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ch[prev[ii]] += 1",
      "mutated_line": "ch[prev[ii]] += 2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 2\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ch[prev[ii]] += 1",
      "mutated_line": "ch[prev[ii]] += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 0\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ch[prev[ii]] += 1",
      "mutated_line": "ch[prev[ii]] += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 0\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "ch[prev[ii]] += 1",
      "mutated_line": "ch[prev[ii]] += -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += -1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ch[j] += 1",
      "mutated_line": "ch[j] += 2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 2\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ch[j] += 1",
      "mutated_line": "ch[j] += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 0\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ch[j] += 1",
      "mutated_line": "ch[j] += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 0\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ch[j] += 1",
      "mutated_line": "ch[j] += -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += -1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ii += 1",
      "mutated_line": "ii += 2",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 2\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ii += 1",
      "mutated_line": "ii += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 0\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ii += 1",
      "mutated_line": "ii += 0",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 0\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ii += 1",
      "mutated_line": "ii += -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += -1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tf = 0",
      "mutated_line": "tf = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 1\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tf = 0",
      "mutated_line": "tf = -1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = -1\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "tf = 0",
      "mutated_line": "tf = 1",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 1\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + 2]) == 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 2]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + 0]) == 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 0]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + 0]) == 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 0]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if len(f[now + 1]) == 0:",
      "mutated_line": "if len(f[now + -1]) == 0:",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + -1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k < len(f[now + 2]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 2]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k < len(f[now + 0]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 0]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k < len(f[now + 0]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 0]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ll * k < len(f[now + 1]):",
      "mutated_line": "if ll * k < len(f[now + -1]):",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + -1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] - 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] - 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] * 1, j + 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] * 1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 1, j - 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j - 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 1, j * 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j * 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 2, j + 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 2, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 0, j + 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 0, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 0, j + 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 0, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + -1, j + 1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + -1, j + 1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 1, j + 2))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 2))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 1, j + 0))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 0))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 1, j + 0))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + 0))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edges.append((prev[ii] + 1, j + 1))",
      "mutated_line": "edges.append((prev[ii] + 1, j + -1))",
      "code": "from collections import defaultdict\n\ndef restore_graph(n, k, d):\n    ar = []\n    f = defaultdict(list)\n    ch = defaultdict(int)\n    for i in range(n):\n        ar.append([d[i], i])\n        f[d[i]].append(i)\n    ar.sort(key=lambda x: x[0])\n    if d.count(0) > 1:\n        return -1\n    elif 0 not in d:\n        return -1\n    d_max = max(d)\n    edges = []\n    now = 0\n    prev = [d.index(0)]\n    tf = 1\n    while now + 1 <= d_max:\n        cur = set()\n        if len(f[now + 1]) == 0:\n            tf = 0\n            break\n        ii = 0\n        ll = len(prev)\n        if ll * k < len(f[now + 1]):\n            tf = 0\n            break\n        else:\n            for j in f[now + 1]:\n                if ch[prev[ii]] < k:\n                    ch[prev[ii]] += 1\n                    ch[j] += 1\n                    cur.add(j)\n                    edges.append((prev[ii] + 1, j + -1))\n                    ii += 1\n                    ii %= ll\n                else:\n                    tf = 0\n                    break\n        prev = list(cur)\n        now += 1\n    if not tf:\n        return -1\n    else:\n        return (len(edges), edges)"
    }
  ]
}