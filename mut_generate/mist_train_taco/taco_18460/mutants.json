{
  "task_id": "taco_18460",
  "entry_point": "execute_rs1",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "TOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')",
      "mutated_line": "TOKENIZER = re.compile('')",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = (0, 0)",
      "mutated_line": "pos = (1, 0)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (1, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = (0, 0)",
      "mutated_line": "pos = (-1, 0)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (-1, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = (0, 0)",
      "mutated_line": "pos = (1, 0)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (1, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = (0, 0)",
      "mutated_line": "pos = (0, 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 1)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = (0, 0)",
      "mutated_line": "pos = (0, -1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, -1)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = (0, 0)",
      "mutated_line": "pos = (0, 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 1)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if s == 'F':",
      "mutated_line": "if s != 'F':",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s != 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '1') + len(act) + 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) + 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], (int(n or '1') + len(act)) * 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], (int(n or '1') + len(act)) * 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == 'F':",
      "mutated_line": "if s == '':",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == '':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "grid = '\\r\\n'.join(",
      "mutated_line": "grid = ''.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = ''.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(1, 1), (1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(1, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(-1, 1), (1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(-1, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(1, 1), (1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(1, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 2), (1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 2), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 0), (1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 0), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 0), (1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 0), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, -1), (1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, -1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (2, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (2, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (0, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (0, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (0, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (0, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (-1, 0), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (-1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 1), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 1), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, -1), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, -1), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 1), (0, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 1), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (1, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (1, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (-1, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (-1, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (1, -1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (1, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, +1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, +1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (+1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (+1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 1)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 1)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, -1)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, -1)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 1)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 1)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[1], int(n or '1') + len(act) - 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[1], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[-1], int(n or '1') + len(act) - 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[-1], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[1], int(n or '1') + len(act) - 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[1], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '1') - len(act) - 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') - len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '1') * len(act) - 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') * len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '1') + len(act) - 2)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 2)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '1') + len(act) - 0)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 0)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '1') + len(act) - 0)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 0)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '1') + len(act) - -1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - -1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 / (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 / (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 + (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 + (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate((r % 4) ** (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate((r % 4) ** (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -2), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -2), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -0), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -0), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -0), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -0), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, --1), (-1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, --1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-2, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-2, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-0, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-0, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-0, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-0, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])",
      "mutated_line": "dirs = deque([(0, 1), (1, 0), (0, -1), (--1, 0)])",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (--1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r * 4 * (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r * 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate((r + 4) * (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate((r + 4) * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (-1 * (s == 'R')))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1 * (s == 'R')))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (-1 + (s == 'R')))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1 + (s == 'R')))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join(('MUTATED'.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join(('MUTATED'.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for x in range(miX, maX + 1)",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX - 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX - 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for x in range(miX, maX + 1)",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX * 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX * 1)))\n    return grid"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n and '1') + len(act) - 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n and '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pos = tuple(z + dz for z, dz in zip(pos, dirs[0]))",
      "mutated_line": "pos = tuple((z - dz for (z, dz) in zip(pos, dirs[0])))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z - dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "pos = tuple(z + dz for z, dz in zip(pos, dirs[0]))",
      "mutated_line": "pos = tuple((z * dz for (z, dz) in zip(pos, dirs[0])))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z * dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 5 * (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 5 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 3 * (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 3 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 0 * (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 0 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 1 * (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 1 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % -4 * (-1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % -4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (+1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (+1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (-1) ** (s != 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s != 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) not in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) not in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else '' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else '' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for x in range(miX, maX + 1)",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 2)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 2)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for x in range(miX, maX + 1)",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 0)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 0)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for x in range(miX, maX + 1)",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 0)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 0)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for x in range(miX, maX + 1)",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + -1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + -1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s, r = act[0], int(n or '1') + len(act) - 1",
      "mutated_line": "(s, r) = (act[0], int(n or '') + len(act) - 1)",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (-2) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-2) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (-0) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-0) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (-0) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-0) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (--1) ** (s == 'R'))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (--1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dirs.rotate(r % 4 * (-1) ** (s == 'R'))",
      "mutated_line": "dirs.rotate(r % 4 * (-1) ** (s == ''))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == ''))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY - 1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY - 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY * 1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY * 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 2))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 2))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 0))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 0))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 0))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 0))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "''.join('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))",
      "mutated_line": "grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + -1))) for x in range(miX, maX + 1)))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[0])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + -1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos = tuple(z + dz for z, dz in zip(pos, dirs[0]))",
      "mutated_line": "pos = tuple((z + dz for (z, dz) in zip(pos, dirs[1])))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[1])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos = tuple(z + dz for z, dz in zip(pos, dirs[0]))",
      "mutated_line": "pos = tuple((z + dz for (z, dz) in zip(pos, dirs[-1])))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[-1])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "pos = tuple(z + dz for z, dz in zip(pos, dirs[0]))",
      "mutated_line": "pos = tuple((z + dz for (z, dz) in zip(pos, dirs[1])))",
      "code": "from collections import deque\nimport re\nTOKENIZER = re.compile('(R+|F+|L+)(\\\\d*)')\n\ndef execute_rs1(code: str) -> str:\n    pos = (0, 0)\n    dirs = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\n    seens = {pos}\n    for (act, n) in TOKENIZER.findall(code):\n        (s, r) = (act[0], int(n or '1') + len(act) - 1)\n        if s == 'F':\n            for _ in range(r):\n                pos = tuple((z + dz for (z, dz) in zip(pos, dirs[1])))\n                seens.add(pos)\n        else:\n            dirs.rotate(r % 4 * (-1) ** (s == 'R'))\n    (miX, maX) = (min((x for (x, y) in seens)), max((x for (x, y) in seens)))\n    (miY, maY) = (min((y for (x, y) in seens)), max((y for (x, y) in seens)))\n    grid = '\\r\\n'.join((''.join(('*' if (x, y) in seens else ' ' for y in range(miY, maY + 1))) for x in range(miX, maX + 1)))\n    return grid"
    }
  ]
}