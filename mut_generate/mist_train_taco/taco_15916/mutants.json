{
  "task_id": "taco_15916",
  "entry_point": "count_reachable_cells",
  "mutant_count": 199,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r += 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r += 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c += 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c += 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 2\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 0\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 0\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r -= 1",
      "mutated_line": "r -= -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= -1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 2\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 0\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 0\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c -= 1",
      "mutated_line": "c -= -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= -1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 1\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = -1\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 1\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans -= 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visit[sr][sc] = 1",
      "mutated_line": "visit[sr][sc] = 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 2\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visit[sr][sc] = 1",
      "mutated_line": "visit[sr][sc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 0\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visit[sr][sc] = 1",
      "mutated_line": "visit[sr][sc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 0\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "visit[sr][sc] = 1",
      "mutated_line": "visit[sr][sc] = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = -1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 2\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 0\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 0\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += -1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visit = [[0 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "visit = [[1 for _ in range(m)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[1 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visit = [[0 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "visit = [[-1 for _ in range(m)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[-1 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "visit = [[0 for _ in range(m)] for _ in range(n)]",
      "mutated_line": "visit = [[1 for _ in range(m)] for _ in range(n)]",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[1 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n or maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n or maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 or maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 or maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m or maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m or maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 or maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 or maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 <= n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 <= n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 >= n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 >= n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 != n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 != n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r + 1][c] != '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] != '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 > 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 > 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 < 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 < 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 == 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 == 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r - 1][c] != '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] != '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 <= m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 <= m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 >= m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 >= m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 != m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 != m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c + 1] != '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] != '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 > 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 > 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 < 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 < 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 == 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 == 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c - 1] != '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] != '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if visit[adr][adc] == 1:",
      "mutated_line": "if visit[adr][adc] != 1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] != 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if c == adc:",
      "mutated_line": "if c != adc:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c != adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans -= 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r - 1 < n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r - 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r * 1 < n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r * 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r + 1][c] == '':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r + 1 >= 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r + 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r * 1 >= 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r * 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 1 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 1 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= -1 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= -1 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 1 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 1 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r - 1][c] == '':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c - 1 < m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c - 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c * 1 < m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c * 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c + 1] == '':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c + 1 >= 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c + 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c * 1 >= 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c * 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 1 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 1 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= -1 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= -1 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 1 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 1 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c - 1] == '':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if visit[adr][adc] == 1:",
      "mutated_line": "if visit[adr][adc] == 2:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 2:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if visit[adr][adc] == 1:",
      "mutated_line": "if visit[adr][adc] == 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 0:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if visit[adr][adc] == 1:",
      "mutated_line": "if visit[adr][adc] == 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 0:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if visit[adr][adc] == 1:",
      "mutated_line": "if visit[adr][adc] == -1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == -1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 2\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 0\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 0\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = -1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 2\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 0\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 0\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += -1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif adc < c:",
      "mutated_line": "elif adc <= c:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc <= c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif adc < c:",
      "mutated_line": "elif adc >= c:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc >= c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif adc < c:",
      "mutated_line": "elif adc != c:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc != c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 2 < n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 2 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 0 < n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 0 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 0 < n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 0 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + -1 < n and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + -1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "nadj.append([r + 1, c])",
      "mutated_line": "nadj.append([r - 1, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r - 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "nadj.append([r + 1, c])",
      "mutated_line": "nadj.append([r * 1, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r * 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 2 >= 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 2 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 0 >= 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 0 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 0 >= 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 0 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - -1 >= 0 and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - -1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nadj.append([r - 1, c])",
      "mutated_line": "nadj.append([r + 1, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r + 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nadj.append([r - 1, c])",
      "mutated_line": "nadj.append([r * 1, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r * 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 2 < m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 2 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 0 < m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 0 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 0 < m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 0 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + -1 < m and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + -1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c - 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c * 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c * 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "nadj.append([r, c + 1])",
      "mutated_line": "nadj.append([r, c - 1])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c - 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "nadj.append([r, c + 1])",
      "mutated_line": "nadj.append([r, c * 1])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c * 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 2 >= 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 2 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 0 >= 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 0 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 0 >= 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 0 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - -1 >= 0 and maze[r][c - 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - -1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c + 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c + 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c * 1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c * 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nadj.append([r, c - 1])",
      "mutated_line": "nadj.append([r, c + 1])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c + 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "nadj.append([r, c - 1])",
      "mutated_line": "nadj.append([r, c * 1])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c * 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 1 > 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 > 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 1 < 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 < 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 1 == 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 == 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans -= 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 1 > 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 > 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 1 < 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 < 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 1 == 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 == 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans -= 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r - 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r - 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r * 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r * 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "nadj.append([r + 1, c])",
      "mutated_line": "nadj.append([r + 2, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 2, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "nadj.append([r + 1, c])",
      "mutated_line": "nadj.append([r + 0, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 0, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "nadj.append([r + 1, c])",
      "mutated_line": "nadj.append([r + 0, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 0, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "nadj.append([r + 1, c])",
      "mutated_line": "nadj.append([r + -1, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + -1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r + 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r + 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r * 1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r * 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nadj.append([r - 1, c])",
      "mutated_line": "nadj.append([r - 2, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 2, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nadj.append([r - 1, c])",
      "mutated_line": "nadj.append([r - 0, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 0, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nadj.append([r - 1, c])",
      "mutated_line": "nadj.append([r - 0, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 0, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nadj.append([r - 1, c])",
      "mutated_line": "nadj.append([r - -1, c])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - -1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c + 2] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 2] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c + 0] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 0] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c + 0] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 0] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if c + 1 < m and maze[r][c + 1] == '.':",
      "mutated_line": "if c + 1 < m and maze[r][c + -1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + -1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "nadj.append([r, c + 1])",
      "mutated_line": "nadj.append([r, c + 2])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 2])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "nadj.append([r, c + 1])",
      "mutated_line": "nadj.append([r, c + 0])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 0])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "nadj.append([r, c + 1])",
      "mutated_line": "nadj.append([r, c + 0])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 0])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "nadj.append([r, c + 1])",
      "mutated_line": "nadj.append([r, c + -1])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + -1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c - 2] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 2] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c - 0] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 0] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c - 0] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 0] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if c - 1 >= 0 and maze[r][c - 1] == '.':",
      "mutated_line": "if c - 1 >= 0 and maze[r][c - -1] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - -1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nadj.append([r, c - 1])",
      "mutated_line": "nadj.append([r, c - 2])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 2])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nadj.append([r, c - 1])",
      "mutated_line": "nadj.append([r, c - 0])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 0])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nadj.append([r, c - 1])",
      "mutated_line": "nadj.append([r, c - 0])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 0])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "nadj.append([r, c - 1])",
      "mutated_line": "nadj.append([r, c - -1])",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - -1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll + 1 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll + 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll * 1 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll * 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 1 >= 1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 1:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 1 >= -1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= -1:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 1 >= 1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 1:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 2\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 0\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 0\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = -1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 2\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 0\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 0\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += -1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr + 1 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr + 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr * 1 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr * 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 1 >= 1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 1:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 1 >= -1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= -1:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 1 >= 1:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 1:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 2\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 0\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 0\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "visit[adr][adc] = 1",
      "mutated_line": "visit[adr][adc] = -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = -1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 2\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 0\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 0\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += -1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r + 2][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 2][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r + 0][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 0][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r + 0][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 0][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r + 1 < n and maze[r + 1][c] == '.':",
      "mutated_line": "if r + 1 < n and maze[r + -1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + -1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r - 2][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 2][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r - 0][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 0][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r - 0][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 0][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if r - 1 >= 0 and maze[r - 1][c] == '.':",
      "mutated_line": "if r - 1 >= 0 and maze[r - -1][c] == '.':",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - -1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 2 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 2 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 0 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 0 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - 0 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 0 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if ll - 1 >= 0:",
      "mutated_line": "if ll - -1 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - -1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 2 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 2 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 0 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 0 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - 0 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 0 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif rr - 1 >= 0:",
      "mutated_line": "elif rr - -1 >= 0:",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - -1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q.append((ll - 1, rr, adr, adc))",
      "mutated_line": "q.append((ll + 1, rr, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll + 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "q.append((ll - 1, rr, adr, adc))",
      "mutated_line": "q.append((ll * 1, rr, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll * 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "q.append((ll, rr - 1, adr, adc))",
      "mutated_line": "q.append((ll, rr + 1, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr + 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "q.append((ll, rr - 1, adr, adc))",
      "mutated_line": "q.append((ll, rr * 1, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr * 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q.append((ll - 1, rr, adr, adc))",
      "mutated_line": "q.append((ll - 2, rr, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 2, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q.append((ll - 1, rr, adr, adc))",
      "mutated_line": "q.append((ll - 0, rr, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 0, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q.append((ll - 1, rr, adr, adc))",
      "mutated_line": "q.append((ll - 0, rr, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 0, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "q.append((ll - 1, rr, adr, adc))",
      "mutated_line": "q.append((ll - -1, rr, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - -1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 1, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((ll, rr - 1, adr, adc))",
      "mutated_line": "q.append((ll, rr - 2, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 2, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((ll, rr - 1, adr, adc))",
      "mutated_line": "q.append((ll, rr - 0, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 0, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((ll, rr - 1, adr, adc))",
      "mutated_line": "q.append((ll, rr - 0, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - 0, adr, adc))\n    bfs(r, c)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "q.append((ll, rr - 1, adr, adc))",
      "mutated_line": "q.append((ll, rr - -1, adr, adc))",
      "code": "from collections import deque\n\ndef count_reachable_cells(n, m, r, c, x, y, maze):\n    r -= 1\n    c -= 1\n    visit = [[0 for _ in range(m)] for _ in range(n)]\n    ans = 0\n\n    def bfs(sr, sc):\n        nonlocal ans\n        q = deque()\n        q.append((x, y, sr, sc))\n        visit[sr][sc] = 1\n        ans += 1\n        while q:\n            (ll, rr, r, c) = q.popleft()\n            nadj = []\n            if r + 1 < n and maze[r + 1][c] == '.':\n                nadj.append([r + 1, c])\n            if r - 1 >= 0 and maze[r - 1][c] == '.':\n                nadj.append([r - 1, c])\n            if c + 1 < m and maze[r][c + 1] == '.':\n                nadj.append([r, c + 1])\n            if c - 1 >= 0 and maze[r][c - 1] == '.':\n                nadj.append([r, c - 1])\n            for (adr, adc) in nadj:\n                if visit[adr][adc] == 1:\n                    continue\n                if c == adc:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.appendleft((ll, rr, adr, adc))\n                elif adc < c:\n                    if ll - 1 >= 0:\n                        visit[adr][adc] = 1\n                        ans += 1\n                        q.append((ll - 1, rr, adr, adc))\n                elif rr - 1 >= 0:\n                    visit[adr][adc] = 1\n                    ans += 1\n                    q.append((ll, rr - -1, adr, adc))\n    bfs(r, c)\n    return ans"
    }
  ]
}