{
  "task_id": "taco_4885",
  "entry_point": "is_bridge",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "time += 1",
      "mutated_line": "time -= 1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time -= 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited = [False] * V",
      "mutated_line": "visited = [False] / V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] / V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited = [False] * V",
      "mutated_line": "visited = [False] + V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] + V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "visited = [False] * V",
      "mutated_line": "visited = [False] ** V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] ** V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "tins = [0] * V",
      "mutated_line": "tins = [0] / V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] / V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "tins = [0] * V",
      "mutated_line": "tins = [0] + V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] + V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "tins = [0] * V",
      "mutated_line": "tins = [0] ** V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] ** V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "low = [0] * V",
      "mutated_line": "low = [0] / V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] / V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "low = [0] * V",
      "mutated_line": "low = [0] + V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] + V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "low = [0] * V",
      "mutated_line": "low = [0] ** V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] ** V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [-1] / V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] / V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [-1] + V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] + V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [-1] ** V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] ** V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 1\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "time = 0",
      "mutated_line": "time = -1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = -1\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 1\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited[sv] = True",
      "mutated_line": "visited[sv] = False",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = False\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "time += 1",
      "mutated_line": "time += 2",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 2\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 0\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 0\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "time += 1",
      "mutated_line": "time += -1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += -1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if edge == [d, c] or edge == [c, d]:",
      "mutated_line": "if edge == [d, c] and edge == [c, d]:",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] and edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visited = [False] * V",
      "mutated_line": "visited = [True] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [True] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tins = [0] * V",
      "mutated_line": "tins = [1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [1] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tins = [0] * V",
      "mutated_line": "tins = [-1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [-1] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tins = [0] * V",
      "mutated_line": "tins = [1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [1] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "low = [0] * V",
      "mutated_line": "low = [1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [1] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "low = [0] * V",
      "mutated_line": "low = [-1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [-1] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "low = [0] * V",
      "mutated_line": "low = [1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [1] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [+1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [+1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if edge == [d, c] or edge == [c, d]:",
      "mutated_line": "if edge != [d, c] or edge == [c, d]:",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge != [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if edge == [d, c] or edge == [c, d]:",
      "mutated_line": "if edge == [d, c] or edge != [c, d]:",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge != [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 2\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 0\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 0\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return -1\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if low[neighbour] > tins[sv]:",
      "mutated_line": "if low[neighbour] >= tins[sv]:",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] >= tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if low[neighbour] > tins[sv]:",
      "mutated_line": "if low[neighbour] <= tins[sv]:",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] <= tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if low[neighbour] > tins[sv]:",
      "mutated_line": "if low[neighbour] != tins[sv]:",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] != tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif neighbour != parent[sv]:",
      "mutated_line": "elif neighbour == parent[sv]:",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour == parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [-2] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-2] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [-0] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-0] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [-0] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [-0] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "parent = [-1] * V",
      "mutated_line": "parent = [--1] * V",
      "code": "def is_bridge(V, E, adj, c, d):\n\n    def dfs(sv, visited, tins, low, parent, output, time):\n        visited[sv] = True\n        tins[sv] = time\n        low[sv] = time\n        time += 1\n        for neighbour in adj[sv]:\n            if not visited[neighbour]:\n                parent[neighbour] = sv\n                dfs(neighbour, visited, tins, low, parent, output, time)\n                low[sv] = min(low[sv], low[neighbour])\n                if low[neighbour] > tins[sv]:\n                    output.append([sv, neighbour])\n            elif neighbour != parent[sv]:\n                low[sv] = min(low[sv], tins[neighbour])\n    visited = [False] * V\n    tins = [0] * V\n    low = [0] * V\n    parent = [--1] * V\n    output = []\n    time = 0\n    for i in range(V):\n        if not visited[i]:\n            dfs(i, visited, tins, low, parent, output, time)\n    for edge in output:\n        if edge == [d, c] or edge == [c, d]:\n            return 1\n    return 0"
    }
  ]
}