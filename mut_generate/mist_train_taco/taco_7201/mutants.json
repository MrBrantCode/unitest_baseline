{
  "task_id": "taco_7201",
  "entry_point": "unflatten_list",
  "mutant_count": 134,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def unflatten(m, d, c=0):",
      "mutated_line": "",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=1):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def unflatten(m, d, c=0):",
      "mutated_line": "",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=-1):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "def unflatten(m, d, c=0):",
      "mutated_line": "",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=1):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if c == d:",
      "mutated_line": "if c != d:",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c != d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while 0 <= i < len(ar):",
      "mutated_line": "while 0 < i < len(ar):",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 < i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while 0 <= i < len(ar):",
      "mutated_line": "while 0 > i < len(ar):",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 > i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while 0 <= i < len(ar):",
      "mutated_line": "while 0 == i < len(ar):",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 == i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c - 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c - 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c * 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c * 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 0 <= i < len(ar):",
      "mutated_line": "while 1 <= i < len(ar):",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 1 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 0 <= i < len(ar):",
      "mutated_line": "while -1 <= i < len(ar):",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while -1 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while 0 <= i < len(ar):",
      "mutated_line": "while 1 <= i < len(ar):",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 1 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i -= [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i -= [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i -= [mod, 1][mod < 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i -= [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 2)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 2)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 0)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 0)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 0)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 0)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + -1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + -1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "(j, r) = (ar[i], lr == 1)",
      "mutated_line": "(j, r) = (ar[i], lr != 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr != 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j * len([ar[i:], ar[:i + 1]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j * len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j + len([ar[i:], ar[:i + 1]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j + len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] / [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] / [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] + [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] + [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] ** [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] ** [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c | 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c | 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [1, len(ar) - 1][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [1, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [-1, len(ar) - 1][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [-1, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [1, len(ar) - 1][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [1, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [0, len(ar) + 1][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) + 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [0, len(ar) * 1][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) * 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(j, r) = (ar[i], lr == 1)",
      "mutated_line": "(j, r) = (ar[i], lr == 2)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 2)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(j, r) = (ar[i], lr == 1)",
      "mutated_line": "(j, r) = (ar[i], lr == 0)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 0)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(j, r) = (ar[i], lr == 1)",
      "mutated_line": "(j, r) = (ar[i], lr == 0)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 0)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "(j, r) = (ar[i], lr == 1)",
      "mutated_line": "(j, r) = (ar[i], lr == -1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == -1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [1, 1][c & 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [1, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [-1, 1][c & 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [-1, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [1, 1][c & 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [1, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 2][c & 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 2][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 0][c & 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 0][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 0][c & 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 0][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, -1][c & 1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, -1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 2]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 2]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 0]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 0]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & 0]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 0]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)",
      "mutated_line": "return unflatten(parse(m, [0, 1][c & -1]), d, c + 1)",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & -1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [0, len(ar) - 2][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 2][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [0, len(ar) - 0][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 0][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [0, len(ar) - 0][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 0][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "(sub, i) = ([], [0, len(ar) - 1][lr])",
      "mutated_line": "(sub, i) = ([], [0, len(ar) - -1][lr])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - -1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [2, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [2, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [0, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [0, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [0, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [0, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [-1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [-1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [1, +1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, +1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod > 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod > 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod < 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod < 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod == 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod == 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod <= 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod <= 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod >= 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod >= 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod != 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod != 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[2, -1][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[2, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[0, -1][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[0, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[0, -1][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[0, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[-1, -1][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[-1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[1, +1][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, +1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [1, -2][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -2][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [1, -0][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -0][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [1, -0][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -0][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i += [1, -1][r]",
      "mutated_line": "i += [1, --1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, --1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 4])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 4])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 2])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 2])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 0])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 0])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 1])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 1])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= -3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= -3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 2][mod < 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 2][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 0][mod < 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 0][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 0][mod < 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 0][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, -1][mod < 3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, -1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 4] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 4] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 2] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 2] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 0] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 0] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 1] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 1] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < -3] * [1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < -3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [2, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [2, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [0, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [0, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [0, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [0, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [-1, -1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [-1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [1, +1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, +1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[1, -2][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -2][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[1, -0][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -0][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[1, -0][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -0][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return sub[::[1, -1][lr]]",
      "mutated_line": "return sub[::[1, --1][lr]]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, --1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [1, -2][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -2][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [1, -0][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -0][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [1, -0][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -0][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "i += [mod, 1][mod < 3] * [1, -1][r]",
      "mutated_line": "i += [mod, 1][mod < 3] * [1, --1][r]",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, --1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j % len([ar[i:], ar[:i - 1]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i - 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j % len([ar[i:], ar[:i * 1]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i * 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i - mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i - mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i * (mod * [1, -1][r]):[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i * (mod * [1, -1][r]):[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j % len([ar[i:], ar[:i + 2]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 2]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j % len([ar[i:], ar[:i + 0]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 0]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j % len([ar[i:], ar[:i + 0]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 0]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "mod = j % len([ar[i:], ar[:i + 1]][r])",
      "mutated_line": "mod = j % len([ar[i:], ar[:i + -1]][r])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + -1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod / [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod / [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + (mod + [1, -1][r]):[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + (mod + [1, -1][r]):[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod ** [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod ** [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[2, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[2, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[0, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[0, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[0, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[0, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[-1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[-1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, +1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, +1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[2, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[2, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[0, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[0, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[0, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[0, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[-1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[-1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, +1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, +1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -2][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -2][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -0][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -0][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -0][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -0][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, --1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, --1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -2][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -2][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -0][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -0][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -0][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -0][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, --1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -1][r]:[1, --1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [2, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [2, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [0, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [0, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [0, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [0, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [-1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [-1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, +1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, +1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -2][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -2][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -0][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -0][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, -0][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, -0][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "sub.append([j, ar[i:i + mod * [1, -1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "mutated_line": "sub.append([j, ar[i:i + mod * [1, --1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])",
      "code": "def unflatten_list(arr, depth):\n\n    def unflatten(m, d, c=0):\n        if c == d:\n            return m\n        return unflatten(parse(m, [0, 1][c & 1]), d, c + 1)\n\n    def parse(ar, lr):\n        (sub, i) = ([], [0, len(ar) - 1][lr])\n        while 0 <= i < len(ar):\n            (j, r) = (ar[i], lr == 1)\n            if isinstance(j, list):\n                sub.append(parse(j, lr))\n                i += [1, -1][r]\n            else:\n                mod = j % len([ar[i:], ar[:i + 1]][r])\n                sub.append([j, ar[i:i + mod * [1, --1][r]:[1, -1][r]][::[1, -1][r]]][mod >= 3])\n                i += [mod, 1][mod < 3] * [1, -1][r]\n        return sub[::[1, -1][lr]]\n    return unflatten(arr, depth)"
    }
  ]
}