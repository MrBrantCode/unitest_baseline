{
  "task_id": "taco_10885",
  "entry_point": "find_valid_positions",
  "mutant_count": 187,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans1 = 0",
      "mutated_line": "ans1 = 1",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 1\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans1 = 0",
      "mutated_line": "ans1 = -1",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = -1\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans1 = 0",
      "mutated_line": "ans1 = 1",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 1\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -1) != -1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) != -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return elem + hash_map[elem]",
      "mutated_line": "return elem - hash_map[elem]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem - hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return elem + hash_map[elem]",
      "mutated_line": "return elem * hash_map[elem]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem * hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n + (m - 1) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n + (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n * ((m - 1) * p)):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n * ((m - 1) * p)):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n + (m - 1) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n + (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n * ((m - 1) * p)):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n * ((m - 1) * p)):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if b_check != c_check:",
      "mutated_line": "if b_check == c_check:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check == c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "ans1 += 1",
      "mutated_line": "ans1 -= 1",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 -= 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -1) == +1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == +1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem <= 1000:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem <= 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem >= 1000:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem >= 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem != 1000:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem != 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m - 1) / p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) / p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m - 1 + p)):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1 + p)):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m - 1) ** p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) ** p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "prev = c_new[q - p]",
      "mutated_line": "prev = c_new[q + p]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q + p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "prev = c_new[q - p]",
      "mutated_line": "prev = c_new[q * p]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q * p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] - c[q + p * (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] - c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append((prev - c[q - p]) * c[q + p * (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append((prev - c[q - p]) * c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m - 1) / p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) / p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m - 1 + p)):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1 + p)):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m - 1) ** p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) ** p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans1 += 1",
      "mutated_line": "ans1 += 2",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 2\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans1 += 1",
      "mutated_line": "ans1 += 0",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 0\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans1 += 1",
      "mutated_line": "ans1 += 0",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 0\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans1 += 1",
      "mutated_line": "ans1 += -1",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += -1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, +1) == -1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, +1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -1) == -2:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -2:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -1) == -0:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -0:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -1) == -0:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -0:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -1) == --1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == --1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem < 1001:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1001:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem < 999:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 999:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem < 0:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 0:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem < 1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if elem < 1000:",
      "mutated_line": "if elem < -1000:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < -1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem) & 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem) & 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem ^ 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem ^ 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 + elem | 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem | 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m + 1) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m + 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - m * 1 * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - m * 1 * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev + c[q - p] + c[q + p * (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev + c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev * c[q - p] + c[q + p * (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev * c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m + 1) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m + 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - m * 1 * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - m * 1 * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans.append(q + 1)",
      "mutated_line": "ans.append(q - 1)",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q - 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans.append(q + 1)",
      "mutated_line": "ans.append(q * 1)",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q * 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -2) == -1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -2) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -0) == -1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -0) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, -0) == -1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -0) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if hash_map.get(elem, -1) == -1:",
      "mutated_line": "if hash_map.get(elem, --1) == -1:",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, --1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem | 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem | 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094024",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094024\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094022",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094022\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 0",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 0\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 1",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 1\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | -21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | -21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 - elem ^ 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 - elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 * elem ^ 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 * elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 + elem ^ 35",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 35\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 + elem ^ 33",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 33\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 + elem ^ 0",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 0\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 + elem ^ 1",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 1\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 3 + elem ^ -34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ -34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q - p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q - p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q * (p * i)] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q * (p * i)] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m - 2) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 2) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m - 0) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 0) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m - 0) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 0) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for q in range(p, n - (m - 1) * p):",
      "mutated_line": "for q in range(p, n - (m - -1) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - -1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q - p * (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q - p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q * (p * (m - 1))])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q * (p * (m - 1))])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m - 2) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 2) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m - 0) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 0) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m - 0) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 0) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for q in range(n - (m - 1) * p):",
      "mutated_line": "for q in range(n - (m - -1) * p):",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - -1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans.append(q + 1)",
      "mutated_line": "ans.append(q + 2)",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 2)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans.append(q + 1)",
      "mutated_line": "ans.append(q + 0)",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 0)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans.append(q + 1)",
      "mutated_line": "ans.append(q + 0)",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 0)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans.append(q + 1)",
      "mutated_line": "ans.append(q + -1)",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + -1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem | 213213 + elem) ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem | 213213 + elem) ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 - elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 - elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 * elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 * elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 4 + elem ^ 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 4 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 2 + elem ^ 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 2 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 0 + elem ^ 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 0 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = 1 + elem ^ 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 1 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "hash_map[elem] = 3 + elem ^ 34",
      "mutated_line": "hash_map[elem] = -3 + elem ^ 34",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = -3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p / i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p / i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + (p + i)] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + (p + i)] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p ** i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p ** i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(1, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(1, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(-1, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(-1, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(1, n - (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(1, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n + (m - 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n + (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n * ((m - 1) * p))))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n * ((m - 1) * p))))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q + p] + c[q + p * (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q + p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q * p] + c[q + p * (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q * p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p / (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p / (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + (p + (m - 1))])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + (p + (m - 1))])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p ** (m - 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p ** (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 - elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 - elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 * elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 * elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211324 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211324 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211322 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211322 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 0 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 0 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 1 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 1 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ -324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ -324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) / p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) / p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1 + p))))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1 + p))))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) ** p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) ** p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p * (m + 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m + 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p * (m * 1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m * 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) - elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) - elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> (7 + int(log(elem)) + int(sqrt(elem))) * elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> (7 + int(log(elem)) + int(sqrt(elem))) * elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213214 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213214 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213212 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213212 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 0 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 0 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 1 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 1 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & -213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & -213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m + 1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m + 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - m * 1 * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - m * 1 * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 2)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 2)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 0)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 0)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 0)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 0)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "c_new.append(prev - c[q - p] + c[q + p * (m - 1)])",
      "mutated_line": "c_new.append(prev - c[q - p] + c[q + p * (m - -1)])",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - -1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) - elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) - elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2)) * elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2)) * elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 - elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 - elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 * elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 * elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) - int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) - int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> (7 + int(log(elem))) * int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> (7 + int(log(elem))) * int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 2) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 2) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 0) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 0) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 0) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 0) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]",
      "mutated_line": "c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - -1) * p)))]",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - -1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) - int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) - int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3)) * int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = (elem // 2 + elem * 1134234546677 + int(elem / 3)) * int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 3 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 3 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 1 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 1 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 0 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 0 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 1 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 1 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << -2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << -2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 - int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 - int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 * int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 * int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 - int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 - int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = (elem // 2 + elem * 1134234546677) * int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = (elem // 2 + elem * 1134234546677) * int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 8 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 8 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 6 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 6 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 0 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 0 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 1 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 1 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> -7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> -7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 - elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 - elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 * (elem * 1134234546677) + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 * (elem * 1134234546677) + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem * 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem * 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem + 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem + 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem / 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem / 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem * 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem * 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem / 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem / 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + (elem + 1134234546677) + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + (elem + 1134234546677) + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem ** 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem ** 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem * 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem * 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem // 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem // 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 3) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 3) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 1) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 1) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 0) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 0) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 1) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 1) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** -2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** -2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 3 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 3 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 1 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 1 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 0 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 0 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 1 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 1 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // -2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // -2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546678 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546678 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546676 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546676 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 0 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 0 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * -1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * -1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 4) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 4) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 2) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 2) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 0) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 0) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 1) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 1) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / 3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "mutated_line": "hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / -3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023",
      "code": "def find_valid_positions(n, m, p, a, b):\n    hash_map = {}\n\n    def hash_elem(elem):\n        if hash_map.get(elem, -1) == -1:\n            if elem < 1000:\n                hash_map[elem] = elem // 2 + elem * 1134234546677 + int(elem / -3) + int(elem ** 2) + elem << 2 + elem >> 7 + int(log(elem)) + int(sqrt(elem)) + elem & 213213 + elem ^ 324234211323 + elem | 21319423094023\n            else:\n                hash_map[elem] = 3 + elem ^ 34\n        return elem + hash_map[elem]\n    c = [hash_elem(elem) for elem in a]\n    c_new = [sum([c[q + p * i] for i in range(m)]) for q in range(min(p, max(0, n - (m - 1) * p)))]\n    for q in range(p, n - (m - 1) * p):\n        prev = c_new[q - p]\n        c_new.append(prev - c[q - p] + c[q + p * (m - 1)])\n    b_check = sum([hash_elem(elem) for elem in b])\n    ans1 = 0\n    ans = []\n    for q in range(n - (m - 1) * p):\n        c_check = c_new[q]\n        if b_check != c_check:\n            continue\n        else:\n            ans1 += 1\n            ans.append(q + 1)\n    return (ans1, ans)"
    }
  ]
}