{
  "task_id": "taco_11240",
  "entry_point": "calculate_min_moves",
  "mutant_count": 153,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] / (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] / (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] + (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] + (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] ** (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] ** (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] / (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] / (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] + (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] + (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] ** (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] ** (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] / (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] / (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] + (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] + (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] ** (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] ** (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] / (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] / (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] + (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] + (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] ** (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] ** (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "was[1] = True",
      "mutated_line": "was[1] = False",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = False\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 1\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = -1\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 1\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = 2",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 2\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 0\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 0\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = 1",
      "mutated_line": "j = -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = -1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] / (n + 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] / (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] + (n + 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] + (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] ** (n + 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] ** (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q[0] = 1",
      "mutated_line": "q[0] = 2",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 2\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q[0] = 1",
      "mutated_line": "q[0] = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 0\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q[0] = 1",
      "mutated_line": "q[0] = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 0\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q[0] = 1",
      "mutated_line": "q[0] = -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = -1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[1] = 0",
      "mutated_line": "p[1] = 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 1\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[1] = 0",
      "mutated_line": "p[1] = -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = -1\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[1] = 0",
      "mutated_line": "p[1] = 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 1\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < j:",
      "mutated_line": "while i <= j:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i <= j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < j:",
      "mutated_line": "while i >= j:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i >= j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i < j:",
      "mutated_line": "while i != j:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i != j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i -= 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "i = j - 1",
      "mutated_line": "i = j + 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j + 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "i = j - 1",
      "mutated_line": "i = j * 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j * 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while i >= 0:",
      "mutated_line": "while i > 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i > 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while i >= 0:",
      "mutated_line": "while i < 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i < 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while i >= 0:",
      "mutated_line": "while i == 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i == 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "i -= 1",
      "mutated_line": "i += 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i += 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[0] - minus[0]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] - minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[0] * minus[0]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] * minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] * (n - 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n - 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] * (n * 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n * 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] * (n - 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n - 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] * (n * 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n * 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] * (n - 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n - 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] * (n * 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n * 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n - 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n - 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n * 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n * 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "was[1] = True",
      "mutated_line": "was[2] = True",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[2] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "was[1] = True",
      "mutated_line": "was[0] = True",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[0] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "was[1] = True",
      "mutated_line": "was[0] = True",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[0] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "was[1] = True",
      "mutated_line": "was[-1] = True",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[-1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] * (n - 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n - 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] * (n * 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n * 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q[0] = 1",
      "mutated_line": "q[1] = 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[1] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q[0] = 1",
      "mutated_line": "q[-1] = 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[-1] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "q[0] = 1",
      "mutated_line": "q[1] = 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[1] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[1] = 0",
      "mutated_line": "p[2] = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[2] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[1] = 0",
      "mutated_line": "p[0] = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[0] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[1] = 0",
      "mutated_line": "p[0] = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[0] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p[1] = 0",
      "mutated_line": "p[-1] = 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[-1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 2\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 0\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 0\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += -1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - 2",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 2\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 0\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 0\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "i = j - 1",
      "mutated_line": "i = j - -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - -1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 1:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= -1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= -1:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "while i >= 0:",
      "mutated_line": "while i >= 1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 1:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i -= 1",
      "mutated_line": "i -= 2",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 2\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 0\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i -= 1",
      "mutated_line": "i -= 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 0\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "i -= 1",
      "mutated_line": "i -= -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= -1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "s = minus[x] - plus[x]",
      "mutated_line": "s = minus[x] + plus[x]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] + plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "s = minus[x] - plus[x]",
      "mutated_line": "s = minus[x] * plus[x]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] * plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x - 1] - s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] - s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x - 1] * s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] * s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if z > 0:",
      "mutated_line": "if z >= 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z >= 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if z > 0:",
      "mutated_line": "if z <= 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z <= 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if z > 0:",
      "mutated_line": "if z != 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z != 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] * (n + 2)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 2)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 0)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 0)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p = [None] * (n + 1)",
      "mutated_line": "p = [None] * (n + -1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + -1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [1] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [1] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [-1] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [-1] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [1] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [1] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] * (n + 2)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 2)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 0)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 0)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "plus = [0] * (n + 1)",
      "mutated_line": "plus = [0] * (n + -1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + -1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [1] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [1] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [-1] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [-1] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [1] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [1] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] * (n + 2)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 2)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 0)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 0)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minus = [0] * (n + 1)",
      "mutated_line": "minus = [0] * (n + -1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + -1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [True] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [True] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + 2)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 2)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 0)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 0)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "was = [False] * (n + 1)",
      "mutated_line": "was = [False] * (n + -1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + -1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [1] * (n + 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [1] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [-1] * (n + 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [-1] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [1] * (n + 100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [1] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] * (n + 101)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 101)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] * (n + 99)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 99)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] * (n + 0)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 0)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] * (n + 1)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 1)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "q = [0] * (n + 100)",
      "mutated_line": "q = [0] * (n + -100)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + -100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j -= 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if z > 0:",
      "mutated_line": "if z > 1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 1:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if z > 0:",
      "mutated_line": "if z > -1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > -1:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if z > 0:",
      "mutated_line": "if z > 1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 1:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif z < 0:",
      "mutated_line": "elif z <= 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z <= 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif z < 0:",
      "mutated_line": "elif z >= 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z >= 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "elif z < 0:",
      "mutated_line": "elif z != 0:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z != 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[1] + minus[0]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[1] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[-1] + minus[0]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[-1] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[1] + minus[0]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[1] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[0] + minus[1]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[0] + minus[-1]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return plus[0] + minus[0]",
      "mutated_line": "return plus[0] + minus[1]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[1]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n - 1)]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n - 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n * 1)]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n * 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "was[y] = True",
      "mutated_line": "was[y] = False",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = False\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 2\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 0\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 0\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += -1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x + 1] + s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x + 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x * 1] + s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x * 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "plus[pp] = max(plus[pp], plus[x] + z)",
      "mutated_line": "plus[pp] = max(plus[pp], plus[x] - z)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] - z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "plus[pp] = max(plus[pp], plus[x] + z)",
      "mutated_line": "plus[pp] = max(plus[pp], plus[x] * z)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] * z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif z < 0:",
      "mutated_line": "elif z < 1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 1:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif z < 0:",
      "mutated_line": "elif z < -1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < -1:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "elif z < 0:",
      "mutated_line": "elif z < 1:",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 1:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + 2)]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 2)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + 0)]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 0)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + 0)]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 0)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "e = [[] for _ in range(n + 1)]",
      "mutated_line": "e = [[] for _ in range(n + -1)]",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + -1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x - 2] + s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 2] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x - 0] + s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 0] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x - 0] + s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 0] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "z = values[x - 1] + s",
      "mutated_line": "z = values[x - -1] + s",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - -1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] - z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "minus[pp] = max(minus[pp], minus[x] - z)",
      "mutated_line": "minus[pp] = max(minus[pp], minus[x] + z)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] + z)\n    return plus[0] + minus[0]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "minus[pp] = max(minus[pp], minus[x] - z)",
      "mutated_line": "minus[pp] = max(minus[pp], minus[x] * z)",
      "code": "def calculate_min_moves(n, edges, values):\n    e = [[] for _ in range(n + 1)]\n    p = [None] * (n + 1)\n    for (a, b) in edges:\n        e[a].append(b)\n        e[b].append(a)\n    plus = [0] * (n + 1)\n    minus = [0] * (n + 1)\n    was = [False] * (n + 1)\n    was[1] = True\n    i = 0\n    j = 1\n    q = [0] * (n + 100)\n    q[0] = 1\n    p[1] = 0\n    while i < j:\n        x = q[i]\n        i += 1\n        for y in e[x]:\n            if not was[y]:\n                was[y] = True\n                p[y] = x\n                q[j] = y\n                j += 1\n    i = j - 1\n    while i >= 0:\n        x = q[i]\n        i -= 1\n        s = minus[x] - plus[x]\n        z = values[x - 1] + s\n        pp = p[x]\n        minus[pp] = max(minus[x], minus[pp])\n        plus[pp] = max(plus[x], plus[pp])\n        if z > 0:\n            plus[pp] = max(plus[pp], plus[x] + z)\n        elif z < 0:\n            minus[pp] = max(minus[pp], minus[x] * z)\n    return plus[0] + minus[0]"
    }
  ]
}