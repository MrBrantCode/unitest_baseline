{
  "task_id": "taco_17110",
  "entry_point": "calculate_minimum_time",
  "mutant_count": 121,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "size = n * m",
      "mutated_line": "size = n / m",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n / m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "size = n * m",
      "mutated_line": "size = n + m",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n + m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "size = n * m",
      "mutated_line": "size = n ** m",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n ** m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dist = [MAXINT] * size",
      "mutated_line": "dist = [MAXINT] / size",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] / size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dist = [MAXINT] * size",
      "mutated_line": "dist = [MAXINT] + size",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] + size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dist = [MAXINT] * size",
      "mutated_line": "dist = [MAXINT] ** size",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] ** size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist[source] = 0",
      "mutated_line": "dist[source] = 1",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 1\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist[source] = 0",
      "mutated_line": "dist[source] = -1",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = -1\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist[source] = 0",
      "mutated_line": "dist[source] = 1",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 1\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist_from_start = dfs(0, size)",
      "mutated_line": "dist_from_start = dfs(1, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(1, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist_from_start = dfs(0, size)",
      "mutated_line": "dist_from_start = dfs(-1, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(-1, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dist_from_start = dfs(0, size)",
      "mutated_line": "dist_from_start = dfs(1, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(1, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist_from_dest = dfs(size - 1, size)",
      "mutated_line": "dist_from_dest = dfs(size + 1, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size + 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dist_from_dest = dfs(size - 1, size)",
      "mutated_line": "dist_from_dest = dfs(size * 1, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size * 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 1] / w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] / w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 1] + w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] + w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 1] ** w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] ** w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start - tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start - tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start * tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start * tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "return -1 if minres == inf else minres",
      "mutated_line": "return -1 if minres != inf else minres",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres != inf else minres"
    },
    {
      "operator": "UOI",
      "lineno": 40,
      "original_line": "return -1 if minres == inf else minres",
      "mutated_line": "return +1 if minres == inf else minres",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return +1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(2, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(2, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(0, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(0, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(0, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(0, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(-1, 0), (0, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(-1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 1), (0, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 1), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, -1), (0, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, -1), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 1), (0, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 1), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (1, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (1, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (-1, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (-1, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (1, 1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (1, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 2), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 2), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 0), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 0), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 0), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, -1), (-1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, -1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (+1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (+1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 1), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 1), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, -1), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, -1), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 1), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 1), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (1, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (1, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (-1, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (-1, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (1, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (1, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, +1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, +1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist_from_dest = dfs(size - 1, size)",
      "mutated_line": "dist_from_dest = dfs(size - 2, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 2, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist_from_dest = dfs(size - 1, size)",
      "mutated_line": "dist_from_dest = dfs(size - 0, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 0, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist_from_dest = dfs(size - 1, size)",
      "mutated_line": "dist_from_dest = dfs(size - 0, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 0, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dist_from_dest = dfs(size - 1, size)",
      "mutated_line": "dist_from_dest = dfs(size - -1, size)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - -1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "loc = x * m + y",
      "mutated_line": "loc = x * m - y",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m - y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "loc = x * m + y",
      "mutated_line": "loc = x * m * y",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m * y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if grid[x][y] > 0:",
      "mutated_line": "if grid[x][y] >= 0:",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] >= 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if grid[x][y] > 0:",
      "mutated_line": "if grid[x][y] <= 0:",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] <= 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if grid[x][y] > 0:",
      "mutated_line": "if grid[x][y] != 0:",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] != 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1 if minres == inf else minres",
      "mutated_line": "return -2 if minres == inf else minres",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -2 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1 if minres == inf else minres",
      "mutated_line": "return -0 if minres == inf else minres",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -0 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1 if minres == inf else minres",
      "mutated_line": "return -0 if minres == inf else minres",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -0 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return -1 if minres == inf else minres",
      "mutated_line": "return --1 if minres == inf else minres",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return --1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-2, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-2, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-0, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-0, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-0, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-0, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (--1, 0), (0, -1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (--1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -2)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -2)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -0)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -0)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -0)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -0)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]",
      "mutated_line": "d4 = [(1, 0), (0, 1), (-1, 0), (0, --1)]",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, --1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "xx = x + dx",
      "mutated_line": "xx = x - dx",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x - dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "xx = x + dx",
      "mutated_line": "xx = x * dx",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x * dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "yy = y + dy",
      "mutated_line": "yy = y - dy",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y - dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "yy = y + dy",
      "mutated_line": "yy = y * dy",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y * dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_loc = xx * m + yy",
      "mutated_line": "new_loc = xx * m - yy",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m - yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_loc = xx * m + yy",
      "mutated_line": "new_loc = xx * m * yy",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m * yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n or 0 <= yy < m or dist[new_loc] == MAXINT or (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n or 0 <= yy < m or dist[new_loc] == MAXINT or (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "loc = x * m + y",
      "mutated_line": "loc = x / m + y",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x / m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "loc = x * m + y",
      "mutated_line": "loc = x + m + y",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x + m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "loc = x * m + y",
      "mutated_line": "loc = x ** m + y",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x ** m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if grid[x][y] > 0:",
      "mutated_line": "if grid[x][y] > 1:",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 1:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if grid[x][y] > 0:",
      "mutated_line": "if grid[x][y] > -1:",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > -1:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if grid[x][y] > 0:",
      "mutated_line": "if grid[x][y] > 1:",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 1:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size + 1] * w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size + 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size * 1] * w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size * 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_loc = xx * m + yy",
      "mutated_line": "new_loc = xx / m + yy",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx / m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_loc = xx * m + yy",
      "mutated_line": "new_loc = xx + m + yy",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx + m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "new_loc = xx * m + yy",
      "mutated_line": "new_loc = xx ** m + yy",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx ** m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 < xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 < xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 > xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 > xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 == xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 == xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 < yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 < yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 > yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 > yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 == yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 == yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] != MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] != MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] > 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] > 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] < 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] < 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] == 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] == 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dist[new_loc] = dist[loc] + 1",
      "mutated_line": "dist[new_loc] = dist[loc] - 1",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] - 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dist[new_loc] = dist[loc] + 1",
      "mutated_line": "dist[new_loc] = dist[loc] * 1",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] * 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])",
      "mutated_line": "tele_from_start = min(tele_from_start, grid[x][y] - w * dist_from_start[loc])",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] - w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])",
      "mutated_line": "tele_from_start = min(tele_from_start, grid[x][y] * (w * dist_from_start[loc]))",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] * (w * dist_from_start[loc]))\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])",
      "mutated_line": "tele_from_dest = min(tele_from_dest, grid[x][y] - w * dist_from_dest[loc])",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] - w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])",
      "mutated_line": "tele_from_dest = min(tele_from_dest, grid[x][y] * (w * dist_from_dest[loc]))",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] * (w * dist_from_dest[loc]))\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 2] * w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 2] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 0] * w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 0] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - 0] * w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 0] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)",
      "mutated_line": "minres = min(dist_from_start[size - -1] * w, tele_from_start + tele_from_dest)",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - -1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 1 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 1 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if -1 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if -1 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 1 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 1 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 1 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 1 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and -1 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and -1 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 1 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 1 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 1):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 1):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= -1):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= -1):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):",
      "mutated_line": "if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 1):",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 1):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[new_loc] = dist[loc] + 1",
      "mutated_line": "dist[new_loc] = dist[loc] + 2",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 2\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[new_loc] = dist[loc] + 1",
      "mutated_line": "dist[new_loc] = dist[loc] + 0",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 0\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[new_loc] = dist[loc] + 1",
      "mutated_line": "dist[new_loc] = dist[loc] + 0",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 0\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dist[new_loc] = dist[loc] + 1",
      "mutated_line": "dist[new_loc] = dist[loc] + -1",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + -1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])",
      "mutated_line": "tele_from_start = min(tele_from_start, grid[x][y] + w / dist_from_start[loc])",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w / dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])",
      "mutated_line": "tele_from_start = min(tele_from_start, grid[x][y] + (w + dist_from_start[loc]))",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + (w + dist_from_start[loc]))\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])",
      "mutated_line": "tele_from_start = min(tele_from_start, grid[x][y] + w ** dist_from_start[loc])",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w ** dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])",
      "mutated_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + w / dist_from_dest[loc])",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w / dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])",
      "mutated_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + (w + dist_from_dest[loc]))",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + (w + dist_from_dest[loc]))\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + w * dist_from_dest[loc])",
      "mutated_line": "tele_from_dest = min(tele_from_dest, grid[x][y] + w ** dist_from_dest[loc])",
      "code": "from collections import deque\nfrom math import inf\n\ndef calculate_minimum_time(n, m, w, grid):\n    MAXINT = inf\n    d4 = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\n    def dfs(source, size):\n        stack = deque([source])\n        dist = [MAXINT] * size\n        dist[source] = 0\n        while stack:\n            loc = stack.popleft()\n            (x, y) = divmod(loc, m)\n            for (dx, dy) in d4:\n                xx = x + dx\n                yy = y + dy\n                new_loc = xx * m + yy\n                if 0 <= xx < n and 0 <= yy < m and (dist[new_loc] == MAXINT) and (grid[xx][yy] >= 0):\n                    dist[new_loc] = dist[loc] + 1\n                    stack.append(new_loc)\n        return dist\n    size = n * m\n    dist_from_start = dfs(0, size)\n    dist_from_dest = dfs(size - 1, size)\n    tele_from_start = inf\n    tele_from_dest = inf\n    for x in range(n):\n        for y in range(m):\n            loc = x * m + y\n            if grid[x][y] > 0:\n                tele_from_start = min(tele_from_start, grid[x][y] + w * dist_from_start[loc])\n                tele_from_dest = min(tele_from_dest, grid[x][y] + w ** dist_from_dest[loc])\n    minres = min(dist_from_start[size - 1] * w, tele_from_start + tele_from_dest)\n    return -1 if minres == inf else minres"
    }
  ]
}