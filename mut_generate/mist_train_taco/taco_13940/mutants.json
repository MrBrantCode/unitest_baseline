{
  "task_id": "taco_13940",
  "entry_point": "can_arrange_on_circle",
  "mutant_count": 131,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 != 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = n // 2",
      "mutated_line": "m = n / 2",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n / 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "m = n // 2",
      "mutated_line": "m = n * 2",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n * 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n * 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n + 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 2:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 0:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 0:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == -1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = n // 2",
      "mutated_line": "m = n // 3",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 3\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = n // 2",
      "mutated_line": "m = n // 1",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 1\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = n // 2",
      "mutated_line": "m = n // 0",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 0\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = n // 2",
      "mutated_line": "m = n // 1",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 1\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = n // 2",
      "mutated_line": "m = n // -2",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // -2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(2, n - 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(2, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(0, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(0, n - 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(0, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(-1, n - 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(-1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n + 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n + 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n * 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (1, n - 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (1, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (-1, n - 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (-1, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (1, n - 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (1, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (0, n + 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n + 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (0, n * 1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n * 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return True, b",
      "mutated_line": "return (False, b)",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (False, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 3 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 1 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 0 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 1 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % -2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return False, []",
      "mutated_line": "return (True, [])",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (True, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 2):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 2):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 0):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - 0):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 0):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n - 1):",
      "mutated_line": "for i in range(1, n - -1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - -1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not ((b[i] < b[i + 1] and b[i] < b[i - 1]) and (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not ((b[i] < b[i + 1] and b[i] < b[i - 1]) and (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (0, n - 2):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 2):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (0, n - 0):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 0):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (0, n - 0):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 0):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in (0, n - 1):",
      "mutated_line": "for i in (0, n - -1):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - -1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not ((b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n]) and (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not ((b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n]) and (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b.append(a[i + m])",
      "mutated_line": "b.append(a[i - m])",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i - m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "b.append(a[i + m])",
      "mutated_line": "b.append(a[i * m])",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i * m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not ((b[i] < b[i + 1] or b[i] < b[i - 1]) or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not ((b[i] < b[i + 1] or b[i] < b[i - 1]) or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] or b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] or b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return False, []",
      "mutated_line": "return (True, [])",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (True, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not ((b[i] < b[(i + 1) % n] or b[i] < b[(i - 1) % n]) or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not ((b[i] < b[(i + 1) % n] or b[i] < b[(i - 1) % n]) or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] or b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] or b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return False, []",
      "mutated_line": "return (True, [])",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (True, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] <= b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] <= b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] >= b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] >= b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] != b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] != b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] <= b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] <= b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] >= b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] >= b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] != b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] != b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] >= b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] >= b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] <= b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] <= b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] != b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] != b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] >= b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] >= b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] <= b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] <= b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] != b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] != b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] <= b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] <= b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] >= b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] >= b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] != b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] != b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] <= b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] <= b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] >= b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] >= b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] != b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] != b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] >= b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] >= b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] <= b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] <= b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] != b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] != b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] >= b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] >= b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] <= b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] <= b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] != b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] != b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i - 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i - 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i * 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i * 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i + 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i + 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i * 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i * 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i - 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i - 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i * 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i * 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i + 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i + 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i * 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i * 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) * n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) * n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[i + 1 + n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[i + 1 + n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) * n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) * n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[i - 1 + n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[i - 1 + n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) * n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) * n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[i + 1 + n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[i + 1 + n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) * n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) * n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[i - 1 + n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[i - 1 + n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 2] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 2] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 0] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 0] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 0] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 0] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + -1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + -1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 2] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 2] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 0] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 0] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 0] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 0] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - -1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - -1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 2] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 2] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 0] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 0] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 0] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 0] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + -1] and b[i] > b[i - 1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + -1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 2])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 2])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 0])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 0])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 0])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 0])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):",
      "mutated_line": "if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - -1])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - -1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i - 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i - 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[i * 1 % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[i * 1 % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i + 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i + 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[i * 1 % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[i * 1 % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i - 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i - 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[i * 1 % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[i * 1 % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i + 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i + 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[i * 1 % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[i * 1 % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 2) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 2) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 0) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 0) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 0) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 0) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + -1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + -1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 2) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 2) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 0) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 0) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 0) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 0) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - -1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - -1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 2) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 2) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 0) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 0) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 0) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 0) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + -1) % n] and b[i] > b[(i - 1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + -1) % n] and b[i] > b[(i - 1) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 2) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 2) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 0) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 0) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 0) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 0) % n])):\n            return (False, [])\n    return (True, b)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - 1) % n])):",
      "mutated_line": "if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - -1) % n])):",
      "code": "def can_arrange_on_circle(a: list[int]) -> tuple[bool, list[int]]:\n    \"\"\"\n    Determines if the given list of integers can be arranged on a circle such that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors.\n\n    Parameters:\n    a (list[int]): The list of integers to be arranged.\n\n    Returns:\n    tuple[bool, list[int]]: A tuple where the first element is a boolean indicating whether a valid arrangement exists, and the second element is the rearranged list if the arrangement is possible. If not possible, the second element is an empty list.\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (False, [])\n    a.sort()\n    m = n // 2\n    b = []\n    for i in range(m):\n        b.append(a[i])\n        b.append(a[i + m])\n    for i in range(1, n - 1):\n        if not (b[i] < b[i + 1] and b[i] < b[i - 1] or (b[i] > b[i + 1] and b[i] > b[i - 1])):\n            return (False, [])\n    for i in (0, n - 1):\n        if not (b[i] < b[(i + 1) % n] and b[i] < b[(i - 1) % n] or (b[i] > b[(i + 1) % n] and b[i] > b[(i - -1) % n])):\n            return (False, [])\n    return (True, b)"
    }
  ]
}