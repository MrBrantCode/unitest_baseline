{
  "task_id": "taco_3014",
  "entry_point": "can_satisfy_rotation_criteria",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[0] -= gaps[-1]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] -= gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mgap = 0",
      "mutated_line": "mgap = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 1\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mgap = 0",
      "mutated_line": "mgap = -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = -1\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mgap = 0",
      "mutated_line": "mgap = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 1\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 1\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = 0",
      "mutated_line": "curr = -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = -1\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 1\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 1\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = -1\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 1\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < N:",
      "mutated_line": "while i <= N:",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i <= N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < N:",
      "mutated_line": "while i >= N:",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i >= N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < N:",
      "mutated_line": "while i != N:",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i != N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i -= 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if S[-1] == '1':",
      "mutated_line": "if S[-1] != '1':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] != '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 1\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = -1\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 1\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while i < N and S[i] == '0':",
      "mutated_line": "while i < N or S[i] == '0':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N or S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "curr += 1",
      "mutated_line": "curr -= 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr -= 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i -= 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 2\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 0\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 0\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += -1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 1\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "curr = 0",
      "mutated_line": "curr = -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = -1\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 1\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[-1] == '1':",
      "mutated_line": "if S[-1] == '':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[1] += gaps[-1]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[1] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[-1] += gaps[-1]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[-1] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[1] += gaps[-1]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[1] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[0] += gaps[+1]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[+1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j > C:",
      "mutated_line": "if j >= C:",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j >= C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j > C:",
      "mutated_line": "if j <= C:",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j <= C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if j > C:",
      "mutated_line": "if j != C:",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j != C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count -= 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count <= 2 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count <= 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count >= 2 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count >= 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count != 2 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count != 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return '' if count < 2 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return '' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count < 2 else ''",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else ''"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i < N and S[i] == '0':",
      "mutated_line": "while i <= N and S[i] == '0':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i <= N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i < N and S[i] == '0':",
      "mutated_line": "while i >= N and S[i] == '0':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i >= N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i < N and S[i] == '0':",
      "mutated_line": "while i != N and S[i] == '0':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i != N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i < N and S[i] == '0':",
      "mutated_line": "while i < N and S[i] != '0':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] != '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr += 1",
      "mutated_line": "curr += 2",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 2\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 0\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 0\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr += 1",
      "mutated_line": "curr += -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += -1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 2\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 0\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 0\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += -1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if S[-1] == '1':",
      "mutated_line": "if S[+1] == '1':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[+1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[0] += gaps[-2]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-2]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[0] += gaps[-0]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-0]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[0] += gaps[-0]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-0]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "gaps[0] += gaps[-1]",
      "mutated_line": "gaps[0] += gaps[--1]",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[--1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 2\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 0\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 0\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += -1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count < 3 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 3 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count < 1 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 1 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count < 0 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 0 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count < 1 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 1 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return 'YES' if count < 2 else 'NO'",
      "mutated_line": "return 'YES' if count < -2 else 'NO'",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < -2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i < N and S[i] == '0':",
      "mutated_line": "while i < N and S[i] == '':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[-1] == '1':",
      "mutated_line": "if S[-2] == '1':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-2] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[-1] == '1':",
      "mutated_line": "if S[-0] == '1':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-0] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[-1] == '1':",
      "mutated_line": "if S[-0] == '1':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[-0] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[-1] == '1':",
      "mutated_line": "if S[--1] == '1':",
      "code": "def can_satisfy_rotation_criteria(S: str, N: int, C: int) -> str:\n    mgap = 0\n    curr = 0\n    gaps = []\n    i = 0\n    while i < N:\n        while i < N and S[i] == '0':\n            curr += 1\n            i += 1\n        gaps.append(curr)\n        i += 1\n        curr = 0\n    if S[--1] == '1':\n        gaps.append(curr)\n    gaps[0] += gaps[-1]\n    gaps.pop()\n    count = 0\n    for j in gaps:\n        if j > C:\n            count += 1\n    return 'YES' if count < 2 else 'NO'"
    }
  ]
}