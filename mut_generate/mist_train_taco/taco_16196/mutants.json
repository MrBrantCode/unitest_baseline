{
  "task_id": "taco_16196",
  "entry_point": "calculate_min_jumps_sum",
  "mutant_count": 191,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tot_dist = 0",
      "mutated_line": "tot_dist = 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 1\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tot_dist = 0",
      "mutated_line": "tot_dist = -1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = -1\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "tot_dist = 0",
      "mutated_line": "tot_dist = 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 1\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] / (n + 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] / (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] + (n + 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] + (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] ** (n + 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] ** (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n - 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n - 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n * 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n * 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][1] -= 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] -= 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [1] * (n + 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [1] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [-1] * (n + 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [-1] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [1] * (n + 1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [1] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 2)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 2)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 0)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 0)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 0)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 0)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + -1)",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + -1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] / 2 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] / 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] + 2 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] + 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] ** 2 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] ** 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([2])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([2])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([0])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([0])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([0])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([0])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([-1])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([-1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "c = s[-1]",
      "mutated_line": "c = s[+1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[+1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[c] = 1",
      "mutated_line": "vis[c] = 2",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 2\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[c] = 1",
      "mutated_line": "vis[c] = 0",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 0\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[c] = 1",
      "mutated_line": "vis[c] = 0",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 0\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[c] = 1",
      "mutated_line": "vis[c] = -1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = -1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "tot = [0] * k",
      "mutated_line": "tot = [0] / k",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] / k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "tot = [0] * k",
      "mutated_line": "tot = [0] + k",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] + k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "tot = [0] * k",
      "mutated_line": "tot = [0] ** k",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] ** k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sum_dist = 0",
      "mutated_line": "sum_dist = 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 1\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sum_dist = 0",
      "mutated_line": "sum_dist = -1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = -1\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sum_dist = 0",
      "mutated_line": "sum_dist = 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 1\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pairable = 0",
      "mutated_line": "pairable = 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 1\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pairable = 0",
      "mutated_line": "pairable = -1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = -1\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pairable = 0",
      "mutated_line": "pairable = 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 1\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist -= pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist -= pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] -= dist[ne][k - 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] -= dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][1] += 2",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 2\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][1] += 0",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 0\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][1] += 0",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 0\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][1] += -1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += -1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist -= dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist -= dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 3 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 3 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 1 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 1 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 0 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 0 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 1 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 1 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * -2 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * -2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n - 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n - 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n * 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n * 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj = [[] for i in range(n + 1)]",
      "mutated_line": "adj = [[] for i in range(n - 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n - 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj = [[] for i in range(n + 1)]",
      "mutated_line": "adj = [[] for i in range(n * 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n * 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = s[-1]",
      "mutated_line": "c = s[-2]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-2]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = s[-1]",
      "mutated_line": "c = s[-0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-0]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = s[-1]",
      "mutated_line": "c = s[-0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-0]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "c = s[-1]",
      "mutated_line": "c = s[--1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[--1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) - sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) - sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) * (sum_dist * sum([dist[ne][i][1] for i in range(k)]))",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) * (sum_dist * sum([dist[ne][i][1] for i in range(k)]))\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "tot[i] += dist[ne][i][1]",
      "mutated_line": "tot[i] -= dist[ne][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] -= dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "pairable += dist[ne][i][1]",
      "mutated_line": "pairable -= dist[ne][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable -= dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "sum_dist += dist[ne][i][0]",
      "mutated_line": "sum_dist -= dist[ne][i][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist -= dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][2] += 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][2] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][0] += 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][0] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][0] += 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][0] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][0][-1] += 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][-1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] - (i + k - 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] - (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] * ((i + k - 1) // k * dist[c][i][1])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] * ((i + k - 1) // k * dist[c][i][1])\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[1] * 2 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[1] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[-1] * 2 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[-1] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[1] * 2 for j in range(k)] for i in range(n + 1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[1] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 2)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 2)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 0)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 0)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 0)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 0)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]",
      "mutated_line": "dist = [[[0] * 2 for j in range(k)] for i in range(n + -1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + -1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for i in range(n + 1)]",
      "mutated_line": "adj = [[] for i in range(n + 2)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 2)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for i in range(n + 1)]",
      "mutated_line": "adj = [[] for i in range(n + 0)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for i in range(n + 1)]",
      "mutated_line": "adj = [[] for i in range(n + 0)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj = [[] for i in range(n + 1)]",
      "mutated_line": "adj = [[] for i in range(n + -1)]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + -1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tot = [0] * k",
      "mutated_line": "tot = [1] * k",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [1] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tot = [0] * k",
      "mutated_line": "tot = [-1] * k",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [-1] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "tot = [0] * k",
      "mutated_line": "tot = [1] * k",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [1] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable / sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable / sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable + sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable + sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable ** sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable ** sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist / sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist / sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + (sum_dist + sum([dist[ne][i][1] for i in range(k)]))",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + (sum_dist + sum([dist[ne][i][1] for i in range(k)]))\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist ** sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist ** sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist -= (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist -= (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] -= dist[ne][(i + k - 1) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] -= dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][1] += dist[ne][k - 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][1] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][-1] += dist[ne][k - 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][-1] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][1] += dist[ne][k - 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][1] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - 1][2]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][2]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - 1][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][0]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - 1][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][0]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - 1][-1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][-1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][1][1] += 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][1][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][-1][1] += 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][-1][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dist[c][0][1] += 1",
      "mutated_line": "dist[c][1][1] += 1",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][1][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k / dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k / dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + ((i + k - 1) // k + dist[c][i][1])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + ((i + k - 1) // k + dist[c][i][1])\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + ((i + k - 1) // k) ** dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + ((i + k - 1) // k) ** dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] / tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] / tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] + tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] + tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += ((i + j + 2 + k - 1) // k * dist[ne][i][1]) ** tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += ((i + j + 2 + k - 1) // k * dist[ne][i][1]) ** tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tot[i] += dist[ne][i][1]",
      "mutated_line": "tot[i] += dist[ne][i][2]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][2]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tot[i] += dist[ne][i][1]",
      "mutated_line": "tot[i] += dist[ne][i][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][0]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tot[i] += dist[ne][i][1]",
      "mutated_line": "tot[i] += dist[ne][i][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][0]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "tot[i] += dist[ne][i][1]",
      "mutated_line": "tot[i] += dist[ne][i][-1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][-1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pairable += dist[ne][i][1]",
      "mutated_line": "pairable += dist[ne][i][2]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][2]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pairable += dist[ne][i][1]",
      "mutated_line": "pairable += dist[ne][i][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][0]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pairable += dist[ne][i][1]",
      "mutated_line": "pairable += dist[ne][i][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][0]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "pairable += dist[ne][i][1]",
      "mutated_line": "pairable += dist[ne][i][-1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][-1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "sum_dist += dist[ne][i][0]",
      "mutated_line": "sum_dist += dist[ne][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][1]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "sum_dist += dist[ne][i][0]",
      "mutated_line": "sum_dist += dist[ne][i][-1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][-1]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "sum_dist += dist[ne][i][0]",
      "mutated_line": "sum_dist += dist[ne][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][1]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in range(2):",
      "mutated_line": "for j in range(3):",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(3):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in range(2):",
      "mutated_line": "for j in range(1):",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(1):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in range(2):",
      "mutated_line": "for j in range(0):",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(0):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in range(2):",
      "mutated_line": "for j in range(1):",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(1):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for j in range(2):",
      "mutated_line": "for j in range(-2):",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(-2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][1][0] += dist[ne][k - 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][1][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][-1][0] += dist[ne][k - 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][-1][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][1][0] += dist[ne][k - 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][1][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k + 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k + 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k * 1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k * 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][1] + (i + k - 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][1] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][-1] + (i + k - 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][-1] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][1] + (i + k - 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][1] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 1) / k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) / k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 1) * k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) * k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) // k / dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k / dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += ((i + j + 2 + k - 1) // k + dist[ne][i][1]) * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += ((i + j + 2 + k - 1) // k + dist[ne][i][1]) * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += ((i + j + 2 + k - 1) // k) ** dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += ((i + j + 2 + k - 1) // k) ** dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - 2][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 2][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - 0][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 0][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - 0][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 0][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dist[c][0][0] += dist[ne][k - 1][1]",
      "mutated_line": "dist[c][0][0] += dist[ne][k - -1][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - -1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k + 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k + 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k) * 1 // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k) * 1 // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][2]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][2]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][0]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][0]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][0]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][-1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][-1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) / k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) / k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) * k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) * k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i + k - 1) * k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) * k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][i + k - 1 + k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][i + k - 1 + k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i - k - 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i - k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i * k - 1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i * k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 2) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 2) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 0) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 0) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - 0) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 0) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]",
      "mutated_line": "tot_dist += dist[c][i][0] + (i + k - -1) // k * dist[c][i][1]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - -1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][1] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][1] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][-1] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][-1] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][1] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][1] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][2] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][2] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][0] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][0] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][0] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][0] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])",
      "mutated_line": "tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][-1] for i in range(k)])",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][-1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k + 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k + 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k) * 1 // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k) * 1 // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][2] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][2] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][0] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][0] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][0] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][0] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][-1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][-1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i + k + 1) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k + 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i + k) * 1 % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k) * 1 % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 - k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 - k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += ((i + j + 2) * k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += ((i + j + 2) * k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 2) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 2) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 0) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 0) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - 0) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 0) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 2 + k - -1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - -1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i - k - 1) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i - k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i * k - 1) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i * k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i + k - 2) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 2) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i + k - 0) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 0) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i + k - 0) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 0) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "dist[c][i][j] += dist[ne][(i + k - 1) % k][j]",
      "mutated_line": "dist[c][i][j] += dist[ne][(i + k - -1) % k][j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - -1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j - 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j - 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += ((i + j) * 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += ((i + j) * 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i - j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i - j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i * j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i * j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 3 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 3 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 1 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 1 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 0 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 0 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + 1 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + 1 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "tot_dist += (i + j + 2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "mutated_line": "tot_dist += (i + j + -2 + k - 1) // k * dist[ne][i][1] * tot[j]",
      "code": "def calculate_min_jumps_sum(n, k, edges):\n    from collections import deque\n    tot_dist = 0\n    vis = [0] * (n + 1)\n    dist = [[[0] * 2 for j in range(k)] for i in range(n + 1)]\n    adj = [[] for i in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    s = deque([1])\n    while s:\n        c = s[-1]\n        if not vis[c]:\n            vis[c] = 1\n            for ne in adj[c]:\n                if not vis[ne]:\n                    s.append(ne)\n        else:\n            tot = [0] * k\n            sum_dist = 0\n            pairable = 0\n            for ne in adj[c]:\n                tot_dist += pairable * sum([dist[ne][i][0] for i in range(k)]) + sum_dist * sum([dist[ne][i][1] for i in range(k)])\n                for i in range(k):\n                    for j in range(k):\n                        tot_dist += (i + j + -2 + k - 1) // k * dist[ne][i][1] * tot[j]\n                for i in range(k):\n                    tot[i] += dist[ne][i][1]\n                    pairable += dist[ne][i][1]\n                    sum_dist += dist[ne][i][0]\n            for ne in adj[c]:\n                for i in range(k):\n                    for j in range(2):\n                        dist[c][i][j] += dist[ne][(i + k - 1) % k][j]\n                dist[c][0][0] += dist[ne][k - 1][1]\n            dist[c][0][1] += 1\n            for i in range(k):\n                tot_dist += dist[c][i][0] + (i + k - 1) // k * dist[c][i][1]\n            s.pop()\n    return tot_dist"
    }
  ]
}