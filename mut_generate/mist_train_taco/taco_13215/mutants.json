{
  "task_id": "taco_13215",
  "entry_point": "find_largest_unmarked_square",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "max_size = 0",
      "mutated_line": "max_size = 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 1\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "max_size = 0",
      "mutated_line": "max_size = -1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = -1\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "max_size = 0",
      "mutated_line": "max_size = 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 1\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 1\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return -1\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 1\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[0] * m for _ in range(n)]",
      "mutated_line": "dp = [[0] / m for _ in range(n)]",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] / m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[0] * m for _ in range(n)]",
      "mutated_line": "dp = [[0] + m for _ in range(n)]",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] + m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp = [[0] * m for _ in range(n)]",
      "mutated_line": "dp = [[0] ** m for _ in range(n)]",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] ** m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[1])",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[1])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[-1])",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[-1])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "m = len(grid[0])",
      "mutated_line": "m = len(grid[1])",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[1])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if grid[y][x] == '.':",
      "mutated_line": "if grid[y][x] != '.':",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] != '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[0] * m for _ in range(n)]",
      "mutated_line": "dp = [[1] * m for _ in range(n)]",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[1] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[0] * m for _ in range(n)]",
      "mutated_line": "dp = [[-1] * m for _ in range(n)]",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[-1] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp = [[0] * m for _ in range(n)]",
      "mutated_line": "dp = [[1] * m for _ in range(n)]",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[1] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if grid[y][x] == '.':",
      "mutated_line": "if grid[y][x] == '':",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == 0 and x == 0:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 and x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y != 0 or x == 0:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y != 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == 0 or x != 0:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x != 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[y][x] = 1",
      "mutated_line": "dp[y][x] = 2",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 2\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[y][x] = 1",
      "mutated_line": "dp[y][x] = 0",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 0\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[y][x] = 1",
      "mutated_line": "dp[y][x] = 0",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 0\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[y][x] = 1",
      "mutated_line": "dp[y][x] = -1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = -1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) - 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) - 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) * 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) * 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == 1 or x == 0:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 1 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == -1 or x == 0:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == -1 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == 1 or x == 0:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 1 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == 0 or x == 1:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 1:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == 0 or x == -1:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == -1:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if y == 0 or x == 0:",
      "mutated_line": "if y == 0 or x == 1:",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 1:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 2",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 2\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 0",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 0\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 0",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 0\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + -1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + -1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x + 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x + 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x * 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x * 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x + 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x + 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x * 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x * 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y + 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y + 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y * 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y * 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 2], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 2], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 0], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 0], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 0], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 0], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - -1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - -1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y + 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y + 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y * 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y * 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 2]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 2]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 0]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 0]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 0]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 0]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - -1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - -1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 2][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 2][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 0][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 0][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 0][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 0][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - -1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - -1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 2][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 2][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 0][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 0][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 0][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 0][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - 1][x - 1]) + 1",
      "mutated_line": "dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - -1][x - 1]) + 1",
      "code": "def find_largest_unmarked_square(grid: list[str]) -> int:\n    \"\"\"\n    Finds the length of the side of the largest square consisting of only unmarked squares in a given grid.\n\n    Parameters:\n    grid (list[str]): A list of strings where each string represents a row in the grid.\n                      '.' indicates an unmarked square, and '*' indicates a marked square.\n\n    Returns:\n    int: The length of the side of the largest square consisting of only unmarked squares.\n    \"\"\"\n    if not grid:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    max_size = 0\n    dp = [[0] * m for _ in range(n)]\n    for y in range(n):\n        for x in range(m):\n            if grid[y][x] == '.':\n                if y == 0 or x == 0:\n                    dp[y][x] = 1\n                else:\n                    dp[y][x] = min(dp[y - 1][x], dp[y][x - 1], dp[y - -1][x - 1]) + 1\n                max_size = max(max_size, dp[y][x])\n    return max_size"
    }
  ]
}