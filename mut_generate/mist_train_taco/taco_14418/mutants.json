{
  "task_id": "taco_14418",
  "entry_point": "find_shortest_paths",
  "mutant_count": 54,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 99999999999999",
      "mutated_line": "INF = 100000000000000",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 100000000000000\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 99999999999999",
      "mutated_line": "INF = 99999999999998",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999998\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 99999999999999",
      "mutated_line": "INF = 0",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 0\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 99999999999999",
      "mutated_line": "INF = 1",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 1\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "INF = 99999999999999",
      "mutated_line": "INF = -99999999999999",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = -99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d[r] = 0",
      "mutated_line": "d[r] = 1",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 1\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d[r] = 0",
      "mutated_line": "d[r] = -1",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = -1\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "d[r] = 0",
      "mutated_line": "d[r] = 1",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 1\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if bellman_ford() == -1:",
      "mutated_line": "return 'NEGATIVE CYCLE'",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() != -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "if bellman_ford() == -1:",
      "mutated_line": "return 'NEGATIVE CYCLE'",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == +1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return \"NEGATIVE CYCLE\"",
      "mutated_line": "return ''",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return ''\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if d_i == INF:",
      "mutated_line": "if d_i != INF:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i != INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n = stack[0]",
      "mutated_line": "n = stack[1]",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[1]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n = stack[0]",
      "mutated_line": "n = stack[-1]",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[-1]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n = stack[0]",
      "mutated_line": "n = stack[1]",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[1]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if dst in yet:",
      "mutated_line": "if dst not in yet:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst not in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for _ in range(V_num - 1):",
      "mutated_line": "for _ in range(V_num + 1):",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num + 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for _ in range(V_num - 1):",
      "mutated_line": "for _ in range(V_num * 1):",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num * 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] >= w + d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] >= w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] <= w + d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] <= w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] != w + d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] != w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bellman_ford() == -1:",
      "mutated_line": "return 'NEGATIVE CYCLE'",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -2:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bellman_ford() == -1:",
      "mutated_line": "return 'NEGATIVE CYCLE'",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -0:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bellman_ford() == -1:",
      "mutated_line": "return 'NEGATIVE CYCLE'",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -0:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if bellman_ford() == -1:",
      "mutated_line": "return 'NEGATIVE CYCLE'",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == --1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for _ in range(V_num - 1):",
      "mutated_line": "for _ in range(V_num - 2):",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 2):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for _ in range(V_num - 1):",
      "mutated_line": "for _ in range(V_num - 0):",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 0):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for _ in range(V_num - 1):",
      "mutated_line": "for _ in range(V_num - 0):",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 0):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for _ in range(V_num - 1):",
      "mutated_line": "for _ in range(V_num - -1):",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - -1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] >= w + d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] >= w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] <= w + d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] <= w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] != w + d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] != w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] > w - d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w - d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] > w * d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w * d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return +1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[0] not in yet or e[1] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet or e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "result.append(\"INF\")",
      "mutated_line": "result.append('')",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] > w - d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w - d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if d[dst] > w + d[src]:",
      "mutated_line": "if d[dst] > w * d[src]:",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w * d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[dst] = w + d[src]",
      "mutated_line": "d[dst] = w - d[src]",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w - d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d[dst] = w + d[src]",
      "mutated_line": "d[dst] = w * d[src]",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w * d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -2\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -0\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -0\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return --1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[0] in yet and e[1] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[1] not in yet and e[1] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[1] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[-1] not in yet and e[1] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[-1] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[1] not in yet and e[1] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[1] not in yet and e[1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[2] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[2] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[0] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[0] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[0] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[0] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[1] not in yet, edges))",
      "mutated_line": "filtered_edges = list(filter(lambda e: e[0] not in yet and e[-1] not in yet, edges))",
      "code": "import collections\n\ndef find_shortest_paths(V_num, E_num, r, edges):\n    adjc_list = [[] for _ in range(V_num)]\n    for (src, dst, w) in edges:\n        adjc_list[src].append((w, dst))\n    INF = 99999999999999\n    d = [INF for _ in range(V_num)]\n    d[r] = 0\n    stack = collections.deque()\n    yet = [ele for ele in range(V_num)]\n\n    def dfs(stack):\n        if not stack:\n            return\n        n = stack[0]\n        yet.remove(n)\n        for (_, dst) in adjc_list[n]:\n            if dst in yet:\n                stack.appendleft(dst)\n                dfs(stack)\n        else:\n            stack.popleft()\n\n    def bellman_ford():\n        for _ in range(V_num - 1):\n            for (src, dst, w) in edges:\n                if d[dst] > w + d[src]:\n                    d[dst] = w + d[src]\n        for (src, dst, w) in edges:\n            if d[dst] > w + d[src]:\n                return -1\n        return\n    stack.clear()\n    stack.appendleft(r)\n    dfs(stack)\n    filtered_edges = list(filter(lambda e: e[0] not in yet and e[-1] not in yet, edges))\n    if bellman_ford() == -1:\n        return 'NEGATIVE CYCLE'\n    result = []\n    for d_i in d:\n        if d_i == INF:\n            result.append('INF')\n        else:\n            result.append(d_i)\n    return result"
    }
  ]
}