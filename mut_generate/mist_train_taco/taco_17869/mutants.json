{
  "task_id": "taco_17869",
  "entry_point": "count_restoration_ways",
  "mutant_count": 177,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 - 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 * 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] / (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] / (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] + (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] + (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] ** (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] ** (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] / (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] / (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] + (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] + (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] ** (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] ** (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "impossibru = 0",
      "mutated_line": "impossibru = 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 1\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "impossibru = 0",
      "mutated_line": "impossibru = -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = -1\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "impossibru = 0",
      "mutated_line": "impossibru = 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 1\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 2\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 0\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 0\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = -1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "I[i] += I[i - 1]",
      "mutated_line": "I[i] -= I[i - 1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] -= I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "D[i] += D[i - 1]",
      "mutated_line": "D[i] -= D[i - 1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] -= D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx - mn + 1) * mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) * mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx - mn + 1) + mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) + mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 * 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 + 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 8\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 6\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 0\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 1\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + -7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] * (N - 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N - 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] * (N * 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N * 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] * (N - 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N - 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] * (N * 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N * 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if x == 'I':",
      "mutated_line": "if x != 'I':",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x != 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "I[L] += 1",
      "mutated_line": "I[L] -= 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] -= 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "I[R] -= 1",
      "mutated_line": "I[R] += 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] += 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "D[L] += 1",
      "mutated_line": "D[L] -= 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] -= 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "D[R] -= 1",
      "mutated_line": "D[R] += 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] += 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (2, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (2, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (0, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (0, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (0, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (0, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (-1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (-1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if I[i] and D[i]:",
      "mutated_line": "if I[i] or D[i]:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] or D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "LCR",
      "lineno": 27,
      "original_line": "if not I[i] and not D[i]:",
      "mutated_line": "if not I[i] or not D[i]:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] or not D[i]:\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if mn > mx:",
      "mutated_line": "if mn >= mx:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn >= mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if mn > mx:",
      "mutated_line": "if mn <= mx:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn <= mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if mn > mx:",
      "mutated_line": "if mn != mx:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn != mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if A[i] != -1:",
      "mutated_line": "if A[i] == -1:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] == -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans / (mx - mn + 1) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans / (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = (ans + (mx - mn + 1)) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = (ans + (mx - mn + 1)) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans ** (mx - mn + 1) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans ** (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 0 if impossibru else ans",
      "mutated_line": "return 1 if impossibru else ans",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 1 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 0 if impossibru else ans",
      "mutated_line": "return -1 if impossibru else ans",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return -1 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 0 if impossibru else ans",
      "mutated_line": "return 1 if impossibru else ans",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 1 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 11 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 9 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 0 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 1 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = -10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 10 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 8 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 0 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 1 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** -9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [1] * (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [1] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [-1] * (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [-1] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [1] * (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [1] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] * (N + 3)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 3)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] * (N + 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 1)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] * (N + 0)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 0)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] * (N + 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 1)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "I = [0] * (N + 2)",
      "mutated_line": "I = [0] * (N + -2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + -2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [1] * (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [1] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [-1] * (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [-1] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [1] * (N + 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [1] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] * (N + 3)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 3)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] * (N + 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 1)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] * (N + 0)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 0)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] * (N + 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 1)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "D = [0] * (N + 2)",
      "mutated_line": "D = [0] * (N + -2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + -2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if x == 'I':",
      "mutated_line": "if x == '':",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == '':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "I[L] += 1",
      "mutated_line": "I[L] += 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 2\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "I[L] += 1",
      "mutated_line": "I[L] += 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 0\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "I[L] += 1",
      "mutated_line": "I[L] += 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 0\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "I[L] += 1",
      "mutated_line": "I[L] += -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += -1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "I[R] -= 1",
      "mutated_line": "I[R] -= 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 2\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "I[R] -= 1",
      "mutated_line": "I[R] -= 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 0\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "I[R] -= 1",
      "mutated_line": "I[R] -= 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 0\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "I[R] -= 1",
      "mutated_line": "I[R] -= -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= -1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "D[L] += 1",
      "mutated_line": "D[L] += 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 2\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "D[L] += 1",
      "mutated_line": "D[L] += 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 0\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "D[L] += 1",
      "mutated_line": "D[L] += 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 0\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "D[L] += 1",
      "mutated_line": "D[L] += -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += -1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D[R] -= 1",
      "mutated_line": "D[R] -= 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 2\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D[R] -= 1",
      "mutated_line": "D[R] -= 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 0\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D[R] -= 1",
      "mutated_line": "D[R] -= 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 0\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "D[R] -= 1",
      "mutated_line": "D[R] -= -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= -1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "I[i] += I[i - 1]",
      "mutated_line": "I[i] += I[i + 1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i + 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "I[i] += I[i - 1]",
      "mutated_line": "I[i] += I[i * 1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i * 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "D[i] += D[i - 1]",
      "mutated_line": "D[i] += D[i + 1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i + 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "D[i] += D[i - 1]",
      "mutated_line": "D[i] += D[i * 1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i * 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 2\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 0\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 0\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = -1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) * mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) + mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "mn += 1",
      "mutated_line": "mn -= 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn -= 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 2\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 0\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 0\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = -1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "if A[i] != -1:",
      "mutated_line": "if A[i] != +1:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != +1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx - mn - 1) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn - 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * ((mx - mn) * 1) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * ((mx - mn) * 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "I[i] += I[i - 1]",
      "mutated_line": "I[i] += I[i - 2]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 2]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "I[i] += I[i - 1]",
      "mutated_line": "I[i] += I[i - 0]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 0]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "I[i] += I[i - 1]",
      "mutated_line": "I[i] += I[i - 0]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 0]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "I[i] += I[i - 1]",
      "mutated_line": "I[i] += I[i - -1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - -1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "D[i] += D[i - 1]",
      "mutated_line": "D[i] += D[i - 2]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 2]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "D[i] += D[i - 1]",
      "mutated_line": "D[i] += D[i - 0]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 0]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "D[i] += D[i - 1]",
      "mutated_line": "D[i] += D[i - 0]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 0]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "D[i] += D[i - 1]",
      "mutated_line": "D[i] += D[i - -1]",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - -1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans / (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = (ans + (mx - mn + 1)) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans ** (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (2, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (2, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (0, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (0, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (0, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (0, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "mn, mx = 1, K",
      "mutated_line": "(mn, mx) = (-1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (-1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mn += 1",
      "mutated_line": "mn += 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 2\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mn += 1",
      "mutated_line": "mn += 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 0\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mn += 1",
      "mutated_line": "mn += 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 0\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "mn += 1",
      "mutated_line": "mn += -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += -1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "mx -= 1",
      "mutated_line": "mx += 1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx += 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if A[i] != -1:",
      "mutated_line": "if A[i] != -2:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -2:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if A[i] != -1:",
      "mutated_line": "if A[i] != -0:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -0:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if A[i] != -1:",
      "mutated_line": "if A[i] != -0:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -0:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if A[i] != -1:",
      "mutated_line": "if A[i] != --1:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != --1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if not mn <= A[i] <= mx:",
      "mutated_line": "if not mn < A[i] <= mx:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn < A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if not mn <= A[i] <= mx:",
      "mutated_line": "if not mn > A[i] <= mx:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn > A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if not mn <= A[i] <= mx:",
      "mutated_line": "if not mn == A[i] <= mx:",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn == A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 2\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 0\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 0\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "impossibru = 1",
      "mutated_line": "impossibru = -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = -1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx + mn + 1) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx + mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx * mn + 1) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx * mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx - mn + 2) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 2) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx - mn + 0) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 0) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx - mn + 0) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 0) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "ans = ans * (mx - mn + -1) % mod",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + -1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn - 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * ((mx - mn) * 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mx = min(mx + 1, K)",
      "mutated_line": "mx = min(mx - 1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx - 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "mx = min(mx + 1, K)",
      "mutated_line": "mx = min(mx * 1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx * 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mx -= 1",
      "mutated_line": "mx -= 2",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 2\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mx -= 1",
      "mutated_line": "mx -= 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 0\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mx -= 1",
      "mutated_line": "mx -= 0",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 0\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mx -= 1",
      "mutated_line": "mx -= -1",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= -1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx + mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx * mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 2) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 0) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 0) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = ans * (mx - mn + 1) % mod",
      "mutated_line": "(mn, mx) = (1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + -1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = min(mx + 1, K)",
      "mutated_line": "mx = min(mx + 2, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 2, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = min(mx + 1, K)",
      "mutated_line": "mx = min(mx + 0, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 0, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = min(mx + 1, K)",
      "mutated_line": "mx = min(mx + 0, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 0, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "mx = min(mx + 1, K)",
      "mutated_line": "mx = min(mx + -1, K)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + -1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(2, mn - 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(2, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(0, mn - 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(0, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(0, mn - 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(0, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(-1, mn - 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(-1, mn - 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(1, mn + 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn + 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(1, mn * 1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn * 1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(1, mn - 2)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 2)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(1, mn - 0)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 0)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(1, mn - 0)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - 0)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "mn = max(1, mn - 1)",
      "mutated_line": "mn = max(1, mn - -1)",
      "code": "def count_restoration_ways(N, M, K, A, restrictions):\n    mod = 10 ** 9 + 7\n    I = [0] * (N + 2)\n    D = [0] * (N + 2)\n    for (x, L, R) in restrictions:\n        (L, R) = (int(L), int(R))\n        if x == 'I':\n            I[L] += 1\n            I[R] -= 1\n        else:\n            D[L] += 1\n            D[R] -= 1\n    impossibru = 0\n    ans = 1\n    (mn, mx) = (1, K)\n    for i in range(N):\n        I[i] += I[i - 1]\n        D[i] += D[i - 1]\n        if I[i] and D[i]:\n            impossibru = 1\n            break\n        if not I[i] and (not D[i]):\n            ans = ans * (mx - mn + 1) % mod\n            (mn, mx) = (1, K)\n        elif I[i]:\n            mx = min(mx + 1, K)\n            mn += 1\n        elif D[i]:\n            mn = max(1, mn - -1)\n            mx -= 1\n        if mn > mx:\n            impossibru = 1\n            break\n        if A[i] != -1:\n            if not mn <= A[i] <= mx:\n                impossibru = 1\n                break\n            mn = mx = A[i]\n    ans = ans * (mx - mn + 1) % mod\n    return 0 if impossibru else ans"
    }
  ]
}