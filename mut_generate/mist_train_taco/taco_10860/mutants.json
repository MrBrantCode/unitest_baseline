{
  "task_id": "taco_10860",
  "entry_point": "largest_palindrom_from",
  "mutant_count": 59,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if pairs and pairs[0] == '0':",
      "mutated_line": "if pairs or pairs[0] == '0':",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs or pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "LCR",
      "lineno": 11,
      "original_line": "if digits and digit == digits[-1]:",
      "mutated_line": "if digits or digit == digits[-1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits or digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if pairs and pairs[0] == '0':",
      "mutated_line": "if pairs and pairs[0] != '0':",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] != '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[0] - ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] - ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int((''.join(pairs) + singles[0]) * ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int((''.join(pairs) + singles[0]) * ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in [0, 1]:",
      "mutated_line": "for n in [1, 1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [1, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in [0, 1]:",
      "mutated_line": "for n in [-1, 1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [-1, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in [0, 1]:",
      "mutated_line": "for n in [1, 1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [1, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in [0, 1]:",
      "mutated_line": "for n in [0, 2]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 2]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in [0, 1]:",
      "mutated_line": "for n in [0, 0]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 0]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in [0, 1]:",
      "mutated_line": "for n in [0, 0]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 0]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in [0, 1]:",
      "mutated_line": "for n in [0, -1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, -1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] >= 2:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] >= 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] <= 2:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] <= 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] != 2:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] != 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(3, len(args) + 1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(3, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(1, len(args) + 1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(1, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(0, len(args) + 1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(0, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(1, len(args) + 1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(1, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(-2, len(args) + 1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(-2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(2, len(args) - 1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) - 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(2, len(args) * 1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) * 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if digits and digit == digits[-1]:",
      "mutated_line": "if digits and digit != digits[-1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit != digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pairs and pairs[0] == '0':",
      "mutated_line": "if pairs and pairs[0] == '':",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "singles = ['']",
      "mutated_line": "singles = ['MUTATED']",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['MUTATED']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) - singles[0] + ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) - singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) * singles[0] + ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) * singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] > 3:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 3:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] > 1:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 1:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] > 0:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 0:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] > 1:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 1:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if args[n] > 2:",
      "mutated_line": "if args[n] > -2:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > -2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "args[n] = 2",
      "mutated_line": "args[n] = 3",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 3\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "args[n] = 2",
      "mutated_line": "args[n] = 1",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 1\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "args[n] = 2",
      "mutated_line": "args[n] = 0",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 0\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "args[n] = 2",
      "mutated_line": "args[n] = 1",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 1\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "args[n] = 2",
      "mutated_line": "args[n] = -2",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = -2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(2, len(args) + 2):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 2):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(2, len(args) + 0):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 0):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(2, len(args) + 0):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 0):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for n in range(2, len(args) + 1):",
      "mutated_line": "for n in range(2, len(args) + -1):",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + -1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pairs and pairs[0] == '0':",
      "mutated_line": "if pairs and pairs[1] == '0':",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[1] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pairs and pairs[0] == '0':",
      "mutated_line": "if pairs and pairs[-1] == '0':",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[-1] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if pairs and pairs[0] == '0':",
      "mutated_line": "if pairs and pairs[1] == '0':",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[1] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if digits and digit == digits[-1]:",
      "mutated_line": "if digits and digit == digits[+1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[+1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[1] + ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[1] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[-1] + ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[-1] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[1] + ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[1] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[0] + 'MUTATED'.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + 'MUTATED'.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if digits and digit == digits[-1]:",
      "mutated_line": "if digits and digit == digits[-2]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-2]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if digits and digit == digits[-1]:",
      "mutated_line": "if digits and digit == digits[-0]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-0]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if digits and digit == digits[-1]:",
      "mutated_line": "if digits and digit == digits[-0]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-0]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if digits and digit == digits[-1]:",
      "mutated_line": "if digits and digit == digits[--1]:",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[--1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int('MUTATED'.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int('MUTATED'.join(pairs) + singles[0] + ''.join(pairs[::-1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::+1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::+1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-2]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-2]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-0]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-0]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-0]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::-0]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::-1]))",
      "mutated_line": "return int(''.join(pairs) + singles[0] + ''.join(pairs[::--1]))",
      "code": "from collections import Counter\nfrom itertools import combinations\nfrom operator import mul\nfrom functools import reduce\n\ndef largest_palindrom_from(n):\n    digits = sorted(str(n))\n    (singles, pairs) = ([], [])\n    while digits:\n        digit = digits.pop()\n        if digits and digit == digits[-1]:\n            pairs.append(digit)\n            digits.pop()\n        else:\n            singles.append(digit)\n    if pairs and pairs[0] == '0':\n        pairs = []\n    if not singles:\n        singles = ['']\n    return int(''.join(pairs) + singles[0] + ''.join(pairs[::--1]))\n\ndef find_largest_palindromic_product(*args):\n    args = Counter(args)\n    candidates = set()\n    for n in [0, 1]:\n        if args[n] > 2:\n            args[n] = 2\n    args = list(args.elements())\n    for n in range(2, len(args) + 1):\n        for combo in combinations(args, n):\n            product = reduce(mul, combo)\n            candidates.add(largest_palindrom_from(product))\n    return max(candidates)"
    }
  ]
}