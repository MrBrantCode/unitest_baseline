{
  "task_id": "taco_19144",
  "entry_point": "fraction_to_decimal",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator * denominator <= 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator <= 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator * denominator >= 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator >= 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator * denominator != 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator != 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "integer_part = numerator // denominator",
      "mutated_line": "integer_part = numerator / denominator",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator / denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "integer_part = numerator // denominator",
      "mutated_line": "integer_part = numerator * denominator",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator * denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "new_numerator = numerator - integer_part * denominator",
      "mutated_line": "new_numerator = numerator + integer_part * denominator",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator + integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "new_numerator = numerator - integer_part * denominator",
      "mutated_line": "new_numerator = numerator * (integer_part * denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator * (integer_part * denominator)\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if new_numerator == 0:",
      "mutated_line": "if new_numerator != 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator != 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "digit_location = 0",
      "mutated_line": "digit_location = 1",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 1\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "digit_location = 0",
      "mutated_line": "digit_location = -1",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = -1\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "digit_location = 0",
      "mutated_line": "digit_location = 1",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 1\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "is_repeating = False",
      "mutated_line": "is_repeating = True",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = True\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while True:",
      "mutated_line": "(new_digit, residual) = single_digit(residual, denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while False:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "digit_location += 1",
      "mutated_line": "digit_location -= 1",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location -= 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator / denominator < 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator / denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator + denominator < 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator + denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator ** denominator < 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator ** denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator * denominator < 1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 1:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator * denominator < -1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < -1:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if numerator * denominator < 0:",
      "mutated_line": "if numerator * denominator < 1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 1:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "add_negative = True",
      "mutated_line": "add_negative = False",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = False\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "add_negative = False",
      "mutated_line": "add_negative = True",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = True\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "new_numerator = numerator - integer_part * denominator",
      "mutated_line": "new_numerator = numerator - integer_part / denominator",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part / denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "new_numerator = numerator - integer_part * denominator",
      "mutated_line": "new_numerator = numerator - (integer_part + denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - (integer_part + denominator)\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "new_numerator = numerator - integer_part * denominator",
      "mutated_line": "new_numerator = numerator - integer_part ** denominator",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part ** denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if new_numerator == 0:",
      "mutated_line": "if new_numerator == 1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 1:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if new_numerator == 0:",
      "mutated_line": "if new_numerator == -1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == -1:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if new_numerator == 0:",
      "mutated_line": "if new_numerator == 1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 1:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digit_location += 1",
      "mutated_line": "digit_location += 2",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 2\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digit_location += 1",
      "mutated_line": "digit_location += 0",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 0\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digit_location += 1",
      "mutated_line": "digit_location += 0",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 0\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "digit_location += 1",
      "mutated_line": "digit_location += -1",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += -1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if residual == 0:",
      "mutated_line": "if residual != 0:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual != 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return '-' + result",
      "mutated_line": "return '-' - result",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' - result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return '-' + result",
      "mutated_line": "return '-' * result",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' * result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 10 * value * denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value * denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 10 * value + denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value + denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return '-' + result",
      "mutated_line": "return '-' - result",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' - result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return '-' + result",
      "mutated_line": "return '-' * result",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' * result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if residual == 0:",
      "mutated_line": "if residual == 1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 1:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if residual == 0:",
      "mutated_line": "if residual == -1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == -1:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if residual == 0:",
      "mutated_line": "if residual == 1:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 1:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif residual in dict_residuals:",
      "mutated_line": "elif residual not in dict_residuals:",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual not in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"",
      "mutated_line": "result = f\"{integer_part}{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"",
      "mutated_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}{''.join(digit_array[loc:])})\"",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}{''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"",
      "mutated_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])}\"",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])}\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "result = f\"{integer_part}.{''.join(digit_array)}\"",
      "mutated_line": "result = f\"{integer_part}{''.join(digit_array)}\"",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return '-' + result",
      "mutated_line": "return '' + result",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value / denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value / denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value * denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value * denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 10 / value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 / value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), (10 + value) % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), (10 + value) % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 10 ** value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 ** value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return '-' + result",
      "mutated_line": "return '' + result",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "is_repeating = True",
      "mutated_line": "is_repeating = False",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = False\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 / value // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 / value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int((10 + value) // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int((10 + value) // denominator), 10 * value % denominator)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 ** value // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 ** value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 11 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 11 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 9 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 9 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 0 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 0 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), 1 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 1 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(10 * value // denominator), -10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), -10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(11 * value // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(11 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(9 * value // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(9 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(0 * value // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(0 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(1 * value // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(1 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (int(10 * value // denominator), 10 * value % denominator)",
      "mutated_line": "return (int(-10 * value // denominator), 10 * value % denominator)",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(-10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"",
      "mutated_line": "result = f\"{integer_part}.{'MUTATED'.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{'MUTATED'.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"",
      "mutated_line": "result = f\"{integer_part}.{''.join(digit_array[:loc])}({'MUTATED'.join(digit_array[loc:])})\"",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({'MUTATED'.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{''.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "result = f\"{integer_part}.{''.join(digit_array)}\"",
      "mutated_line": "result = f\"{integer_part}.{'MUTATED'.join(digit_array)}\"",
      "code": "def fraction_to_decimal(numerator: int, denominator: int) -> str:\n    if numerator * denominator < 0:\n        add_negative = True\n    else:\n        add_negative = False\n    (numerator, denominator) = (abs(numerator), abs(denominator))\n    integer_part = numerator // denominator\n    new_numerator = numerator - integer_part * denominator\n    if new_numerator == 0:\n        result = str(integer_part)\n        if add_negative:\n            return '-' + result\n        else:\n            return result\n    dict_residuals = {}\n    digit_location = 0\n    digit_array = []\n    residual = new_numerator\n    is_repeating = False\n    while True:\n        (new_digit, residual) = single_digit(residual, denominator)\n        digit_location += 1\n        if residual == 0:\n            digit_array.append(str(new_digit))\n            break\n        elif residual in dict_residuals:\n            digit_array.append(str(new_digit))\n            is_repeating = True\n            break\n        else:\n            dict_residuals[residual] = digit_location\n            digit_array.append(str(new_digit))\n    if is_repeating:\n        loc = dict_residuals[residual]\n        result = f\"{integer_part}.{''.join(digit_array[:loc])}({''.join(digit_array[loc:])})\"\n    else:\n        result = f\"{integer_part}.{'MUTATED'.join(digit_array)}\"\n    if add_negative:\n        return '-' + result\n    else:\n        return result\n\ndef single_digit(value: int, denominator: int) -> tuple[int, int]:\n    return (int(10 * value // denominator), 10 * value % denominator)"
    }
  ]
}