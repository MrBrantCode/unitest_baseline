{
  "task_id": "taco_12327",
  "entry_point": "smallest_lexicographical_subsequence",
  "mutant_count": 278,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = ''",
      "mutated_line": "ans = 'MUTATED'",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = 'MUTATED'\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nn = 1",
      "mutated_line": "nn = 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 2\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nn = 1",
      "mutated_line": "nn = 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 0\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nn = 1",
      "mutated_line": "nn = 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 0\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "nn = 1",
      "mutated_line": "nn = -1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = -1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while nn < len(arr):",
      "mutated_line": "while nn <= len(arr):",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn <= len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while nn < len(arr):",
      "mutated_line": "while nn >= len(arr):",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn >= len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while nn < len(arr):",
      "mutated_line": "while nn != len(arr):",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn != len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "nn *= 2",
      "mutated_line": "nn /= 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn /= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 2 + 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 + 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 2 * 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 * 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 1\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "start = 0",
      "mutated_line": "start = -1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = -1\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "start = 0",
      "mutated_line": "start = 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 1\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while K > 0:",
      "mutated_line": "while K >= 0:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K >= 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while K > 0:",
      "mutated_line": "while K <= 0:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K <= 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while K > 0:",
      "mutated_line": "while K != 0:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K != 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "ans += xx[0]",
      "mutated_line": "ans -= xx[0]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans -= xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if low == high:",
      "mutated_line": "if low != high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low != high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) / 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) / 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) * 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) * 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if aa[0] != bb[0]:",
      "mutated_line": "if aa[0] == bb[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] == bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if qLow <= low and qHigh >= high:",
      "mutated_line": "if qLow <= low or qHigh >= high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low or qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if qLow > high or qHigh < low:",
      "mutated_line": "if qLow > high and qHigh < low:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high and qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) / 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) / 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) * 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) * 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if b[0] != c[0]:",
      "mutated_line": "if b[0] == c[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] == c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "nn *= 2",
      "mutated_line": "nn *= 3",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 3\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "nn *= 2",
      "mutated_line": "nn *= 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 1\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "nn *= 2",
      "mutated_line": "nn *= 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 0\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "nn *= 2",
      "mutated_line": "nn *= 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 1\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "nn *= 2",
      "mutated_line": "nn *= -2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= -2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn / 2 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn / 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn + 2 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn + 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn ** 2 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn ** 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 2 - 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 2\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 2 - 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 0\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 2 - 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 0\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 2 - -1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - -1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "arrTree = [0 for x in range(nn)]",
      "mutated_line": "arrTree = [1 for x in range(nn)]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [1 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "arrTree = [0 for x in range(nn)]",
      "mutated_line": "arrTree = [-1 for x in range(nn)]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [-1 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "arrTree = [0 for x in range(nn)]",
      "mutated_line": "arrTree = [1 for x in range(nn)]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [1 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 1, len(arr) - 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 1, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, -1, len(arr) - 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, -1, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 1, len(arr) - 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 1, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) + 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) + 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) * 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) * 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 1)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, -1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, -1)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 1)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while K > 0:",
      "mutated_line": "while K > 1:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 1:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while K > 0:",
      "mutated_line": "while K > -1:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > -1:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while K > 0:",
      "mutated_line": "while K > 1:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 1:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "end = len(arr) - K",
      "mutated_line": "end = len(arr) + K",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) + K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "end = len(arr) - K",
      "mutated_line": "end = len(arr) * K",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) * K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[1]) - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) - 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[1]) * 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) * 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "K = K - 1",
      "mutated_line": "K = K + 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K + 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "K = K - 1",
      "mutated_line": "K = K * 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K * 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low - high) // 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low - high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = low * high // 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = low * high // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 3",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 3\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 1\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 0\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 1\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // -2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // -2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 * pos - 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos - 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 * pos * 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos * 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid - 1, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid - 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid * 1, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid * 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos - 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos - 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos * 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos * 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 * pos - 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos - 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 * pos * 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos * 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 * pos - 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos - 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 * pos * 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos * 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if qLow <= low and qHigh >= high:",
      "mutated_line": "if qLow < low and qHigh >= high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow < low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if qLow <= low and qHigh >= high:",
      "mutated_line": "if qLow > low and qHigh >= high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow > low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if qLow <= low and qHigh >= high:",
      "mutated_line": "if qLow == low and qHigh >= high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow == low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if qLow <= low and qHigh >= high:",
      "mutated_line": "if qLow <= low and qHigh > high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh > high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if qLow <= low and qHigh >= high:",
      "mutated_line": "if qLow <= low and qHigh < high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh < high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if qLow <= low and qHigh >= high:",
      "mutated_line": "if qLow <= low and qHigh == high:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh == high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qLow > high or qHigh < low:",
      "mutated_line": "if qLow >= high or qHigh < low:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow >= high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qLow > high or qHigh < low:",
      "mutated_line": "if qLow <= high or qHigh < low:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow <= high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qLow > high or qHigh < low:",
      "mutated_line": "if qLow != high or qHigh < low:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow != high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qLow > high or qHigh < low:",
      "mutated_line": "if qLow > high or qHigh <= low:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh <= low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qLow > high or qHigh < low:",
      "mutated_line": "if qLow > high or qHigh >= low:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh >= low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if qLow > high or qHigh < low:",
      "mutated_line": "if qLow > high or qHigh != low:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh != low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low - high) // 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low - high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = low * high // 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = low * high // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 3",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 3\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 1\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 0\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 1\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // -2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // -2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos - 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos - 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos * 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos * 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid - 1, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid - 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid * 1, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid * 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos - 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos - 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos * 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos * 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 3 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 3 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 1 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 1 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 0 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 0 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * 1 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 1 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "nn = nn * 2 - 1",
      "mutated_line": "nn = nn * -2 - 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * -2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) - 2, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 2, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) - 0, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 0, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) - 0, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 0, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "segmentTree(arr, arrTree, 0, len(arr) - 1, 0)",
      "mutated_line": "segmentTree(arr, arrTree, 0, len(arr) - -1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - -1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 1, len(arr) - 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 1, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, -1, len(arr) - 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, -1, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 1, len(arr) - 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 1, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) + 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) + 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) * 1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) * 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 1)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, -1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, -1)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 1)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[1]) + 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 2\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[1]) + 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 0\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[1]) + 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 0\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[1]) + -1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + -1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += xx[0]",
      "mutated_line": "ans += xx[1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[1]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += xx[0]",
      "mutated_line": "ans += xx[-1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[-1]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "ans += xx[0]",
      "mutated_line": "ans += xx[1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[1]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "K = K - 1",
      "mutated_line": "K = K - 2",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "K = K - 1",
      "mutated_line": "K = K - 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "K = K - 1",
      "mutated_line": "K = K - 0",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "K = K - 1",
      "mutated_line": "K = K - -1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - -1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 / pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 / pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 + pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 + pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 ** pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 ** pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 2)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 0)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 0)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 2 * pos + -1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + -1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 2, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 2, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 0, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 0, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 0, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 0, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + -1, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + -1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 / pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 / pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 + pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 + pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 ** pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 ** pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 3)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 3)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 1)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 0)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 1)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + -2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + -2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 / pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 / pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 + pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 + pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 ** pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 ** pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 * pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 2]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 * pos + 0]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 0]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 * pos + 0]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 0]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[2 * pos + -1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + -1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 / pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 / pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 + pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 + pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 ** pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 ** pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 * pos + 3]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 3]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 * pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 1]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 * pos + 0]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 0]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 * pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 1]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[2 * pos + -2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + -2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if aa[0] != bb[0]:",
      "mutated_line": "if aa[1] != bb[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[1] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if aa[0] != bb[0]:",
      "mutated_line": "if aa[-1] != bb[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[-1] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if aa[0] != bb[0]:",
      "mutated_line": "if aa[1] != bb[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[1] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if aa[0] != bb[0]:",
      "mutated_line": "if aa[0] != bb[1]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[1]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if aa[0] != bb[0]:",
      "mutated_line": "if aa[0] != bb[-1]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[-1]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if aa[0] != bb[0]:",
      "mutated_line": "if aa[0] != bb[1]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[1]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] <= bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] <= bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] >= bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] >= bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] != bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] != bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] <= bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] <= bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] >= bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] >= bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] != bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] != bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return ('zzz', 1000)",
      "mutated_line": "return ('', 1000)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return ('zzz', 1000)",
      "mutated_line": "return ('zzz', 1001)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1001)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return ('zzz', 1000)",
      "mutated_line": "return ('zzz', 999)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 999)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return ('zzz', 1000)",
      "mutated_line": "return ('zzz', 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 0)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return ('zzz', 1000)",
      "mutated_line": "return ('zzz', 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return ('zzz', 1000)",
      "mutated_line": "return ('zzz', -1000)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', -1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 / pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 / pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 + pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 + pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 ** pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 ** pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 2)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 0)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 0)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + -1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + -1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 2, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 2, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 0, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 0, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 0, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 0, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + -1, high, 2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + -1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 / pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 / pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 + pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 + pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 ** pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 ** pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 3)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 3)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 1)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 0)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 1)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + -2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + -2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if b[0] != c[0]:",
      "mutated_line": "if b[1] != c[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[1] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if b[0] != c[0]:",
      "mutated_line": "if b[-1] != c[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[-1] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if b[0] != c[0]:",
      "mutated_line": "if b[1] != c[0]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[1] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if b[0] != c[0]:",
      "mutated_line": "if b[0] != c[1]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[1]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if b[0] != c[0]:",
      "mutated_line": "if b[0] != c[-1]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[-1]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if b[0] != c[0]:",
      "mutated_line": "if b[0] != c[1]:",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[1]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[0] <= c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] <= c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[0] >= c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] >= c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[0] != c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] != c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[1] <= c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] <= c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[1] >= c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] >= c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[1] != c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] != c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) - 2, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 2, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) - 0, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 0, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) - 0, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 0, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)",
      "mutated_line": "xx = qr(arrTree, start, end, 0, len(arr) - -1, 0)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - -1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 3 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 3 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 1 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 1 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 0 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 0 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, 1 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 1 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "segmentTree(arr, segTree, low, mid, 2 * pos + 1)",
      "mutated_line": "segmentTree(arr, segTree, low, mid, -2 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, -2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 3 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 3 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 1 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 1 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 0 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 0 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, 1 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 1 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "segmentTree(arr, segTree, mid + 1, high, -2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, -2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[3 * pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[3 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[1 * pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[1 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[0 * pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[0 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[1 * pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[1 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "aa = segTree[2 * pos + 1]",
      "mutated_line": "aa = segTree[-2 * pos + 1]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[-2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[3 * pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[3 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[1 * pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[1 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[0 * pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[0 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[1 * pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[1 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bb = segTree[2 * pos + 2]",
      "mutated_line": "bb = segTree[-2 * pos + 2]",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[-2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 3 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 3 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 1 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 1 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 0 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 0 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, 1 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 1 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)",
      "mutated_line": "b = qr(segTree, qLow, qHigh, low, mid, -2 * pos + 1)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, -2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 3 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 3 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 1 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 1 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 0 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 0 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 1 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 1 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)",
      "mutated_line": "c = qr(segTree, qLow, qHigh, mid + 1, high, -2 * pos + 2)",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, -2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[2]) + 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[2]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[0]) + 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[0]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[0]) + 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[0]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "start = int(xx[1]) + 1",
      "mutated_line": "start = int(xx[-1]) + 1",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[-1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] < bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[1] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[-1] < bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[-1] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] < bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[1] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] < bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[1] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] < bb[-1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[-1] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "segTree[pos] = aa if aa[0] < bb[0] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] < bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[1] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[2] < bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[2] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] < bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[0] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[0] < bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[0] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[-1] < bb[1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[-1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] < bb[2] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[2] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] < bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[0] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] < bb[0] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[0] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "segTree[pos] = aa if aa[1] < bb[1] else bb",
      "mutated_line": "segTree[pos] = aa if aa[1] < bb[-1] else bb",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[-1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[1] < c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[1] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[-1] < c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[-1] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[1] < c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[1] < c[0] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[0] < c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[1] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[0] < c[-1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[-1] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "a = b if b[0] < c[0] else c",
      "mutated_line": "a = b if b[0] < c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[1] else c\n        else:\n            a = b if b[1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[2] < c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[2] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[0] < c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[0] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[0] < c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[0] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[-1] < c[1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[-1] < c[1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[1] < c[2] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[2] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[1] < c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[0] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[1] < c[0] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[0] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "a = b if b[1] < c[1] else c",
      "mutated_line": "a = b if b[1] < c[-1] else c",
      "code": "def smallest_lexicographical_subsequence(S, K):\n\n    def segmentTree(arr, segTree, low, high, pos):\n        if low == high:\n            segTree[pos] = (arr[low], low)\n            return\n        mid = (low + high) // 2\n        segmentTree(arr, segTree, low, mid, 2 * pos + 1)\n        segmentTree(arr, segTree, mid + 1, high, 2 * pos + 2)\n        aa = segTree[2 * pos + 1]\n        bb = segTree[2 * pos + 2]\n        if aa[0] != bb[0]:\n            segTree[pos] = aa if aa[0] < bb[0] else bb\n        else:\n            segTree[pos] = aa if aa[1] < bb[1] else bb\n\n    def qr(segTree, qLow, qHigh, low, high, pos):\n        if qLow <= low and qHigh >= high:\n            return segTree[pos]\n        if qLow > high or qHigh < low:\n            return ('zzz', 1000)\n        mid = (low + high) // 2\n        b = qr(segTree, qLow, qHigh, low, mid, 2 * pos + 1)\n        c = qr(segTree, qLow, qHigh, mid + 1, high, 2 * pos + 2)\n        if b[0] != c[0]:\n            a = b if b[0] < c[0] else c\n        else:\n            a = b if b[1] < c[-1] else c\n        return a\n    arr = list(S)\n    ans = ''\n    nn = 1\n    while nn < len(arr):\n        nn *= 2\n    nn = nn * 2 - 1\n    arrTree = [0 for x in range(nn)]\n    segmentTree(arr, arrTree, 0, len(arr) - 1, 0)\n    start = 0\n    while K > 0:\n        end = len(arr) - K\n        xx = qr(arrTree, start, end, 0, len(arr) - 1, 0)\n        start = int(xx[1]) + 1\n        ans += xx[0]\n        K = K - 1\n    return ans"
    }
  ]
}